<?xml version="1.0"?>
<doc>
    <assembly>
        <name>EPPlus</name>
    </assembly>
    <members>
        <member name="T:CellStore`1">
            <summary>
            This is the store for all Rows, Columns and Cells.
            It is a Dictionary implementation that allows you to change the Key (the RowID, ColumnID or CellID )
            </summary>
        </member>
        <member name="M:CellStore`1.DeleteCells(PageIndex,System.Int32,System.Int32,System.Boolean)">
            
        </member>
        <member name="M:CellStore`1.AddPage(ColumnIndex,System.Int32,PageIndex)">
            <summary>
            Add a new page to the collection
            </summary>
            <param name="column">The column</param>
            <param name="pos">Position</param>
            <param name="page">The new page object to add</param>
        </member>
        <member name="M:CellStore`1.AddPage(ColumnIndex,System.Int32)">
            <summary>
            Add a new page to the collection
            </summary>
            <param name="column">The column</param>
            <param name="pos">Position</param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingAverageGroup">
            <summary>
            IExcelConditionalFormattingAverageGroup
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingBeginsWith">
            <summary>
            IExcelConditionalFormattingBeginsWith
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingBetween">
            <summary>
            IExcelConditionalFormattingBetween
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingColorScaleGroup">
            <summary>
            IExcelConditionalFormattingColorScaleGroup
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingContainsBlanks">
            <summary>
            IExcelConditionalFormattingContainsBlanks
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingContainsErrors">
            <summary>
            IExcelConditionalFormattingContainsErrors
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingContainsText">
            <summary>
            IExcelConditionalFormattingContainsText
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingDataBarGroup">
            <summary>
            IExcelConditionalFormattingDataBar
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingDataBarGroup.ShowValue">
            <summary>
            ShowValue
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingDataBarGroup.LowValue">
            <summary>
            Databar Low Value
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingDataBarGroup.HighValue">
            <summary>
            Databar High Value
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingDataBarGroup.Color">
            <summary>
            The color of the databar
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingDuplicateValues">
            <summary>
            IExcelConditionalFormattingDuplicateValues
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingEndsWith">
            <summary>
            IExcelConditionalFormattingEndsWith
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingEqual">
            <summary>
            IExcelConditionalFormattingEqual
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingExpression">
            <summary>
            IExcelConditionalFormattingExpression
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingGreaterThan">
            <summary>
            IExcelConditionalFormattingGreaterThan
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingGreaterThanOrEqual">
            <summary>
            IExcelConditionalFormattingGreaterThanOrEqual
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingThreeIconSet`1">
            <summary>
            IExcelConditionalFormattingThreeIconSet
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingThreeIconSet`1.Icon1">
            <summary>
            Icon1 (part of the 3, 4 ou 5 Icon Set)
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingThreeIconSet`1.Icon2">
            <summary>
            Icon2 (part of the 3, 4 ou 5 Icon Set)
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingThreeIconSet`1.Icon3">
            <summary>
            Icon3 (part of the 3, 4 ou 5 Icon Set)
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingFourIconSet`1">
            <summary>
            IExcelConditionalFormattingFourIconSet
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingFourIconSet`1.Icon4">
            <summary>
            Icon4 (part of the 4 ou 5 Icon Set)
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingFiveIconSet">
            <summary>
            IExcelConditionalFormattingFiveIconSet
            </summary>eExcelconditionalFormatting4IconsSetType
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingFiveIconSet.Icon5">
            <summary>
            Icon5 (part of the 5 Icon Set)
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingIconSetGroup`1">
            <summary>
            IExcelConditionalFormattingIconSetGroup
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingIconSetGroup`1.Reverse">
            <summary>
            Reverse
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingIconSetGroup`1.ShowValue">
            <summary>
            ShowValue
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingIconSetGroup`1.IconSet">
            <summary>
            IconSet (3, 4 ou 5 IconSet)
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingThreeColorScale">
            <summary>
            IExcelConditionalFormattingThreeColorScale
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingThreeColorScale.MiddleValue">
            <summary>
            Three Color Scale Middle Value
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingLessThan">
            <summary>
            IExcelConditionalFormattingLessThan
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingLessThanOrEqual">
            <summary>
            IExcelConditionalFormattingGreaterThanOrEqual
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingNotBetween">
            <summary>
            IExcelConditionalFormattingNotBetween
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingNotContainsBlanks">
            <summary>
            IExcelConditionalFormattingNotContainsBlanks
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingNotContainsErrors">
            <summary>
            IExcelConditionalFormattingNotContainsErrors
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingNotContainsText">
            <summary>
            IExcelConditionalFormattingNotContainsText
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingNotEqual">
            <summary>
            IExcelConditionalFormattingNotEqual
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingStdDevGroup">
            <summary>
            IExcelConditionalFormattingStdDevGroup
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingTimePeriodGroup">
            <summary>
            IExcelConditionalFormattingTimePeriod
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingTopBottomGroup">
            <summary>
            IExcelConditionalFormattingTopBottomGroup
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingTwoColorScale">
            <summary>
            IExcelConditionalFormattingTwoColorScale
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingTwoColorScale.LowValue">
            <summary>
            Two Color Scale Low Value
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingTwoColorScale.HighValue">
            <summary>
            Two Color Scale High Value
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingUniqueValues">
            <summary>
            IExcelConditionalFormattingUniqueValues
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithFormula">
            <summary>
            IExcelConditionalFormattingWithFormula
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithFormula.Formula">
            <summary>
            Formula Attribute
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithFormula2">
            <summary>
            IExcelConditionalFormattingWithFormula2
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithFormula2.Formula2">
            <summary>
            Formula2 Attribute
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithRank">
            <summary>
            IExcelConditionalFormattingWithRank
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithRank.Rank">
            <summary>
            Rank Attribute
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithReverse">
            <summary>
            IExcelConditionalFormattingWithReverse
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithReverse.Reverse">
            <summary>
            Reverse Attribute
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithShowValue">
            <summary>
            IExcelConditionalFormattingWithShowValue
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithShowValue.ShowValue">
            <summary>
            ShowValue Attribute
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithStdDev">
            <summary>
            IExcelConditionalFormattingWithStdDev
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithStdDev.StdDev">
            <summary>
            StdDev Attribute
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithText">
            <summary>
            IExcelConditionalFormattingWithText
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithText.Text">
            <summary>
            Text Attribute
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingRule">
            <summary>
            Interface for conditional formatting rule
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingRule.Node">
            <summary>
            The 'cfRule' XML node
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingRule.Type">
            <summary>
            Type of conditional formatting rule. ST_CfType §18.18.12.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingRule.Address">
            <summary>
            <para>Range over which these conditional formatting rules apply.</para>
            <para>The possible values for this attribute are defined by the
            ST_Sqref simple type (§18.18.76).</para>
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingRule.Priority">
            <summary>
            The priority of this conditional formatting rule. This value is used to determine
            which format should be evaluated and rendered. Lower numeric values are higher
            priority than higher numeric values, where 1 is the highest priority.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingRule.StopIfTrue">
            <summary>
            If this flag is 1, no rules with lower priority shall be applied over this rule,
            when this rule evaluates to true.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingRule.Style">
            <summary>
            Gives access to the differencial styling (DXF) for the rule.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconDataBarValue">
            <summary>
            18.3.1.11 cfvo (Conditional Format Value Object)
            Describes the values of the interpolation points in a gradient scale.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconDataBarValue.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectType,System.Double,System.String,OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Initialize the cfvo (§18.3.1.11) node
            </summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="formula"></param>
            <param name="ruleType"></param>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode">The cfvo (§18.3.1.11) node parent. Can be any of the following:
            colorScale (§18.3.1.16); dataBar (§18.3.1.28); iconSet (§18.3.1.49)</param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconDataBarValue.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Initialize the cfvo (§18.3.1.11) node
            </summary>
            <param name="ruleType"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode">The cfvo (§18.3.1.11) node parent. Can be any of the following:
            colorScale (§18.3.1.16); dataBar (§18.3.1.28); iconSet (§18.3.1.49)</param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconDataBarValue.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectType,System.Double,System.String,OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNamespaceManager)">
            <summary>
            Initialize the <see cref="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingColorScaleValue"/>
            </summary>
            <param name="type"></param>
            <param name="value"></param>
            <param name="formula"></param>
            <param name="ruleType"></param>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconDataBarValue.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectType,System.Drawing.Color,OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNamespaceManager)">
            <summary>
            Initialize the <see cref="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingColorScaleValue"/>
            </summary>
            <param name="type"></param>
            <param name="color"></param>
            <param name="ruleType"></param>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconDataBarValue.RuleType">
            <summary>
            
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconDataBarValue.Type">
            <summary>
            
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconDataBarValue.Value">
            <summary>
            Get/Set the 'cfvo' node @val attribute
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconDataBarValue.Formula">
            <summary>
            Get/Set the Formula of the Object Value (uses the same attribute as the Value)
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingDataBar">
            <summary>
            Databar
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingDataBar.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingDataBar.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingDataBar.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingFiveIconSet">
            <summary>
            ExcelConditionalFormattingThreeIconSet
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingFiveIconSet.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingFiveIconSet.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingFiveIconSet.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingFourIconSet">
            <summary>
            ExcelConditionalFormattingThreeIconSet
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingFourIconSet.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingFourIconSet.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingFourIconSet.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAboveStdDev">
            <summary>
            ExcelConditionalFormattingAboveStdDev
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAboveStdDev.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAboveStdDev.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAboveStdDev.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAboveOrEqualAverage">
            <summary>
            ExcelConditionalFormattingAboveOrEqualAverage
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAboveOrEqualAverage.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAboveOrEqualAverage.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAboveOrEqualAverage.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAverageGroup">
            <summary>
            ExcelConditionalFormattingAverageGroup
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAverageGroup.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAverageGroup.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
             <summary>
             
             </summary>
            <param name="type"></param>
             <param name="priority"></param>
             <param name="address"></param>
             <param name="worksheet"></param>
             <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAverageGroup.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
             <summary>
             
             </summary>
            <param name="type"></param>
             <param name="priority"></param>
             <param name="address"></param>
             <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAboveAverage">
            <summary>
            ExcelConditionalFormattingAboveAverage
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAboveAverage.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAboveAverage.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAboveAverage.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection">
            <summary>
            Collection of <see cref="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule"/>.
            This class is providing the API for EPPlus conditional formatting.
            </summary>
            <remarks>
            <para>
            The public methods of this class (Add[...]ConditionalFormatting) will create a ConditionalFormatting/CfRule entry in the worksheet. When this
            Conditional Formatting has been created changes to the properties will affect the workbook immediately.
            </para>
            <para>
            Each type of Conditional Formatting Rule has diferente set of properties.
            </para>
            <code>
            // Add a Three Color Scale conditional formatting
            var cf = worksheet.ConditionalFormatting.AddThreeColorScale(new ExcelAddress("A1:C10"));
            // Set the conditional formatting properties
            cf.LowValue.Type = ExcelConditionalFormattingValueObjectType.Min;
            cf.LowValue.Color = Color.White;
            cf.MiddleValue.Type = ExcelConditionalFormattingValueObjectType.Percent;
            cf.MiddleValue.Value = 50;
            cf.MiddleValue.Color = Color.Blue;
            cf.HighValue.Type = ExcelConditionalFormattingValueObjectType.Max;
            cf.HighValue.Color = Color.Black;
            </code>
            </remarks>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.#ctor(OfficeOpenXml.ExcelWorksheet)">
            <summary>
            Initialize the <see cref="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection"/>
            </summary>
            <param name="worksheet"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.EnsureRootElementExists">
            <summary>
            
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.GetRootNode">
            <summary>
            GetRootNode
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.ValidateAddress(OfficeOpenXml.ExcelAddress)">
            <summary>
            Validates address - not empty (collisions are allowded)
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.GetNextPriority">
            <summary>
            Get the next priority sequencial number
            </summary>
            <returns></returns>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.Count">
            <summary>
            Number of validations
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.Item(System.Int32)">
            <summary>
            Index operator, returns by 0-based index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.System#Collections#Generic#IEnumerable{OfficeOpenXml#ConditionalFormatting#Contracts#IExcelConditionalFormattingRule}#GetEnumerator">
            <summary>
            Get the 'cfRule' enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get the 'cfRule' enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.RemoveAll">
            <summary>
            Removes all 'cfRule' from the collection and from the XML.
            <remarks>
            This is the same as removing all the 'conditionalFormatting' nodes.
            </remarks>
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.Remove(OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingRule)">
            <summary>
            Remove a Conditional Formatting Rule by its object
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.RemoveAt(System.Int32)">
            <summary>
            Remove a Conditional Formatting Rule by its 0-based index
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.RemoveByPriority(System.Int32)">
            <summary>
            Remove a Conditional Formatting Rule by its priority
            </summary>
            <param name="priority"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.RulesByPriority(System.Int32)">
            <summary>
            Get a rule by its priority
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddRule(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress)">
            <summary>
            Add rule (internal)
            </summary>
            <param name="type"></param>
            <param name="address"></param>
            <returns></returns>F
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddAboveAverage(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add AboveAverage Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddAboveOrEqualAverage(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add AboveOrEqualAverage Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddBelowAverage(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add BelowAverage Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddBelowOrEqualAverage(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add BelowOrEqualAverage Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddAboveStdDev(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add AboveStdDev Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddBelowStdDev(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add BelowStdDev Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddBottom(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add Bottom Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddBottomPercent(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add BottomPercent Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddTop(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add Top Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddTopPercent(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add TopPercent Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddLast7Days(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add Last7Days Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddLastMonth(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add LastMonth Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddLastWeek(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add LastWeek Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddNextMonth(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add NextMonth Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddNextWeek(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add NextWeek Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddThisMonth(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add ThisMonth Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddThisWeek(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add ThisWeek Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddToday(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add Today Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddTomorrow(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add Tomorrow Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddYesterday(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add Yesterday Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddBeginsWith(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add BeginsWith Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddBetween(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add Between Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddContainsBlanks(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add ContainsBlanks Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddContainsErrors(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add ContainsErrors Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddContainsText(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add ContainsText Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddDuplicateValues(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add DuplicateValues Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddEndsWith(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add EndsWith Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddEqual(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add Equal Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddExpression(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add Expression Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddGreaterThan(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add GreaterThan Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddGreaterThanOrEqual(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add GreaterThanOrEqual Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddLessThan(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add LessThan Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddLessThanOrEqual(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add LessThanOrEqual Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddNotBetween(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add NotBetween Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddNotContainsBlanks(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add NotContainsBlanks Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddNotContainsErrors(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add NotContainsErrors Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddNotContainsText(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add NotContainsText Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddNotEqual(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add NotEqual Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddUniqueValues(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add Unique Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddThreeColorScale(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add ThreeColorScale Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddTwoColorScale(OfficeOpenXml.ExcelAddress)">
            <summary>
            Add TwoColorScale Rule
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddThreeIconSet(OfficeOpenXml.ExcelAddress,OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting3IconsSetType)">
            <summary>
            Add ThreeIconSet Rule
            </summary>
            <param name="Address">The address</param>
            <param name="IconSet">Type of iconset</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddFourIconSet(OfficeOpenXml.ExcelAddress,OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting4IconsSetType)">
            <summary>
            Adds a FourIconSet rule
            </summary>
            <param name="Address"></param>
            <param name="IconSet"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddFiveIconSet(OfficeOpenXml.ExcelAddress,OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting5IconsSetType)">
            <summary>
            Adds a FiveIconSet rule
            </summary>
            <param name="Address"></param>
            <param name="IconSet"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection.AddDatabar(OfficeOpenXml.ExcelAddress,System.Drawing.Color)">
            <summary>
            Adds a databar rule
            </summary>
            <param name="Address"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingOperatorType">
            <summary>
            Functions related to the <see cref="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingOperatorType"/>
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingOperatorType.GetAttributeByType(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingOperatorType)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingOperatorType.GetTypeByAttribute(System.String)">
            <summary>
            
            </summary>
            param name="attribute"
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRuleFactory">
            <summary>
            Factory class for ExcelConditionalFormatting.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingConstants">
            <summary>
            The conditional formatting constants
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTimePeriodType">
            <summary>
            Functions related to the <see cref="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTimePeriodType"/>
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTimePeriodType.GetAttributeByType(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingTimePeriodType)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTimePeriodType.GetTypeByAttribute(System.String)">
            <summary>
            
            </summary>
            <param name="attribute"></param>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingColorScaleValue">
            <summary>
            18.3.1.11 cfvo (Conditional Format Value Object)
            Describes the values of the interpolation points in a gradient scale.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingColorScaleValue.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectPosition,OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectType,System.Drawing.Color,System.Double,System.String,OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Initialize the cfvo (§18.3.1.11) node
            </summary>
            <param name="position"></param>
            <param name="type"></param>
            <param name="color"></param>
            <param name="value"></param>
            <param name="formula"></param>
            <param name="ruleType"></param>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode">The cfvo (§18.3.1.11) node parent. Can be any of the following:
            colorScale (§18.3.1.16); dataBar (§18.3.1.28); iconSet (§18.3.1.49)</param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingColorScaleValue.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectPosition,OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectType,System.Drawing.Color,System.Double,System.String,OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNamespaceManager)">
            <summary>
            Initialize the <see cref="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingColorScaleValue"/>
            </summary>
            <param name="position"></param>
            <param name="type"></param>
            <param name="color"></param>
            <param name="value"></param>
            <param name="formula"></param>
            <param name="ruleType"></param>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingColorScaleValue.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectPosition,OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectType,System.Drawing.Color,OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNamespaceManager)">
            <summary>
            Initialize the <see cref="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingColorScaleValue"/>
            </summary>
            <param name="position"></param>
            <param name="type"></param>
            <param name="color"></param>
            <param name="ruleType"></param>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingColorScaleValue.GetNodeOrder">
            <summary>
            Get the node order (1, 2 ou 3) according to the Position (Low, Middle and High)
            and the Rule Type (TwoColorScale ou ThreeColorScale).
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingColorScaleValue.CreateNodeByOrdem(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectNodeType,System.String,System.String)">
            <summary>
            Create the 'cfvo'/'color' nodes in the right order. They should appear like this:
            	"cfvo"   --> Low Value (value object)
            	"cfvo"   --> Middle Value (value object)
            	"cfvo"   --> High Value (value object)
            	"color"  --> Low Value (color)
            	"color"  --> Middle Value (color)
            	"color"  --> High Value (color)
            </summary>
            <param name="nodeType"></param>
            <param name="attributePath"></param>
            <param name="attributeValue"></param>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingColorScaleValue.Position">
            <summary>
            
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingColorScaleValue.RuleType">
            <summary>
            
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingColorScaleValue.Type">
            <summary>
            
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingColorScaleValue.Color">
            <summary>
            
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingColorScaleValue.Value">
            <summary>
            Get/Set the 'cfvo' node @val attribute
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingColorScaleValue.Formula">
            <summary>
            Get/Set the Formula of the Object Value (uses the same attribute as the Value)
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType">
            <summary>
            Enum for Conditional Format Type ST_CfType §18.18.12. With some changes.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.AboveAverage">
            <summary>
            This conditional formatting rule highlights cells that are above the average
            for all values in the range.
            </summary>
            <remarks>AboveAverage Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.AboveOrEqualAverage">
            <summary>
            This conditional formatting rule highlights cells that are above or equal
            the average for all values in the range.
            </summary>
            <remarks>AboveAverage Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.BelowAverage">
            <summary>
            This conditional formatting rule highlights cells that are below the average
            for all values in the range.
            </summary>
            <remarks>AboveAverage Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.BelowOrEqualAverage">
            <summary>
            This conditional formatting rule highlights cells that are below or equal
            the average for all values in the range.
            </summary>
            <remarks>AboveAverage Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.AboveStdDev">
            <summary>
            This conditional formatting rule highlights cells that are above the standard
            deviationa for all values in the range.
            <remarks>AboveAverage Excel CF Rule Type</remarks>
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.BelowStdDev">
            <summary>
            This conditional formatting rule highlights cells that are below the standard
            deviationa for all values in the range.
            </summary>
            <remarks>AboveAverage Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.Bottom">
            <summary>
            This conditional formatting rule highlights cells whose values fall in the
            bottom N bracket as specified.
            </summary>
            <remarks>Top10 Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.BottomPercent">
            <summary>
            This conditional formatting rule highlights cells whose values fall in the
            bottom N percent as specified.
            </summary>
            <remarks>Top10 Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.Top">
            <summary>
            This conditional formatting rule highlights cells whose values fall in the
            top N bracket as specified.
            </summary>
            <remarks>Top10 Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.TopPercent">
            <summary>
            This conditional formatting rule highlights cells whose values fall in the
            top N percent as specified.
            </summary>
            <remarks>Top10 Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.Last7Days">
            <summary>
            This conditional formatting rule highlights cells containing dates in the
            last 7 days.
            </summary>
            <remarks>TimePeriod Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.LastMonth">
            <summary>
            This conditional formatting rule highlights cells containing dates in the
            last month.
            </summary>
            <remarks>TimePeriod Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.LastWeek">
            <summary>
            This conditional formatting rule highlights cells containing dates in the
            last week.
            </summary>
            <remarks>TimePeriod Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.NextMonth">
            <summary>
            This conditional formatting rule highlights cells containing dates in the
            next month.
            </summary>
            <remarks>TimePeriod Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.NextWeek">
            <summary>
            This conditional formatting rule highlights cells containing dates in the
            next week.
            </summary>
            <remarks>TimePeriod Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.ThisMonth">
            <summary>
            This conditional formatting rule highlights cells containing dates in this
            month.
            </summary>
            <remarks>TimePeriod Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.ThisWeek">
            <summary>
            This conditional formatting rule highlights cells containing dates in this
            week.
            </summary>
            <remarks>TimePeriod Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.Today">
            <summary>
            This conditional formatting rule highlights cells containing today dates.
            </summary>
            <remarks>TimePeriod Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.Tomorrow">
            <summary>
            This conditional formatting rule highlights cells containing tomorrow dates.
            </summary>
            <remarks>TimePeriod Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.Yesterday">
            <summary>
            This conditional formatting rule highlights cells containing yesterday dates.
            </summary>
            <remarks>TimePeriod Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.BeginsWith">
            <summary>
            This conditional formatting rule highlights cells in the range that begin with
            the given text.
            </summary>
            <remarks>
            Equivalent to using the LEFT() sheet function and comparing values.
            </remarks>
            <remarks>BeginsWith Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.Between">
            <summary>
            This conditional formatting rule highlights cells in the range between the
            given two formulas.
            </summary>
            <remarks>CellIs Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.ContainsBlanks">
            <summary>
            This conditional formatting rule highlights cells that are completely blank.
            </summary>
            <remarks>
            Equivalent of using LEN(TRIM()). This means that if the cell contains only
            characters that TRIM() would remove, then it is considered blank. An empty cell
            is also considered blank.
            </remarks>
            <remarks>ContainsBlanks Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.ContainsErrors">
            <summary>
            This conditional formatting rule highlights cells with formula errors.
            </summary>
            <remarks>
            Equivalent to using ISERROR() sheet function to determine if there is
            a formula error.
            </remarks>
            <remarks>ContainsErrors Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.ContainsText">
            <summary>
            This conditional formatting rule highlights cells in the range that begin with
            the given text.
            </summary>
            <remarks>
            Equivalent to using the LEFT() sheet function and comparing values.
            </remarks>
            <remarks>ContainsText Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.DuplicateValues">
            <summary>
            This conditional formatting rule highlights duplicated values.
            </summary>
            <remarks>DuplicateValues Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.EndsWith">
            <summary>
            This conditional formatting rule highlights cells ending with given text.
            </summary>
            <remarks>
            Equivalent to using the RIGHT() sheet function and comparing values.
            </remarks>
            <remarks>EndsWith Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.Equal">
            <summary>
            This conditional formatting rule highlights cells equals to with given formula.
            </summary>
            <remarks>CellIs Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.Expression">
            <summary>
            This conditional formatting rule contains a formula to evaluate. When the 
            formula result is true, the cell is highlighted.
            </summary>
            <remarks>Expression Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.GreaterThan">
            <summary>
            This conditional formatting rule highlights cells greater than the given formula.
            </summary>
            <remarks>CellIs Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.GreaterThanOrEqual">
            <summary>
            This conditional formatting rule highlights cells greater than or equal the
            given formula.
            </summary>
            <remarks>CellIs Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.LessThan">
            <summary>
            This conditional formatting rule highlights cells less than the given formula.
            </summary>
            <remarks>CellIs Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.LessThanOrEqual">
            <summary>
            This conditional formatting rule highlights cells less than or equal the
            given formula.
            </summary>
            <remarks>CellIs Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.NotBetween">
            <summary>
            This conditional formatting rule highlights cells outside the range in
            given two formulas.
            </summary>
            <remarks>CellIs Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.NotContains">
            <summary>
            This conditional formatting rule highlights cells that does not contains the
            given formula.
            </summary>
            <remarks>CellIs Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.NotContainsBlanks">
            <summary>
            This conditional formatting rule highlights cells that are not blank.
            </summary>
            <remarks>
            Equivalent of using LEN(TRIM()). This means that if the cell contains only
            characters that TRIM() would remove, then it is considered blank. An empty cell
            is also considered blank.
            </remarks>
            <remarks>NotContainsBlanks Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.NotContainsErrors">
            <summary>
            This conditional formatting rule highlights cells without formula errors.
            </summary>
            <remarks>
            Equivalent to using ISERROR() sheet function to determine if there is a
            formula error.
            </remarks>
            <remarks>NotContainsErrors Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.NotContainsText">
            <summary>
            This conditional formatting rule highlights cells that do not contain
            the given text.
            </summary>
            <remarks>
            Equivalent to using the SEARCH() sheet function.
            </remarks>
            <remarks>NotContainsText Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.NotEqual">
            <summary>
            This conditional formatting rule highlights cells not equals to with
            given formula.
            </summary>
            <remarks>CellIs Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.UniqueValues">
            <summary>
            This conditional formatting rule highlights unique values in the range.
            </summary>
            <remarks>UniqueValues Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.ThreeColorScale">
            <summary>
            Three Color Scale (Low, Middle and High Color Scale)
            </summary>
            <remarks>ColorScale Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.TwoColorScale">
            <summary>
            Two Color Scale (Low and High Color Scale)
            </summary>
            <remarks>ColorScale Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.ThreeIconSet">
            <summary>
            This conditional formatting rule applies a 3 set icons to cells according
            to their values.
            </summary>
            <remarks>IconSet Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.FourIconSet">
            <summary>
            This conditional formatting rule applies a 4 set icons to cells according
            to their values.
            </summary>
            <remarks>IconSet Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.FiveIconSet">
            <summary>
            This conditional formatting rule applies a 5 set icons to cells according
            to their values.
            </summary>
            <remarks>IconSet Excel CF Rule Type</remarks>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType.DataBar">
            <summary>
            This conditional formatting rule displays a gradated data bar in the range of cells.
            </summary>
            <remarks>DataBar Excel CF Rule Type</remarks>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectType">
            <summary>
            Enum for Conditional Format Value Object Type ST_CfvoType §18.18.13
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectType.Formula">
            <summary>
            Formula
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectType.Max">
            <summary>
            Maximum Value
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectType.Min">
            <summary>
            Minimum Value
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectType.Num">
            <summary>
            Number Value
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectType.Percent">
            <summary>
            Percent
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectType.Percentile">
            <summary>
            Percentile
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectPosition">
            <summary>
            Enum for Conditional Formatting Value Object Position
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectPosition.Low">
            <summary>
            The lower position for both TwoColorScale and ThreeColorScale
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectPosition.Middle">
            <summary>
            The middle position only for ThreeColorScale
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectPosition.High">
            <summary>
            The highest position for both TwoColorScale and ThreeColorScale
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectNodeType">
            <summary>
            Enum for Conditional Formatting Value Object Node Type
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectNodeType.Cfvo">
            <summary>
            'cfvo' node
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectNodeType.Color">
            <summary>
            'color' node
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingOperatorType">
            <summary>
            Enum for Conditional Formatting Operartor Type ST_ConditionalFormattingOperator §18.18.15
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingOperatorType.BeginsWith">
            <summary>
            Begins With. 'Begins with' operator
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingOperatorType.Between">
            <summary>
            Between. 'Between' operator
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingOperatorType.ContainsText">
            <summary>
            Contains. 'Contains' operator
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingOperatorType.EndsWith">
            <summary>
            Ends With. 'Ends with' operator
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingOperatorType.Equal">
            <summary>
            Equal. 'Equal to' operator
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingOperatorType.GreaterThan">
            <summary>
            Greater Than. 'Greater than' operator
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingOperatorType.GreaterThanOrEqual">
            <summary>
            Greater Than Or Equal. 'Greater than or equal to' operator
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingOperatorType.LessThan">
            <summary>
            Less Than. 'Less than' operator
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingOperatorType.LessThanOrEqual">
            <summary>
            Less Than Or Equal. 'Less than or equal to' operator
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingOperatorType.NotBetween">
            <summary>
            Not Between. 'Not between' operator
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingOperatorType.NotContains">
            <summary>
            Does Not Contain. 'Does not contain' operator
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingOperatorType.NotEqual">
            <summary>
            Not Equal. 'Not equal to' operator
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingTimePeriodType">
            <summary>
            Enum for Conditional Formatting Time Period Type ST_TimePeriod §18.18.82
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingTimePeriodType.Last7Days">
            <summary>
            Last 7 Days. A date in the last seven days.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingTimePeriodType.LastMonth">
            <summary>
            Last Month. A date occuring in the last calendar month.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingTimePeriodType.LastWeek">
            <summary>
            Last Week. A date occuring last week.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingTimePeriodType.NextMonth">
            <summary>
            Next Month. A date occuring in the next calendar month.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingTimePeriodType.NextWeek">
            <summary>
            Next Week. A date occuring next week.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingTimePeriodType.ThisMonth">
            <summary>
            This Month. A date occuring in this calendar month.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingTimePeriodType.ThisWeek">
            <summary>
            This Week. A date occuring this week.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingTimePeriodType.Today">
            <summary>
            Today. Today's date.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingTimePeriodType.Tomorrow">
            <summary>
            Tomorrow. Tomorrow's date.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingTimePeriodType.Yesterday">
            <summary>
            Yesterday. Yesterday's date.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting3IconsSetType">
            <summary>
            18.18.42 ST_IconSetType (Icon Set Type) - Only 3 icons
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting3IconsSetType.Arrows">
            <summary>
            (3 Arrows) 3 arrows icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting3IconsSetType.ArrowsGray">
            <summary>
            (3 Arrows (Gray)) 3 gray arrows icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting3IconsSetType.Flags">
            <summary>
            (3 Flags) 3 flags icon set. 
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting3IconsSetType.Signs">
            <summary>
            (3 Signs) 3 signs icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting3IconsSetType.Symbols">
            <summary>
            (3 Symbols Circled) 3 symbols icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting3IconsSetType.Symbols2">
            <summary>
            (3 Symbols) 3 Symbols icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting3IconsSetType.TrafficLights1">
            <summary>
            (3 Traffic Lights) 3 traffic lights icon set (#1).
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting3IconsSetType.TrafficLights2">
            <summary>
            (3 Traffic Lights Black) 3 traffic lights icon set with thick black border.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting4IconsSetType">
            <summary>
            18.18.42 ST_IconSetType (Icon Set Type) - Only 4 icons
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting4IconsSetType.Arrows">
            <summary>
            (4 Arrows) 4 arrows icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting4IconsSetType.ArrowsGray">
            <summary>
            (4 Arrows (Gray)) 4 gray arrows icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting4IconsSetType.Rating">
            <summary>
            (4 Ratings) 4 ratings icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting4IconsSetType.RedToBlack">
            <summary>
            (4 Red To Black) 4 'red to black' icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting4IconsSetType.TrafficLights">
            <summary>
            (4 Traffic Lights) 4 traffic lights icon set.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting5IconsSetType">
            <summary>
            18.18.42 ST_IconSetType (Icon Set Type) - Only 5 icons
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting5IconsSetType.Arrows">
            <summary>
            (5 Arrows) 5 arrows icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting5IconsSetType.ArrowsGray">
            <summary>
            (5 Arrows (Gray)) 5 gray arrows icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting5IconsSetType.Quarters">
            <summary>
            (5 Quarters) 5 quarters icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting5IconsSetType.Rating">
            <summary>
            (5 Ratings Icon Set) 5 rating icon set.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormattingIconsSetType">
            <summary>
            18.18.42 ST_IconSetType (Icon Set Type)
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormattingIconsSetType.ThreeArrows">
            <summary>
            (3 Arrows) 3 arrows icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormattingIconsSetType.ThreeArrowsGray">
            <summary>
            (3 Arrows (Gray)) 3 gray arrows icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormattingIconsSetType.ThreeFlags">
            <summary>
            (3 Flags) 3 flags icon set. 
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormattingIconsSetType.ThreeSigns">
            <summary>
            (3 Signs) 3 signs icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormattingIconsSetType.ThreeSymbols">
            <summary>
            (3 Symbols Circled) 3 symbols icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormattingIconsSetType.ThreeSymbols2">
            <summary>
            (3 Symbols) 3 Symbols icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormattingIconsSetType.ThreeTrafficLights1">
            <summary>
            (3 Traffic Lights) 3 traffic lights icon set (#1).
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormattingIconsSetType.ThreeTrafficLights2">
            <summary>
            (3 Traffic Lights Black) 3 traffic lights icon set with thick black border.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormattingIconsSetType.FourArrows">
            <summary>
            (4 Arrows) 4 arrows icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormattingIconsSetType.FourArrowsGray">
            <summary>
            (4 Arrows (Gray)) 4 gray arrows icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormattingIconsSetType.FourRating">
            <summary>
            (4 Ratings) 4 ratings icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormattingIconsSetType.FourRedToBlack">
            <summary>
            (4 Red To Black) 4 'red to black' icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormattingIconsSetType.FourTrafficLights">
            <summary>
            (4 Traffic Lights) 4 traffic lights icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormattingIconsSetType.FiveArrows">
            <summary>
            (5 Arrows) 5 arrows icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormattingIconsSetType.FiveArrowsGray">
            <summary>
            (5 Arrows (Gray)) 5 gray arrows icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormattingIconsSetType.FiveQuarters">
            <summary>
            (5 Quarters) 5 quarters icon set.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormattingIconsSetType.FiveRating">
            <summary>
            (5 Ratings Icon Set) 5 rating icon set.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingValueObjectType">
            <summary>
            Functions related to the <see cref="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingColorScaleValue"/>
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingValueObjectType.GetOrderByPosition(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectPosition,OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType)">
            <summary>
            Get the sequencial order of a cfvo/color by its position.
            </summary>
            <param name="position"></param>
            <param name="ruleType"></param>
            <returns>1, 2 or 3</returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingValueObjectType.GetTypeByAttrbiute(System.String)">
            <summary>
            Get the CFVO type by its @type attribute
            </summary>
            <param name="attribute"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingValueObjectType.GetCfvoNodeByPosition(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectPosition,OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
             <summary>
             
             </summary>
             <param name="position"></param>
            <param name="ruleType"></param>
             <param name="topNode"></param>
             <param name="nameSpaceManager"></param>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingValueObjectType.GetAttributeByType(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectType)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingValueObjectType.GetParentPathByRuleType(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType)">
            <summary>
            Get the cfvo (§18.3.1.11) node parent by the rule type. Can be any of the following:
            "colorScale" (§18.3.1.16); "dataBar" (§18.3.1.28); "iconSet" (§18.3.1.49)
            </summary>
            <param name="ruleType"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingValueObjectType.GetNodePathByNodeType(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectNodeType)">
            <summary>
            
            </summary>
            <param name="nodeType"></param>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBeginsWith">
            <summary>
            ExcelConditionalFormattingBeginsWith
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBeginsWith.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBeginsWith.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBeginsWith.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBeginsWith.Text">
            <summary>
            The text to search in the beginning of the cell
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBelowAverage">
            <summary>
            ExcelConditionalFormattingBelowAverage
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBelowAverage.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBelowAverage.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBelowAverage.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBelowOrEqualAverage">
            <summary>
            ExcelConditionalFormattingBelowOrEqualAverage
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBelowOrEqualAverage.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBelowOrEqualAverage.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBelowOrEqualAverage.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBelowStdDev">
            <summary>
            ExcelConditionalFormattingBelowStdDev
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBelowStdDev.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBelowStdDev.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBelowStdDev.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBetween">
            <summary>
            ExcelConditionalFormattingBetween
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBetween.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBetween.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBetween.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBottom">
            <summary>
            ExcelConditionalFormattingBottom
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBottom.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBottom.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBottom.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBottomPercent">
            <summary>
            ExcelConditionalFormattingBottomPercent
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBottomPercent.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBottomPercent.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBottomPercent.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingContainsBlanks">
            <summary>
            ExcelConditionalFormattingContainsBlanks
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingContainsBlanks.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingContainsBlanks.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingContainsBlanks.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingContainsErrors">
            <summary>
            ExcelConditionalFormattingContainsErrors
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingContainsErrors.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingContainsErrors.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingContainsErrors.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingContainsText">
            <summary>
            ExcelConditionalFormattingContainsText
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingContainsText.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingContainsText.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingContainsText.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingContainsText.Text">
            <summary>
            The text to search inside the cell
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingDuplicateValues">
            <summary>
            ExcelConditionalFormattingDuplicateValues
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingDuplicateValues.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingDuplicateValues.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingDuplicateValues.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingEndsWith">
            <summary>
            ExcelConditionalFormattingEndsWith
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingEndsWith.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingEndsWith.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingEndsWith.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingEndsWith.Text">
            <summary>
            The text to search in the end of the cell
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingEqual">
            <summary>
            ExcelConditionalFormattingEqual
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingEqual.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingEqual.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingEqual.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingExpression">
            <summary>
            ExcelConditionalFormattingExpression
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingExpression.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingExpression.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingExpression.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingGreaterThan">
            <summary>
            ExcelConditionalFormattingGreaterThan
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingGreaterThan.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingGreaterThan.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingGreaterThan.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingGreaterThanOrEqual">
            <summary>
            ExcelConditionalFormattingGreaterThanOrEqual
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingGreaterThanOrEqual.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingGreaterThanOrEqual.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingGreaterThanOrEqual.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLast7Days">
            <summary>
            ExcelConditionalFormattingLast7Days
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLast7Days.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLast7Days.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLast7Days.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLastMonth">
            <summary>
            ExcelConditionalFormattingLastMonth
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLastMonth.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLastMonth.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLastMonth.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLastWeek">
            <summary>
            ExcelConditionalFormattingLastWeek
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLastWeek.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLastWeek.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLastWeek.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLessThan">
            <summary>
            ExcelConditionalFormattingLessThan
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLessThan.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLessThan.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLessThan.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLessThanOrEqual">
            <summary>
            ExcelConditionalFormattingLessThanOrEqual
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLessThanOrEqual.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLessThanOrEqual.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLessThanOrEqual.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNextMonth">
            <summary>
            ExcelConditionalFormattingNextMonth
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNextMonth.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNextMonth.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNextMonth.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNextWeek">
            <summary>
            ExcelConditionalFormattingNextWeek
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNextWeek.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNextWeek.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNextWeek.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotBetween">
            <summary>
            ExcelConditionalFormattingNotBetween
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotBetween.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotBetween.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotBetween.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotContainsBlanks">
            <summary>
            ExcelConditionalFormattingNotContainsBlanks
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotContainsBlanks.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotContainsBlanks.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotContainsBlanks.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotContainsErrors">
            <summary>
            ExcelConditionalFormattingNotContainsErrors
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotContainsErrors.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotContainsErrors.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotContainsErrors.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotContainsText">
            <summary>
            ExcelConditionalFormattingNotContainsText
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotContainsText.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotContainsText.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotContainsText.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotContainsText.Text">
            <summary>
            The text to search inside the cell
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotEqual">
            <summary>
            ExcelConditionalFormattingNotEqual
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotEqual.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotEqual.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotEqual.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule">
            <summary>
            
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule._changingPriority">
            <summary>
            Sinalize that we are in a Cnaging Priorities opeartion so that we won't enter
            a recursive loop.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Initialize the <see cref="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule"/>
            </summary>
            <param name="type"></param>
            <param name="address"></param>
            <param name="priority">Used also as the cfRule unique key</param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNamespaceManager)">
            <summary>
            Initialize the <see cref="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule"/>
            </summary>
            <param name="type"></param>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule.Node">
            <summary>
            Get the &lt;cfRule&gt; node
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule.Address">
            <summary>
            Address of the conditional formatting rule
            </summary>
            <remarks>
            The address is stores in a parent node called &lt;conditionalFormatting&gt; in the
            @sqref attribute. Excel groups rules that have the same address inside one node.
            </remarks>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule.Type">
            <summary>
            Type of conditional formatting rule. ST_CfType §18.18.12.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule.Priority">
            <summary>
            The priority of this conditional formatting rule. This value is used to determine
            which format should be evaluated and rendered. Lower numeric values are higher
            priority than higher numeric values, where 1 is the highest priority.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule.StopIfTrue">
            <summary>
            If this flag is true, no rules with lower priority shall be applied over this rule,
            when this rule evaluates to true.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule.DxfId">
            <summary>
            DxfId Style Attribute
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule.StdDev">
            <summary>
            StdDev (zero is not allowed and will be converted to 1)
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule.Rank">
            <summary>
            Rank (zero is not allowed and will be converted to 1)
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule.AboveAverage">
            <summary>
            AboveAverage
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule.EqualAverage">
            <summary>
            EqualAverage
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule.Bottom">
            <summary>
            Bottom attribute
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule.Percent">
            <summary>
            Percent attribute
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule.TimePeriod">
            <summary>
            TimePeriod
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule.Operator">
            <summary>
            Operator
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule.Formula">
            <summary>
            Formula
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule.Formula2">
            <summary>
            Formula2
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRuleType">
            <summary>
            Functions related to the ExcelConditionalFormattingRule
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRuleType.GetTypeByAttrbiute(System.String,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="attribute"></param>
            <param name="topNode"></param>
            <param name="nameSpaceManager"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRuleType.GetColorScaleType(System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Get the "colorScale" rule type according to the number of "cfvo" and "color" nodes.
            If we have excatly 2 "cfvo" and "color" childs, then we return "twoColorScale"
            </summary>
            <returns>TwoColorScale or ThreeColorScale</returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRuleType.GetAboveAverageType(System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Get the "aboveAverage" rule type according to the follwoing attributes:
            "AboveAverage", "EqualAverage" and "StdDev".
            
            @StdDev greater than "0"                              == AboveStdDev
            @StdDev less than "0"                                 == BelowStdDev
            @AboveAverage = "1"/null and @EqualAverage = "0"/null == AboveAverage
            @AboveAverage = "1"/null and @EqualAverage = "1"      == AboveOrEqualAverage
            @AboveAverage = "0" and @EqualAverage = "0"/null      == BelowAverage
            @AboveAverage = "0" and @EqualAverage = "1"           == BelowOrEqualAverage
            /// </summary>
            <returns>AboveAverage, AboveOrEqualAverage, BelowAverage or BelowOrEqualAverage</returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRuleType.GetTop10Type(System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Get the "top10" rule type according to the follwoing attributes:
            "Bottom" and "Percent"
            
            @Bottom = "1" and @Percent = "0"/null       == Bottom
            @Bottom = "1" and @Percent = "1"            == BottomPercent
            @Bottom = "0"/null and @Percent = "0"/null  == Top
            @Bottom = "0"/null and @Percent = "1"       == TopPercent
            /// </summary>
            <returns>Top, TopPercent, Bottom or BottomPercent</returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRuleType.GetTimePeriodType(System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Get the "timePeriod" rule type according to "TimePeriod" attribute.
            /// </summary>
            <returns>Last7Days, LastMonth etc.</returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRuleType.GetAttributeByType(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRuleType.GetCfvoParentPathByType(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType)">
            <summary>
            Return cfvo §18.3.1.11 parent according to the rule type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThisMonth">
            <summary>
            ExcelConditionalFormattingThisMonth
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThisMonth.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThisMonth.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThisMonth.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThisWeek">
            <summary>
            ExcelConditionalFormattingThisWeek
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThisWeek.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThisWeek.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThisWeek.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThreeColorScale">
            <summary>
            ExcelConditionalFormattingThreeColorScale
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThreeColorScale._lowValue">
            <summary>
            Private Low Value
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThreeColorScale._middleValue">
            <summary>
            Private Middle Value
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThreeColorScale._highValue">
            <summary>
            Private High Value
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThreeColorScale.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThreeColorScale.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThreeColorScale.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThreeColorScale.LowValue">
            <summary>
            Low Value for Three Color Scale Object Value
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThreeColorScale.MiddleValue">
            <summary>
            Middle Value for Three Color Scale Object Value
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThreeColorScale.HighValue">
            <summary>
            High Value for Three Color Scale Object Value
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconSetBase`1">
            <summary>
            ExcelConditionalFormattingThreeIconSet
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconSetBase`1.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconSetBase`1.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
             <summary>
             
             </summary>
            <param name="type"></param>
             <param name="priority"></param>
             <param name="address"></param>
             <param name="worksheet"></param>
             <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconSetBase`1.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
             <summary>
             
             </summary>
            <param name="type"></param>
             <param name="priority"></param>
             <param name="address"></param>
             <param name="worksheet"></param>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconSetBase`1.Icon1">
            <summary>
            Settings for icon 1 in the iconset
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconSetBase`1.Icon2">
            <summary>
            Settings for icon 2 in the iconset
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconSetBase`1.Icon3">
            <summary>
            Settings for icon 2 in the iconset
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconSetBase`1.Reverse">
            <summary>
            Reverse the order of the icons
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconSetBase`1.ShowValue">
            <summary>
            If the cell values are visible
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconSetBase`1.IconSet">
            <summary>
            Type of iconset
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTimePeriodGroup">
            <summary>
            ExcelConditionalFormattingTimePeriodGroup
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTimePeriodGroup.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTimePeriodGroup.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTimePeriodGroup.#ctor(OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType,OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingToday">
            <summary>
            ExcelConditionalFormattingToday
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingToday.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingToday.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingToday.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTomorrow">
            <summary>
            ExcelConditionalFormattingTomorrow
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTomorrow.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTomorrow.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTomorrow.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTop">
            <summary>
            ExcelConditionalFormattingTop
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTop.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTop.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTop.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTopPercent">
            <summary>
            ExcelConditionalFormattingTopPercent
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTopPercent.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTopPercent.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTopPercent.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTwoColorScale">
            <summary>
            ExcelConditionalFormattingTwoColorScale
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTwoColorScale._lowValue">
            <summary>
            Private Low Value
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTwoColorScale._highValue">
            <summary>
            Private High Value
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTwoColorScale.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTwoColorScale.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTwoColorScale.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTwoColorScale.LowValue">
            <summary>
            Low Value for Two Color Scale Object Value
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTwoColorScale.HighValue">
            <summary>
            High Value for Two Color Scale Object Value
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingHelper">
            <summary>
            Conditional formatting helper
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingHelper.CheckAndFixRangeAddress(System.String)">
            <summary>
            Check and fix an address (string address)
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingHelper.ConvertFromColorCode(System.String)">
            <summary>
            Convert a color code to Color Object
            </summary>
            <param name="colorCode">Color Code (Ex. "#FFB43C53" or "FFB43C53")</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingHelper.GetAttributeString(System.Xml.XmlNode,System.String)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="attribute"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingHelper.GetAttributeInt(System.Xml.XmlNode,System.String)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="attribute"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingHelper.GetAttributeIntNullable(System.Xml.XmlNode,System.String)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="attribute"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingHelper.GetAttributeBool(System.Xml.XmlNode,System.String)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="attribute"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingHelper.GetAttributeBoolNullable(System.Xml.XmlNode,System.String)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="attribute"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingHelper.GetAttributeDouble(System.Xml.XmlNode,System.String)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="attribute"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingHelper.GetAttributeDecimal(System.Xml.XmlNode,System.String)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="attribute"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingHelper.EncodeXML(System.String)">
            <summary>
            Encode to XML (special characteres: &apos; &quot; &gt; &lt; &amp;)
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingHelper.DecodeXML(System.String)">
            <summary>
            Decode from XML (special characteres: &apos; &quot; &gt; &lt; &amp;)
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting">
            <summary>
            Provides functionality for adding Conditional Formatting to a range (<see cref="T:OfficeOpenXml.ExcelRangeBase"/>).
            Each method will return a configurable condtional formatting type.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddAboveAverage">
            <summary>
            Adds a Above Average rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddAboveOrEqualAverage">
            <summary>
            Adds a Above Or Equal Average rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddBelowAverage">
            <summary>
            Adds a Below Average rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddBelowOrEqualAverage">
            <summary>
            Adds a Below Or Equal Average rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddAboveStdDev">
            <summary>
            Adds a Above StdDev rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddBelowStdDev">
            <summary>
            Adds a Below StdDev rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddBottom">
            <summary>
            Adds a Bottom rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddBottomPercent">
            <summary>
            Adds a Bottom Percent rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddTop">
            <summary>
            Adds a Top rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddTopPercent">
            <summary>
            Adds a Top Percent rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddLast7Days">
            <summary>
            Adds a Last 7 Days rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddLastMonth">
            <summary>
            Adds a Last Month rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddLastWeek">
            <summary>
            Adds a Last Week rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddNextMonth">
            <summary>
            Adds a Next Month rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddNextWeek">
            <summary>
            Adds a Next Week rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddThisMonth">
            <summary>
            Adds a This Month rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddThisWeek">
            <summary>
            Adds a This Week rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddToday">
            <summary>
            Adds a Today rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddTomorrow">
            <summary>
            Adds a Tomorrow rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddYesterday">
            <summary>
            Adds a Yesterday rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddBeginsWith">
            <summary>
            Adds a Begins With rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddBetween">
            <summary>
            Adds a Between rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddContainsBlanks">
            <summary>
            Adds a ContainsBlanks rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddContainsErrors">
            <summary>
            Adds a ContainsErrors rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddContainsText">
            <summary>
            Adds a ContainsText rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddDuplicateValues">
            <summary>
            Adds a DuplicateValues rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddEndsWith">
            <summary>
            Adds a EndsWith rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddEqual">
            <summary>
            Adds a Equal rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddExpression">
            <summary>
            Adds a Expression rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddGreaterThan">
            <summary>
            Adds a GreaterThan rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddGreaterThanOrEqual">
            <summary>
            Adds a GreaterThanOrEqual rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddLessThan">
            <summary>
            Adds a LessThan rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddLessThanOrEqual">
            <summary>
            Adds a LessThanOrEqual rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddNotBetween">
            <summary>
            Adds a NotBetween rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddNotContainsBlanks">
            <summary>
            Adds a NotContainsBlanks rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddNotContainsErrors">
            <summary>
            Adds a NotContainsErrors rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddNotContainsText">
            <summary>
            Adds a NotContainsText rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddNotEqual">
            <summary>
            Adds a NotEqual rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddUniqueValues">
            <summary>
            Adds a UniqueValues rule to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddThreeColorScale">
            <summary>
            Adds a <see cref="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThreeColorScale"/> to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddTwoColorScale">
            <summary>
            Adds a <see cref="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTwoColorScale"/> to the range
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddThreeIconSet(OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting3IconsSetType)">
            <summary>
            Adds a <see cref="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingThreeIconSet`1"/> to the range
            </summary>
            <param name="IconSet"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddFourIconSet(OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting4IconsSetType)">
            <summary>
            Adds a <see cref="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingFourIconSet`1"/> to the range
            </summary>
            <param name="IconSet"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddFiveIconSet(OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting5IconsSetType)">
            <summary>
            Adds a <see cref="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingFiveIconSet"/> to the range
            </summary>
            <param name="IconSet"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting.AddDatabar(System.Drawing.Color)">
            <summary>
            Adds a <see cref="T:OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingDataBarGroup"/> to the range
            </summary>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddAboveAverage">
            <summary>
            Add AboveOrEqualAverage Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddAboveOrEqualAverage">
            <summary>
            Add AboveOrEqualAverage Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddBelowAverage">
            <summary>
            Add BelowOrEqualAverage Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddBelowOrEqualAverage">
            <summary>
            Add BelowOrEqualAverage Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddAboveStdDev">
            <summary>
            Add AboveStdDev Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddBelowStdDev">
            <summary>
            Add BelowStdDev Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddBottom">
            <summary>
            Add Bottom Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddBottomPercent">
            <summary>
            Add BottomPercent Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddTop">
            <summary>
            Add Top Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddTopPercent">
            <summary>
            Add TopPercent Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddLast7Days">
            <summary>
            Add Last7Days Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddLastMonth">
            <summary>
            Add LastMonth Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddLastWeek">
            <summary>
            Add LastWeek Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddNextMonth">
            <summary>
            Add NextMonth Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddNextWeek">
            <summary>
            Add NextWeek Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddThisMonth">
            <summary>
            Add ThisMonth Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddThisWeek">
            <summary>
            Add ThisWeek Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddToday">
            <summary>
            Add Today Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddTomorrow">
            <summary>
            Add Tomorrow Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddYesterday">
            <summary>
            Add Yesterday Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddBeginsWith">
            <summary>
            Add BeginsWith Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddBetween">
            <summary>
            Add Between Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddContainsBlanks">
            <summary>
            Add ContainsBlanks Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddContainsErrors">
            <summary>
            Add ContainsErrors Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddContainsText">
            <summary>
            Add ContainsText Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddDuplicateValues">
            <summary>
            Add DuplicateValues Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddEndsWith">
            <summary>
            Add EndsWith Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddEqual">
            <summary>
            Add Equal Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddExpression">
            <summary>
            Add Expression Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddGreaterThan">
            <summary>
            Add GreaterThan Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddGreaterThanOrEqual">
            <summary>
            Add GreaterThanOrEqual Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddLessThan">
            <summary>
            Add LessThan Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddLessThanOrEqual">
            <summary>
            Add LessThanOrEqual Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddNotBetween">
            <summary>
            Add NotBetween Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddNotContainsBlanks">
            <summary>
            Add NotContainsBlanks Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddNotContainsErrors">
            <summary>
            Add NotContainsErrors Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddNotContainsText">
            <summary>
            Add NotContainsText Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddNotEqual">
            <summary>
            Add NotEqual Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddUniqueValues">
            <summary>
            Add UniqueValues Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddThreeColorScale">
            <summary>
            Add ThreeColorScale Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddTwoColorScale">
            <summary>
            Add TwoColorScale Conditional Formatting
            </summary>
             <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddThreeIconSet(OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting3IconsSetType)">
            <summary>
            Adds a ThreeIconSet rule 
            </summary>
            <param name="IconSet"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddFourIconSet(OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting4IconsSetType)">
            <summary>
            Adds a FourIconSet rule 
            </summary>
            <param name="IconSet"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddFiveIconSet(OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting5IconsSetType)">
            <summary>
            Adds a FiveIconSet rule 
            </summary>
            <param name="IconSet"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting.AddDatabar(System.Drawing.Color)">
            <summary>
            Adds a Databar rule 
            </summary>
            <param name="Color">The color of the databar</param>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingUniqueValues">
            <summary>
            ExcelConditionalFormattingUniqueValues
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingUniqueValues.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <param name="priority"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingUniqueValues.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingUniqueValues.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingYesterday">
            <summary>
            ExcelConditionalFormattingYesterday
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingYesterday.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingYesterday.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingYesterday.#ctor(OfficeOpenXml.ExcelAddress,System.Int32,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="priority"></param>
            <param name="address"></param>
            <param name="worksheet"></param>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation">
            <summary>
            Interface for data validation
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation.Address">
            <summary>
            Address of data validation
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation.ValidationType">
            <summary>
            Validation type
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation.ErrorStyle">
            <summary>
            Controls how Excel will handle invalid values.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation.AllowBlank">
            <summary>
            True if input message should be shown
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation.ShowInputMessage">
            <summary>
            True if input message should be shown
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation.ShowErrorMessage">
            <summary>
            True if error message should be shown.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation.ErrorTitle">
            <summary>
            Title of error message box (see property ShowErrorMessage)
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation.Error">
            <summary>
            Error message box text (see property ShowErrorMessage)
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation.PromptTitle">
            <summary>
            Title of info box if input message should be shown (see property ShowInputMessage)
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation.Prompt">
            <summary>
            Info message text (see property ShowErrorMessage)
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation.AllowsOperator">
            <summary>
            True if the current validation type allows operator.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation.Validate">
            <summary>
            Validates the state of the validation.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationAny">
            <summary>
            Data validation interface for Any value validation.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationCustom">
            <summary>
            Data validation interface for custom validation.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationDateTime">
            <summary>
            Validation interface for datetime validations
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationDecimal">
            <summary>
            Data validation interface for decimal values
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationTime">
            <summary>
            Data validation interface for time validation.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationWithFormula2`1">
            <summary>
            Interface for a data validation with two formulas
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationWithFormula2`1.Formula2">
            <summary>
            Formula 2
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationWithOperator">
            <summary>
            Represents a validation with an operator
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationWithOperator.Operator">
            <summary>
            Operator type
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.ExcelDataValidationAny">
            <summary>
            Any value validation.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationAny.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationAny.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationAny.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationAny.Validate">
            <summary>
            This method will validate the state of the validation
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.ExcelDataValidationCustom">
            <summary>
            Custom validation, i.e. a formula.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationCustom.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationCustom.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationCustom.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.ExcelDataValidationDateTime">
            <summary>
            Validation for <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationDateTime.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationDateTime.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationDateTime.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.ExcelDataValidationFactory">
            <summary>
            Factory class for ExcelDataValidation.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationFactory.Create(OfficeOpenXml.DataValidation.ExcelDataValidationType,OfficeOpenXml.ExcelWorksheet,System.String,System.Xml.XmlNode)">
            <summary>
            Creates an instance of <see cref="T:OfficeOpenXml.DataValidation.ExcelDataValidation"/> out of the given parameters.
            </summary>
            <param name="type"></param>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="itemElementNode"></param>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.ExcelDataValidationTime">
            <summary>
            Validation for times (<see cref="T:OfficeOpenXml.DataValidation.ExcelTime"/>).
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationTime.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationTime.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationTime.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager"></param>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.ExcelDataValidationWithFormula`1">
            <summary>
            A validation containing a formula
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationWithFormula`1.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationWithFormula`1.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet">Worksheet that owns the validation</param>
            <param name="itemElementNode">Xml top node (dataValidations)</param>
            <param name="validationType">Data validation type</param>
            <param name="address">address for data validation</param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationWithFormula`1.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet">Worksheet that owns the validation</param>
            <param name="itemElementNode">Xml top node (dataValidations)</param>
            <param name="validationType">Data validation type</param>
            <param name="address">address for data validation</param>
            <param name="namespaceManager">for test purposes</param>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelDataValidationWithFormula`1.Formula">
            <summary>
            Formula - Either a {T} value (except for custom validation) or a spreadsheet formula
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationWithFormula2`1.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationWithFormula2`1.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet">Worksheet that owns the validation</param>
            <param name="itemElementNode">Xml top node (dataValidations)</param>
            <param name="validationType">Data validation type</param>
            <param name="address">address for data validation</param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationWithFormula2`1.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet">Worksheet that owns the validation</param>
            <param name="itemElementNode">Xml top node (dataValidations)</param>
            <param name="validationType">Data validation type</param>
            <param name="address">address for data validation</param>
            <param name="namespaceManager">for test purposes</param>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelDataValidationWithFormula2`1.Formula2">
            <summary>
            Formula - Either a {T} value or a spreadsheet formula
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.ExcelTime">
            <summary>
            Represents a time between 00:00:00 and 23:59:59
            </summary>
        </member>
        <member name="F:OfficeOpenXml.DataValidation.ExcelTime.NumberOfDecimals">
            <summary>
            Max number of decimals when rounding.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelTime.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelTime.#ctor(System.Decimal)">
            <summary>
            Constructor
            </summary>
            <param name="value">An existing time for initialization</param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelTime.SetSecond(System.Int32)">
            <summary>
            If we are unlucky second might be rounded up to 60. This will have the minute to be raised and might affect the hour.
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelTime.Hour">
            <summary>
            Hour between 0 and 23
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelTime.Minute">
            <summary>
            Minute between 0 and 59
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelTime.Second">
            <summary>
            Second between 0 and 59
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelTime.ToExcelTime">
            <summary>
            Returns the excel decimal representation of a time.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelTime.ToExcelString">
            <summary>
            Returns the excel decimal representation of a time as a string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.Formulas.Contracts.IExcelDataValidationFormula">
            <summary>
            Interface for a data validation formula
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.Formulas.Contracts.IExcelDataValidationFormula.ExcelFormula">
            <summary>
            An excel formula
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.Formulas.Contracts.IExcelDataValidationFormulaDateTime">
            <summary>
            Validation formula interface for <see cref="T:System.DateTime"/>
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.Formulas.Contracts.IExcelDataValidationFormulaList">
            <summary>
            Interface for a data validation of list type
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.Formulas.Contracts.IExcelDataValidationFormulaList.Values">
            <summary>
            A list of value strings.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.Formulas.Contracts.IExcelDataValidationFormulaWithValue`1">
            <summary>
            Interface for a formula with a value
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.Formulas.Contracts.IExcelDataValidationFormulaWithValue`1.Value">
            <summary>
            The value.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.Formulas.Contracts.IExcelDataValidationFormulaDecimal">
            <summary>
            Interface for a data validation formula of <see cref="T:System.Single">float</see> value
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.Formulas.Contracts.IExcelDataValidationFormulaInt">
            <summary>
            Interface for a data validation formula of <see cref="T:System.Int32"/> value
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.Formulas.FormulaState">
            <summary>
            Enumeration representing the state of an <see cref="T:OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormulaValue`1"/>
            </summary>
        </member>
        <member name="F:OfficeOpenXml.DataValidation.Formulas.FormulaState.Value">
            <summary>
            Value is set
            </summary>
        </member>
        <member name="F:OfficeOpenXml.DataValidation.Formulas.FormulaState.Formula">
            <summary>
            Formula is set
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormula">
            <summary>
            Base class for a formula
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormula.#ctor(System.Xml.XmlNamespaceManager,System.Xml.XmlNode,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="namespaceManager">Namespacemanger of the worksheet</param>
            <param name="topNode">validation top node</param>
            <param name="formulaPath">xml path of the current formula</param>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormula.State">
            <summary>
            State of the validationformula, i.e. tells if value or formula is set
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormula.ExcelFormula">
            <summary>
            A formula which output must match the current validation type
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormula.GetXmlValue">
            <summary>
            This value will be stored in the xml. Can be overridden by subclasses
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormula.GetValueAsString">
            <summary>
            Returns the value as a string. Must be implemented by subclasses
            </summary>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormulaCustom">
            <summary>
            
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormulaValue`1">
            <summary>
            This class represents a validation formula. Its value can be specified as a value of the specified datatype or as a formula.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormulaValue`1.#ctor(System.Xml.XmlNamespaceManager,System.Xml.XmlNode,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="namespaceManager">Namespacemanger of the worksheet</param>
            <param name="topNode">validation top node</param>
            <param name="formulaPath">xml path of the current formula</param>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormulaValue`1.Value">
            <summary>
            Typed value
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormulaDecimal">
            <summary>
            
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.ExcelDataValidationOperator">
            <summary>
            Operator for comparison between Formula and Formula2 in a validation.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.ExcelDataValidationWarningStyle">
            <summary>
            warning style, controls how Excel will handle invalid changes.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.DataValidation.ExcelDataValidationWarningStyle.undefined">
            <summary>
            warning style will be excluded
            </summary>
        </member>
        <member name="F:OfficeOpenXml.DataValidation.ExcelDataValidationWarningStyle.stop">
            <summary>
            stop warning style, invalid changes will not be accepted
            </summary>
        </member>
        <member name="F:OfficeOpenXml.DataValidation.ExcelDataValidationWarningStyle.warning">
            <summary>
            warning will be presented when an attempt to an invalid change is done, but the change will be accepted.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.DataValidation.ExcelDataValidationWarningStyle.information">
            <summary>
            information warning style.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.ExcelDataValidationDecimal">
            <summary>
            Data validation for decimal values
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationDecimal.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationDecimal.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationDecimal.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager">For test purposes</param>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.ExcelDataValidationList">
            <summary>
            This class represents an List data validation.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationList.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationList.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationList.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager">Namespace manager, for test purposes</param>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.ExcelDataValidationInt">
            <summary>
            Data validation for integer values.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationInt.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationInt.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
            <param name="itemElementNode"></param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationInt.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
            <param name="address"></param>
            <param name="validationType"></param>
            <param name="itemElementNode"></param>
            <param name="namespaceManager">For test purposes</param>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.IRangeDataValidation">
            <summary>
            Provides functionality for adding datavalidation to a range (<see cref="T:OfficeOpenXml.ExcelRangeBase"/>). Each method will
            return a configurable validation.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.IRangeDataValidation.AddAnyDataValidation">
            <summary>
            Adds a <see cref="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationAny"/> to the range.
            </summary>
            <returns>A <see cref="T:OfficeOpenXml.DataValidation.ExcelDataValidationAny"/> that can be configured for any validation</returns>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.IRangeDataValidation.AddIntegerDataValidation">
            <summary>
            Adds a <see cref="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationInt"/> to the range
            </summary>
            <returns>A <see cref="T:OfficeOpenXml.DataValidation.ExcelDataValidationInt"/> that can be configured for integer data validation</returns>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.IRangeDataValidation.AddDecimalDataValidation">
            <summary>
            Adds a <see cref="T:OfficeOpenXml.DataValidation.ExcelDataValidationDecimal"/> to the range
            </summary>
            <returns>A <see cref="T:OfficeOpenXml.DataValidation.ExcelDataValidationDecimal"/> that can be configured for decimal data validation</returns>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.IRangeDataValidation.AddDateTimeDataValidation">
            <summary>
            Adds a <see cref="T:OfficeOpenXml.DataValidation.ExcelDataValidationDateTime"/> to the range
            </summary>
            <returns>A <see cref="T:OfficeOpenXml.DataValidation.ExcelDataValidationDecimal"/> that can be configured for datetime data validation</returns>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.IRangeDataValidation.AddListDataValidation">
            <summary>
            Adds a <see cref="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationList"/> to the range
            </summary>
            <returns>A <see cref="T:OfficeOpenXml.DataValidation.ExcelDataValidationList"/> that can be configured for datetime data validation</returns>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.IRangeDataValidation.AddTextLengthDataValidation">
            <summary>
            Adds a <see cref="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationInt"/> regarding text length validation to the range.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.IRangeDataValidation.AddTimeDataValidation">
            <summary>
            Adds a <see cref="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationTime"/> to the range.
            </summary>
            <returns>A <see cref="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationTime"/> that can be configured for time data validation</returns>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.IRangeDataValidation.AddCustomDataValidation">
            <summary>
            Adds a <see cref="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationCustom"/> to the range.
            </summary>
            <returns>A <see cref="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationCustom"/> that can be configured for custom validation</returns>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.ExcelDataValidation">
            <summary>
            Excel datavalidation
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidation.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet">worksheet that owns the validation</param>
            <param name="itemElementNode">Xml top node (dataValidations)</param>
            <param name="validationType">Data validation type</param>
            <param name="address">address for data validation</param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidation.#ctor(OfficeOpenXml.ExcelWorksheet,System.String,OfficeOpenXml.DataValidation.ExcelDataValidationType,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet">worksheet that owns the validation</param>
            <param name="itemElementNode">Xml top node (dataValidations) when importing xml</param>
            <param name="validationType">Data validation type</param>
            <param name="address">address for data validation</param>
            <param name="namespaceManager">Xml Namespace manager</param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidation.Validate">
            <summary>
            This method will validate the state of the validation
            </summary>
            <exception cref="T:System.InvalidOperationException">If the state breaks the rules of the validation</exception>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelDataValidation.AllowsOperator">
            <summary>
            True if the validation type allows operator to be set.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelDataValidation.Address">
            <summary>
            Address of data validation
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelDataValidation.ValidationType">
            <summary>
            Validation type
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelDataValidation.Operator">
            <summary>
            Operator for comparison between the entered value and Formula/Formulas.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelDataValidation.ErrorStyle">
            <summary>
            Warning style
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelDataValidation.AllowBlank">
            <summary>
            True if blanks should be allowed
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelDataValidation.ShowInputMessage">
            <summary>
            True if input message should be shown
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelDataValidation.ShowErrorMessage">
            <summary>
            True if error message should be shown
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelDataValidation.ErrorTitle">
            <summary>
            Title of error message box
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelDataValidation.Error">
            <summary>
            Error message box text
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelDataValidation.Formula1Internal">
            <summary>
            Formula 1
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelDataValidation.Formula2Internal">
            <summary>
            Formula 2
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.ExcelDataValidationCollection">
            <summary>
            <para>
            Collection of <see cref="T:OfficeOpenXml.DataValidation.ExcelDataValidation"/>. This class is providing the API for EPPlus data validation.
            </para>
            <para>
            The public methods of this class (Add[...]Validation) will create a datavalidation entry in the worksheet. When this
            validation has been created changes to the properties will affect the workbook immediately.
            </para>
            <para>
            Each type of validation has either a formula or a typed value/values, except for custom validation which has a formula only.
            </para>
            <code>
            // Add a date time validation
            var validation = worksheet.DataValidation.AddDateTimeValidation("A1");
            // set validation properties
            validation.ShowErrorMessage = true;
            validation.ErrorTitle = "An invalid date was entered";
            validation.Error = "The date must be between 2011-01-31 and 2011-12-31";
            validation.Prompt = "Enter date here";
            validation.Formula.Value = DateTime.Parse("2011-01-01");
            validation.Formula2.Value = DateTime.Parse("2011-12-31");
            validation.Operator = ExcelDataValidationOperator.between;
            </code>
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationCollection.#ctor(OfficeOpenXml.ExcelWorksheet)">
            <summary>
            Constructor
            </summary>
            <param name="worksheet"></param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationCollection.ValidateAddress(System.String,OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation)">
            <summary>
            Validates address - not empty, collisions
            </summary>
            <param name="address"></param>
            <param name="validatingValidation"></param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationCollection.ValidateAll">
            <summary>
            Validates all data validations.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationCollection.AddAnyValidation(System.String)">
            <summary>
            Adds a <see cref="T:OfficeOpenXml.DataValidation.ExcelDataValidationAny"/> to the worksheet.
            </summary>
            <param name="address">The range/address to validate</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationCollection.AddIntegerValidation(System.String)">
            <summary>
            Adds an <see cref="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationInt"/> to the worksheet. Whole means that the only accepted values
            are integer values.
            </summary>
            <param name="address">the range/address to validate</param>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationCollection.AddDecimalValidation(System.String)">
            <summary>
            Addes an <see cref="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationDecimal"/> to the worksheet. The only accepted values are
            decimal values.
            </summary>
            <param name="address">The range/address to validate</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationCollection.AddListValidation(System.String)">
            <summary>
            Adds an <see cref="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationList"/> to the worksheet. The accepted values are defined
            in a list.
            </summary>
            <param name="address">The range/address to validate</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationCollection.AddTextLengthValidation(System.String)">
            <summary>
            Adds an <see cref="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationInt"/> regarding text length to the worksheet.
            </summary>
            <param name="address">The range/address to validate</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationCollection.AddDateTimeValidation(System.String)">
            <summary>
            Adds an <see cref="T:OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationDateTime"/> to the worksheet.
            </summary>
            <param name="address">The range/address to validate</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationCollection.AddCustomValidation(System.String)">
            <summary>
            Adds a <see cref="T:OfficeOpenXml.DataValidation.ExcelDataValidationCustom"/> to the worksheet.
            </summary>
            <param name="address">The range/address to validate</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationCollection.Remove(OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation)">
            <summary>
            Removes an <see cref="T:OfficeOpenXml.DataValidation.ExcelDataValidation"/> from the collection.
            </summary>
            <param name="item">The item to remove</param>
            <returns>True if remove succeeds, otherwise false</returns>
            <exception cref="T:System.ArgumentNullException">if <paramref name="item"/> is null</exception>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelDataValidationCollection.Count">
            <summary>
            Number of validations
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelDataValidationCollection.Item(System.Int32)">
            <summary>
            Index operator, returns by 0-based index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelDataValidationCollection.Item(System.String)">
            <summary>
            Index operator, returns a data validation which address partly or exactly matches the searched address.
            </summary>
            <param name="address">A cell address or range</param>
            <returns>A <see cref="T:OfficeOpenXml.DataValidation.ExcelDataValidation"/> or null if no match</returns>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationCollection.FindAll(System.Predicate{OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation})">
            <summary>
            Returns all validations that matches the supplied predicate <paramref name="match"/>.
            </summary>
            <param name="match">predicate to filter out matching validations</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationCollection.Find(System.Predicate{OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation})">
            <summary>
            Returns the first matching validation.
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationCollection.Clear">
            <summary>
            Removes all validations from the collection.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationCollection.RemoveAll(System.Predicate{OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation})">
            <summary>
            Removes the validations that matches the predicate
            </summary>
            <param name="match"></param>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.eDataValidationType">
            <summary>
            Enum for available data validation types
            </summary>
        </member>
        <member name="F:OfficeOpenXml.DataValidation.eDataValidationType.Any">
            <summary>
            Any value
            </summary>
        </member>
        <member name="F:OfficeOpenXml.DataValidation.eDataValidationType.Whole">
            <summary>
            Integer value
            </summary>
        </member>
        <member name="F:OfficeOpenXml.DataValidation.eDataValidationType.Decimal">
            <summary>
            Decimal values
            </summary>
        </member>
        <member name="F:OfficeOpenXml.DataValidation.eDataValidationType.List">
            <summary>
            List of values
            </summary>
        </member>
        <member name="F:OfficeOpenXml.DataValidation.eDataValidationType.TextLength">
            <summary>
            Text length validation
            </summary>
        </member>
        <member name="F:OfficeOpenXml.DataValidation.eDataValidationType.DateTime">
            <summary>
            DateTime validation
            </summary>
        </member>
        <member name="F:OfficeOpenXml.DataValidation.eDataValidationType.Time">
            <summary>
            Time validation
            </summary>
        </member>
        <member name="F:OfficeOpenXml.DataValidation.eDataValidationType.Custom">
            <summary>
            Custom validation
            </summary>
        </member>
        <member name="T:OfficeOpenXml.DataValidation.ExcelDataValidationType">
            <summary>
            Types of datavalidation
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelDataValidationType.Type">
            <summary>
            Validation type
            </summary>
        </member>
        <member name="P:OfficeOpenXml.DataValidation.ExcelDataValidationType.AllowOperator">
            <summary>
            This type allows operator to be set
            </summary>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationType.GetByValidationType(OfficeOpenXml.DataValidation.eDataValidationType)">
            <summary>
            Returns a validation type by <see cref="T:OfficeOpenXml.DataValidation.eDataValidationType"/>
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationType.Equals(System.Object)">
            <summary>
            Overridden Equals, compares on internal validation type
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.DataValidation.ExcelDataValidationType.GetHashCode">
            <summary>
            Overrides GetHashCode()
            </summary>
            <returns></returns>
        </member>
        <member name="F:OfficeOpenXml.DataValidation.ExcelDataValidationType._any">
            <summary>
            Integer values
            </summary>
        </member>
        <member name="F:OfficeOpenXml.DataValidation.ExcelDataValidationType._whole">
            <summary>
            Integer values
            </summary>
        </member>
        <member name="F:OfficeOpenXml.DataValidation.ExcelDataValidationType._list">
            <summary>
            List of allowed values
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelBarChartSerie">
            <summary>
            A serie for a scatter chart
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelBarChartSerie.#ctor(OfficeOpenXml.Drawing.Chart.ExcelChartSeries,System.Xml.XmlNamespaceManager,System.Xml.XmlNode,System.Boolean)">
            <summary>
            Default constructor
            </summary>
            <param name="chartSeries">Parent collection</param>
            <param name="ns">Namespacemanager</param>
            <param name="node">Topnode</param>
            <param name="isPivot">Is pivotchart</param>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelBarChartSerie.DataLabel">
            <summary>
            Datalabel
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelSurfaceChartSerie">
            <summary>
            A serie for a surface chart
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelSurfaceChartSerie.#ctor(OfficeOpenXml.Drawing.Chart.ExcelChartSeries,System.Xml.XmlNamespaceManager,System.Xml.XmlNode,System.Boolean)">
            <summary>
            Default constructor
            </summary>
            <param name="chartSeries">Parent collection</param>
            <param name="ns">Namespacemanager</param>
            <param name="node">Topnode</param>
            <param name="isPivot">Is pivotchart</param>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelSurfaceChart">
            <summary>
            A Surface chart
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelRadarChart">
            <summary>
            Provides access to line chart specific properties
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelRadarChart.RadarStyle">
            <summary>
            The type of radarchart
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelRadarChart.DataLabel">
            <summary>
            Access to datalabel properties
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelBubbleChartSerie">
            <summary>
            A serie for a scatter chart
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelBubbleChartSerie.#ctor(OfficeOpenXml.Drawing.Chart.ExcelChartSeries,System.Xml.XmlNamespaceManager,System.Xml.XmlNode,System.Boolean)">
            <summary>
            Default constructor
            </summary>
            <param name="chartSeries">Parent collection</param>
            <param name="ns">Namespacemanager</param>
            <param name="node">Topnode</param>
            <param name="isPivot">Is pivotchart</param>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelBubbleChartSerie.DataLabel">
            <summary>
            Datalabel
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelLineChartSerie">
            <summary>
            A serie for a line chart
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelLineChartSerie.#ctor(OfficeOpenXml.Drawing.Chart.ExcelChartSeries,System.Xml.XmlNamespaceManager,System.Xml.XmlNode,System.Boolean)">
            <summary>
            Default constructor
            </summary>
            <param name="chartSeries">Parent collection</param>
            <param name="ns">Namespacemanager</param>
            <param name="node">Topnode</param>
            <param name="isPivot">Is pivotchart</param>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelLineChartSerie.DataLabel">
            <summary>
            Datalabels
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelLineChartSerie.Marker">
            <summary>
            Marker symbol 
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelLineChartSerie.Smooth">
            <summary>
            Smoth lines
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelLineChartSerie.LineColor">
             <summary>
             Line color.
             </summary>
            
             <value>
             The color of the line.
             </value>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelLineChartSerie.MarkerSize">
             <summary>
             Gets or sets the size of the marker.
             </summary>
            
             <remarks>
             value between 2 and 72.
             </remarks>
            
             <value>
             The size of the marker.
             </value>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelLineChartSerie.LineWidth">
             <summary>
             Gets or sets the width of the line in pt.
             </summary>
            
             <value>
             The width of the line.
             </value>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelLineChartSerie.MarkerLineColor">
             <summary>
             Marker Line color. 
             (not to be confused with LineColor)
             </summary>
            
             <value>
             The color of the Marker line.
             </value>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.eChartType">
            <summary>
            Chart type
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.eDirection">
            <summary>
            Bar or column
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.eGrouping">
            <summary>
            How the series are grouped
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.eShape">
            <summary>
            Shape for bar charts
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.eScatterStyle">
            <summary>
            Smooth or lines markers
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eRadarStyle.Filled">
            <summary>
            Specifies that the radar chart shall be filled and have lines but no markers.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eRadarStyle.Marker">
            <summary>
            Specifies that the radar chart shall have lines and markers but no fill.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eRadarStyle.Standard">
            <summary>
            Specifies that the radar chart shall have lines but no markers and no fill.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ePieType">
            <summary>
            Bar or pie
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.eLabelPosition">
            <summary>
            Position of the labels
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.eTickLabelPosition">
            <summary>
            Axis label position
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.eMarkerStyle">
            <summary>
            Markerstyle
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.eChartStyle">
            <summary>
            The build in style of the chart.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.eTrendLine">
            <summary>
            Type of Trendline for a chart
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eTrendLine.Exponential">
            <summary>
            Specifies the trendline shall be an exponential curve in the form
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eTrendLine.Linear">
            <summary>
            Specifies the trendline shall be a logarithmic curve in the form , where log is the natural
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eTrendLine.Logarithmic">
            <summary>
            Specifies the trendline shall be a logarithmic curve in the form , where log is the natural
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eTrendLine.MovingAvgerage">
            <summary>
            Specifies the trendline shall be a moving average of period Period
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eTrendLine.Polynomial">
            <summary>
            Specifies the trendline shall be a polynomial curve of order Order in the form 
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eTrendLine.Power">
            <summary>
            Specifies the trendline shall be a power curve in the form
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.eDisplayBlanksAs">
            <summary>
            Specifies the possible ways to display blanks
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eDisplayBlanksAs.Gap">
            <summary>
            Blank values shall be left as a gap
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eDisplayBlanksAs.Span">
            <summary>
            Blank values shall be spanned with a line (Line charts)
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eDisplayBlanksAs.Zero">
            <summary>
            Blank values shall be treated as zero
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eSizeRepresents.Area">
            <summary>
            Specifies the area of the bubbles shall be proportional to the bubble size value.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eSizeRepresents.Width">
            <summary>
            Specifies the radius of the bubbles shall be proportional to the bubble size value.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelChart">
            <summary>
            Base class for Chart object.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelChart.GetChartNodeText">
            <summary>
            Get the name of the chart node
            </summary>
            <returns>The name</returns>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelChart.AddAxis">
            <summary>
            Add a secondary axis
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.WorkSheet">
            <summary>
            Reference to the worksheet
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.ChartXml">
            <summary>
            The chart xml document
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.ChartType">
            <summary>
            Type of chart
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.Title">
            <summary>
            Titel of the chart
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.Series">
            <summary>
            Chart series
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.Axis">
            <summary>
            An array containg all axis of all Charttypes
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.XAxis">
            <summary>
            The XAxis
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.YAxis">
            <summary>
            The YAxis
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.UseSecondaryAxis">
            <summary>
            If true the charttype will use the secondary axis.
            The chart must contain a least one other charttype that uses the primary axis.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.Style">
            <summary>
            The build-in chart styles. 
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.ShowHiddenData">
            <summary>
            Show data in hidden rows and columns
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.DisplayBlanksAs">
            <summary>
            Specifies the possible ways to display blanks
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.ShowDataLabelsOverMaximum">
            <summary>
            Specifies data labels over the maximum of the chart shall be shown
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelChart.CheckRemoveAxis(OfficeOpenXml.Drawing.Chart.ExcelChartAxis)">
            <summary>
            Remove all axis that are not used any more
            </summary>
            <param name="excelChartAxis"></param>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.PlotArea">
            <summary>
            Plotarea
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.Legend">
            <summary>
            Legend
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.Border">
            <summary>
            Border
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.Fill">
            <summary>
            Fill
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.View3D">
            <summary>
            3D-settings
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.VaryColors">
            <summary>
            If the chart has only one serie this varies the colors for each point.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChart.UriChart">
            <summary>
            Package internal URI
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelChartCollection">
            <summary>
            Enumerates charttypes 
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelChartCollection.Add(OfficeOpenXml.Drawing.Chart.eChartType)">
            <summary>
            Add a new charttype to the chart
            </summary>
            <param name="chartType">The type of the new chart</param>
            <returns></returns>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartCollection.Item(System.Int32)">
            <summary>
            Returns a chart at the specific position.  
            </summary>
            <param name="PositionID">The position of the chart. 0-base</param>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelChartTrendlineCollection">
            <summary>
            A collection of trendlines.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelChartTrendlineCollection.Add(OfficeOpenXml.Drawing.Chart.eTrendLine)">
            <summary>
            Add a new trendline
            </summary>
            <param name="Type"></param>
            <returns>The trendline</returns>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelChartTrendline">
            <summary>
            A trendline object
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartTrendline.Type">
            <summary>
            Type of Trendline
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartTrendline.Name">
            <summary>
            Name in the legend
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartTrendline.Order">
            <summary>
            Order for polynominal trendlines
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartTrendline.Period">
            <summary>
            Period for monthly average trendlines
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartTrendline.Forward">
            <summary>
            Forcast forward periods
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartTrendline.Backward">
            <summary>
            Forcast backwards periods
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartTrendline.Intercept">
            <summary>
            Specify the point where the trendline crosses the vertical axis
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartTrendline.DisplayRSquaredValue">
            <summary>
            Display the R-squared value for a trendline
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartTrendline.DisplayEquation">
            <summary>
            Display the trendline equation on the chart
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelBubbleChart">
            <summary>
            Provides access to bubble chart specific properties
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelBubbleChart.BubbleScale">
            <summary>
            Specifies the scale factor for the bubble chart. Can range from 0 to 300, corresponding to a percentage of the default size,
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelBubbleChart.ShowNegativeBubbles">
            <summary>
            Specifies the scale factor for the bubble chart. Can range from 0 to 300, corresponding to a percentage of the default size,
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelBubbleChart.Bubble3D">
            <summary>
            Specifies if the bubblechart is three dimensional
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelBubbleChart.SizeRepresents">
            <summary>
            Specifies the scale factor for the bubble chart. Can range from 0 to 300, corresponding to a percentage of the default size,
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelChartSurface">
            <summary>
            Chart surface settings
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartSurface.Thickness">
            <summary>
            Show the values 
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartSurface.Fill">
            <summary>
            Access fill properties
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartSurface.Border">
            <summary>
            Access border properties
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelRadarChartSerie">
            <summary>
            A serie for a scatter chart
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelRadarChartSerie.#ctor(OfficeOpenXml.Drawing.Chart.ExcelChartSeries,System.Xml.XmlNamespaceManager,System.Xml.XmlNode,System.Boolean)">
            <summary>
            Default constructor
            </summary>
            <param name="chartSeries">Parent collection</param>
            <param name="ns">Namespacemanager</param>
            <param name="node">Topnode</param>
            <param name="isPivot">Is pivotchart</param>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelRadarChartSerie.DataLabel">
            <summary>
            Datalabel
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelRadarChartSerie.Marker">
            <summary>
            Marker symbol 
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelLineChart">
            <summary>
            Provides access to line chart specific properties
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelLineChart.Marker">
            <summary>
            If the series has markers
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelLineChart.Smooth">
            <summary>
            If the series has smooth lines
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelLineChart.DataLabel">
            <summary>
            Access to datalabel properties
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.eLegendPosition">
            <summary>
            Position of the legend
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelChartLegend">
            <summary>
            Chart ledger
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartLegend.Position">
            <summary>
            Position of the Legend
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartLegend.Overlay">
            <summary>
            If the legend overlays other objects
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartLegend.Fill">
            <summary>
            Fill style
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartLegend.Border">
            <summary>
            Border style
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartLegend.Font">
            <summary>
            Font properties
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelChartLegend.Remove">
            <summary>
            Remove the legend
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelChartLegend.Add">
            <summary>
            Add a legend to the chart
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelChartPlotArea">
            <summary>
            A charts plot area
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelChartSerieDataLabel">
            <summary>
            Datalabel properties
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartSerieDataLabel.Position">
            <summary>
            Position of the labels
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartSerieDataLabel.Fill">
            <summary>
            Access fill properties
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartSerieDataLabel.Border">
            <summary>
            Access border properties
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartSerieDataLabel.Font">
            <summary>
            Access font properties
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelScatterChartSerie">
            <summary>
            A serie for a scatter chart
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelScatterChartSerie.#ctor(OfficeOpenXml.Drawing.Chart.ExcelChartSeries,System.Xml.XmlNamespaceManager,System.Xml.XmlNode,System.Boolean)">
            <summary>
            Default constructor
            </summary>
            <param name="chartSeries">Parent collection</param>
            <param name="ns">Namespacemanager</param>
            <param name="node">Topnode</param>
            <param name="isPivot">Is pivotchart</param>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelScatterChartSerie.DataLabel">
            <summary>
            Datalabel
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelScatterChartSerie.Smooth">
            <summary>
            Smooth for scattercharts
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelScatterChartSerie.Marker">
            <summary>
            Marker symbol 
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelScatterChartSerie.LineColor">
             <summary>
             Line color.
             </summary>
            
             <value>
             The color of the line.
             </value>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelScatterChartSerie.MarkerSize">
             <summary>
             Gets or sets the size of the marker.
             </summary>
            
             <remarks>
             value between 2 and 72.
             </remarks>
            
             <value>
             The size of the marker.
             </value>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelScatterChartSerie.MarkerColor">
             <summary>
             Marker color.
             </summary>
            
             <value>
             The color of the Marker.
             </value>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelScatterChartSerie.LineWidth">
             <summary>
             Gets or sets the width of the line in pt.
             </summary>
            
             <value>
             The width of the line.
             </value>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelScatterChartSerie.MarkerLineColor">
             <summary>
             Marker Line color.
             (not to be confused with LineColor)
             </summary>
            
             <value>
             The color of the Marker line.
             </value>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelScatterChartSerie.setAlphaChannel(System.Drawing.Color,System.String)">
            <summary>
            write alpha value (if Color.A != 255)
            </summary>
            <param name="c">Color</param>
            <param name="xPath">where to write</param>
            <remarks>
            alpha-values may only written to color-nodes
            eg: a:prstClr (preset), a:hslClr (hsl), a:schemeClr (schema), a:sysClr (system), a:scrgbClr (rgb percent) or a:srgbClr (rgb hex)
                .../a:prstClr/a:alpha/@val
            </remarks>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelScatterChartSerie.getAlphaChannel(System.String)">
            <summary>
            read AlphaChannel from a:solidFill
            </summary>
            <param name="xPath"></param>
            <returns>alpha or 255 if their is no such node</returns>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelScatterChartSerie.xPath4Alpha(System.String)">
            <summary>
            creates xPath to alpha attribute for a color 
            eg: a:prstClr/a:alpha/@val
            </summary>
            <param name="xPath">xPath to color node</param>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelChartTitle">
            <summary>
            The title of a chart
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartTitle.Text">
            <summary>
            The text
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartTitle.Border">
            <summary>
            A reference to the border properties
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartTitle.Fill">
            <summary>
            A reference to the fill properties
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartTitle.Font">
            <summary>
            A reference to the font properties
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartTitle.RichText">
            <summary>
            Richtext
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartTitle.Overlay">
            <summary>
            Show without overlaping the chart.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartTitle.AnchorCtr">
            <summary>
            Specifies the centering of the text box. 
            The way it works fundamentally is to determine the smallest possible "bounds box" for the text and then to center that "bounds box" accordingly. 
            This is different than paragraph alignment, which aligns the text within the "bounds box" for the text. 
            This flag is compatible with all of the different kinds of anchoring. 
            If this attribute is omitted, then a value of 0 or false is implied.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartTitle.TextVertical">
            <summary>
            Vertical text
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartTitle.Rotation">
            <summary>
            Rotation in degrees (0-360)
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelOfPieChart">
            <summary>
            Provides access to ofpie-chart specific properties
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelOfPieChart.OfPieType">
            <summary>
            Type, pie or bar
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelPieChartSerie">
            <summary>
            A serie for a pie chart
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelPieChartSerie.#ctor(OfficeOpenXml.Drawing.Chart.ExcelChartSeries,System.Xml.XmlNamespaceManager,System.Xml.XmlNode,System.Boolean)">
            <summary>
            Default constructor
            </summary>
            <param name="chartSeries">Parent collection</param>
            <param name="ns">Namespacemanager</param>
            <param name="node">Topnode</param>
            <param name="isPivot">Is pivotchart</param>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelPieChartSerie.Explosion">
            <summary>
            Explosion for Piecharts
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelPieChartSerie.DataLabel">
            <summary>
            DataLabels
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelBarChart">
            <summary>
            Bar chart
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelBarChart.Direction">
            <summary>
            Direction, Bar or columns
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelBarChart.Shape">
            <summary>
            The shape of the bar/columns
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelBarChart.DataLabel">
            <summary>
            Access to datalabel properties
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.eAxisPosition">
            <summary>
            Position of the axis.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.eYAxisPosition">
            <summary>
            Position of the Y-Axis
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.eXAxisPosition">
            <summary>
            Position of the X-Axis
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.eAxisOrientation">
            <summary>
            Axis orientaion
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.eCrossBetween">
            <summary>
            How the axis are crossed
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eCrossBetween.Between">
            <summary>
            Specifies the value axis shall cross the category axis between data markers
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eCrossBetween.MidCat">
            <summary>
            Specifies the value axis shall cross the category axis at the midpoint of a category.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.eCrosses">
            <summary>
            Where the axis cross. 
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eCrosses.AutoZero">
            <summary>
            (Axis Crosses at Zero) The category axis crosses at the zero point of the valueaxis (if possible), or the minimum value (if theminimum is greater than zero) or the maximum (if the maximum is less than zero).
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eCrosses.Max">
            <summary>
            The axis crosses at the maximum value
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eCrosses.Min">
            <summary>
            (Axis crosses at the minimum value of the chart.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.eAxisTickMark">
            <summary>
            Tickmarks
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eAxisTickMark.Cross">
            <summary>
            Specifies the tick marks shall cross the axis. 
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eAxisTickMark.In">
            <summary>
            Specifies the tick marks shall be inside the plot area. 
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eAxisTickMark.None">
            <summary>
            Specifies there shall be no tick marks.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.eAxisTickMark.Out">
            <summary>
            Specifies the tick marks shall be outside the plot area.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelChartAxis">
            <summary>
            An axis for a chart
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.eAxisType">
            <summary>
            Type of axis
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.eAxisType.Val">
            <summary>
            Value axis
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.eAxisType.Cat">
            <summary>
            Category axis
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.eAxisType.Date">
            <summary>
            Date axis
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.eAxisType.Serie">
            <summary>
            Series axis
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.MajorTickMark">
            <summary>
            majorTickMark 
            This element specifies the major tick marks for the axis. 
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.MinorTickMark">
            <summary>
            minorTickMark 
            This element specifies the minor tick marks for the axis. 
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.AxisType">
            <summary>
            Type of axis
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.AxisPosition">
            <summary>
            Where the axis is located
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.Crosses">
            <summary>
            Where the axis cross
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.CrossBetween">
            <summary>
            How the axis are crossed
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.CrossesAt">
            <summary>
            The value where the axis cross. 
            Null is automatic
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.Format">
            <summary>
            Numberformat
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.LabelPosition">
            <summary>
            Position of the labels
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.Fill">
            <summary>
            Access to fill properties
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.Border">
            <summary>
            Access to border properties
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.Font">
            <summary>
            Access to font properties
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.Deleted">
            <summary>
            If the axis is deleted
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.TickLabelPosition">
            <summary>
            Position of the Lables
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.Title">
            <summary>
            Chart axis title
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.MinValue">
            <summary>
            Minimum value for the axis.
            Null is automatic
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.MaxValue">
            <summary>
            Max value for the axis.
            Null is automatic
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.MajorUnit">
            <summary>
            Major unit for the axis.
            Null is automatic
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.MinorUnit">
            <summary>
            Minor unit for the axis.
            Null is automatic
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.LogBase">
            <summary>
            The base for a logaritmic scale
            Null for a normal scale
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartAxis.Orientation">
            <summary>
            
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelChartDataLabel">
            <summary>
            Datalabel on chart level. 
            This class is inherited by ExcelChartSerieDataLabel
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartDataLabel.ShowValue">
            <summary>
            Show the values 
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartDataLabel.ShowCategory">
            <summary>
            Show category names
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartDataLabel.ShowSeriesName">
            <summary>
            Show series names
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartDataLabel.ShowPercent">
            <summary>
            Show percent values
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartDataLabel.ShowLeaderLines">
            <summary>
            Show the leader lines
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartDataLabel.ShowBubbleSize">
            <summary>
            Bubble Size.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartDataLabel.Separator">
            <summary>
            Separator string 
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartDataLabel.Fill">
            <summary>
            Access fill properties
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartDataLabel.Border">
            <summary>
            Access border properties
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartDataLabel.Font">
            <summary>
            Access font properties
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelChartSerie">
            <summary>
            A chart serie
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelChartSerie.#ctor(OfficeOpenXml.Drawing.Chart.ExcelChartSeries,System.Xml.XmlNamespaceManager,System.Xml.XmlNode,System.Boolean)">
            <summary>
            Default constructor
            </summary>
            <param name="chartSeries">Parent collection</param>
            <param name="ns">Namespacemanager</param>
            <param name="node">Topnode</param>
            <param name="isPivot">Is pivotchart</param>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartSerie.Header">
            <summary>
            Header for the serie.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartSerie.HeaderAddress">
            <summary>
            Header address for the serie.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartSerie.Series">
            <summary>
            Set this to a valid address or the drawing will be invalid.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartSerie.XSeries">
            <summary>
            Set an address for the horisontal labels
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartSerie.TrendLines">
            <summary>
            Access to the trendline collection
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelChartSeries">
            <summary>
            Collection class for chart series
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartSeries.Item(System.Int32)">
            <summary>
            Returns the serie at the specified position.  
            </summary>
            <param name="PositionID">The position of the series.</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelChartSeries.Delete(System.Int32)">
            <summary>
            Delete the chart at the specific position
            </summary>
            <param name="PositionID">Zero based</param>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelChartSeries.Chart">
            <summary>
            A reference to the chart object
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelChartSeries.Add(OfficeOpenXml.ExcelRangeBase,OfficeOpenXml.ExcelRangeBase)">
            <summary>
            Add a new serie to the chart. Do not apply to pivotcharts.
            </summary>
            <param name="Serie">The Y-Axis range</param>
            <param name="XSerie">The X-Axis range</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Chart.ExcelChartSeries.Add(System.String,System.String)">
            <summary>
            Add a new serie to the chart.Do not apply to pivotcharts.
            </summary>
            <param name="SerieAddress">The Y-Axis range</param>
            <param name="XSerieAddress">The X-Axis range</param>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelDoughnutChart">
            <summary>
            Provides access to doughnut chart specific properties
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelDoughnutChart.FirstSliceAngle">
            <summary>
            Angle of the first slize
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelDoughnutChart.HoleSize">
            <summary>
            Size of the doubnut hole
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelPieChart">
            <summary>
            Provides access to pie chart specific properties
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelPieChart.DataLabel">
            <summary>
            Access to datalabel properties
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Chart.ExcelScatterChart">
            <summary>
            Provides access to scatter chart specific properties
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelScatterChart.ScatterStyle">
            <summary>
            If the scatter has LineMarkers or SmoothMarkers
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Chart.ExcelScatterChart.Marker">
            <summary>
            If the series has markers
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.eTextAnchoringType">
            <summary>
            Text anchoring
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.eTextVerticalType">
            <summary>
            Vertical text type
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.eEditAs">
            <summary>
            How the drawing will be resized.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.eEditAs.Absolute">
            <summary>
            Specifies that the current start and end positions shall
            be maintained with respect to the distances from the
            absolute start point of the worksheet.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.eEditAs.OneCell">
             <summary>
             Specifies that the current drawing shall move with its
            row and column (i.e. the object is anchored to the
             actual from row and column), but that the size shall
            remain absolute.
             </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.eEditAs.TwoCell">
            <summary>
            Specifies that the current drawing shall move and
            resize to maintain its row and column anchors (i.e. the
            object is anchored to the actual from and to row and column).
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.ExcelDrawing">
            <summary>
            Base class for twoanchored drawings. 
            Drawings are Charts, shapes and Pictures.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.ExcelDrawing.ExcelPosition">
            <summary>
            Position of the a drawing.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawing.ExcelPosition.ColumnOff">
            <summary>
            Column Offset
            
            EMU units   1cm         =   1/360000 
                        1US inch    =   1/914400
                        1pixel      =   1/9525
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawing.ExcelPosition.RowOff">
            <summary>
            Row Offset
            
            EMU units   1cm         =   1/360000 
                        1US inch    =   1/914400
                        1pixel      =   1/9525
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawing.Name">
            <summary>
            The name of the drawing object
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawing.EditAs">
            <summary>
            How Excel resize drawings when the column width is changed within Excel.
            The width of drawings are currently NOT resized in EPPLus when the column width changes
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawing.Locked">
            <summary>
            Lock drawing
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawing.Print">
            <summary>
            Print drawing with sheet
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawing.From">
            <summary>
            Top Left position
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawing.To">
            <summary>
            Bottom right position
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Drawing.ExcelDrawing.GetDrawing(OfficeOpenXml.Drawing.ExcelDrawings,System.Xml.XmlNode)">
            <summary>
            Add new Drawing types here
            </summary>
            <param name="drawings">The drawing collection</param>
            <param name="node">Xml top node</param>
            <returns>The Drawing object</returns>
        </member>
        <member name="M:OfficeOpenXml.Drawing.ExcelDrawing.SetPosition(System.Int32,System.Int32)">
            <summary>
            Set the top left corner of a drawing. 
            Note that resizing columns / rows after using this function will effect the position of the drawing
            </summary>
            <param name="PixelTop">Top pixel</param>
            <param name="PixelLeft">Left pixel</param>
        </member>
        <member name="M:OfficeOpenXml.Drawing.ExcelDrawing.SetPosition(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Set the top left corner of a drawing. 
            Note that resizing columns / rows after using this function will effect the position of the drawing
            </summary>
            <param name="Row">Start row - 0-based index.</param>
            <param name="RowOffsetPixels">Offset in pixels</param>
            <param name="Column">Start Column - 0-based index.</param>
            <param name="ColumnOffsetPixels">Offset in pixels</param>
        </member>
        <member name="M:OfficeOpenXml.Drawing.ExcelDrawing.SetSize(System.Int32)">
            <summary>
            Set size in Percent
            Note that resizing columns / rows after using this function will effect the size of the drawing
            </summary>
            <param name="Percent"></param>
        </member>
        <member name="M:OfficeOpenXml.Drawing.ExcelDrawing.SetSize(System.Int32,System.Int32)">
            <summary>
            Set size in pixels
            Note that resizing columns / rows after using this function will effect the size of the drawing
            </summary>
            <param name="PixelWidth">Width in pixels</param>
            <param name="PixelHeight">Height in pixels</param>
        </member>
        <member name="T:OfficeOpenXml.Drawing.ExcelDrawingLineEnd">
            <summary>
            Properties for drawing line ends
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawingLineEnd.HeadEnd">
            <summary>
            HeaderEnd
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawingLineEnd.TailEnd">
            <summary>
            HeaderEnd
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawingLineEnd.TailEndSizeWidth">
            <summary>
            TailEndSizeWidth
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawingLineEnd.TailEndSizeHeight">
            <summary>
            TailEndSizeHeight
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawingLineEnd.HeadEndSizeWidth">
            <summary>
            TailEndSizeWidth
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawingLineEnd.HeadEndSizeHeight">
            <summary>
            TailEndSizeHeight
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.ExcelPicture">
            <summary>
            An image object
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelPicture.Image">
            <summary>
            The Image
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelPicture.ImageFormat">
            <summary>
            Image format
            If the picture is created from an Image this type is always Jpeg
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Drawing.ExcelPicture.SetSize(System.Int32)">
            <summary>
            Set the size of the image in percent from the orginal size
            Note that resizing columns / rows after using this function will effect the size of the picture
            </summary>
            <param name="Percent">Percent</param>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelPicture.Fill">
            <summary>
            Fill
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelPicture.Border">
            <summary>
            Border
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelPicture.Hyperlink">
            <summary>
            Hyperlink
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPictureCollection.Item(System.Int32)">
            <summary>
            Indexer
            </summary>
            <param name="Index">Index</param>
            <returns>The VML Drawing Picture object</returns>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPictureCollection.GetNewId">
            <summary>
            returns the next drawing id.
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingCommentCollection.GetNewId">
            <summary>
            returns the next drawing id.
            </summary>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPicture">
            <summary>
            Drawing object used for header and footer pictures
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPicture.Position">
            <summary>
            Position ID
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPicture.Width">
            <summary>
            The width in points
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPicture.Height">
            <summary>
            The height in points
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPicture.Left">
            <summary>
            Margin Left in points
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPicture.Top">
            <summary>
            Margin top in points
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPicture.Title">
            <summary>
            The Title of the image
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPicture.Image">
            <summary>
            The image
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPicture.BiLevel">
            <summary>
            Determines whether an image will be displayed in black and white
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPicture.GrayScale">
            <summary>
            Determines whether a picture will be displayed in grayscale mode
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPicture.Gain">
            <summary>
            Defines the intensity of all colors in an image
            Default value is 1
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPicture.Gamma">
            <summary>
            Defines the amount of contrast for an image
            Default value is 0;
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPicture.BlackLevel">
            <summary>
            Defines the intensity of black in an image
            Default value is 0
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Vml.eTextAlignHorizontalVml">
            <summary>
            Horizontal Alingment
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Vml.eTextAlignVerticalVml">
            <summary>
            Vertical Alingment
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Vml.eLineStyleVml">
            <summary>
            Linestyle
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingBase">
            <summary>
            Drawing object used for comments
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingBase.AlternativeText">
            <summary>
            Alternative text to be displayed instead of a graphic.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingComment">
            <summary>
            Drawing object used for comments
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingComment.Address">
            <summary>
            Address in the worksheet
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingComment.VerticalAlignment">
            <summary>
            Vertical alignment for text
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingComment.HorizontalAlignment">
            <summary>
            Horizontal alignment for text
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingComment.Visible">
            <summary>
            If the drawing object is visible.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingComment.BackgroundColor">
            <summary>
            Background color
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingComment.LineStyle">
            <summary>
            Linestyle for border
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingComment.LineColor">
            <summary>
            Line color 
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingComment.LineWidth">
            <summary>
            Width of the border
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingComment.AutoFit">
            <summary>
            Autofits the drawingobject 
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingComment.Locked">
            <summary>
            If the object is locked when the sheet is protected
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingComment.LockText">
            <summary>
            Specifies that the object's text is locked
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingComment.From">
            <summary>
            From position. For comments only when Visible=true.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingComment.To">
            <summary>
            To position. For comments only when Visible=true.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPosition">
            <summary>
            The position of a VML drawing. Used for comments
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPosition.Row">
            <summary>
            Row. Zero based
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPosition.RowOffset">
            <summary>
            Row offset in pixels. Zero based
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPosition.Column">
            <summary>
            Column. Zero based
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPosition.ColumnOffset">
            <summary>
            Column offset. Zero based
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.ExcelDrawings">
            <summary>
            Collection for Drawing objects.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawings.DrawingXml">
            <summary>
            A reference to the drawing xml document
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Drawing.ExcelDrawings.CreateNSM">
            <summary>
            Creates the NamespaceManager. 
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Drawing.ExcelDrawings._nsManager">
            <summary>
            Provides access to a namespace manager instance to allow XPath searching
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawings.Item(System.Int32)">
            <summary>
            Returns the drawing at the specified position.  
            </summary>
            <param name="PositionID">The position of the drawing. 0-base</param>
            <returns></returns>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawings.Item(System.String)">
            <summary>
            Returns the drawing matching the specified name
            </summary>
            <param name="Name">The name of the worksheet</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.Drawing.ExcelDrawings.AddChart(System.String,OfficeOpenXml.Drawing.Chart.eChartType,OfficeOpenXml.Table.PivotTable.ExcelPivotTable)">
            <summary>
            Add a new chart to the worksheet.
            Do not support Bubble-, Radar-, Stock- or Surface charts. 
            </summary>
            <param name="Name"></param>
            <param name="ChartType">Type of chart</param>
            <param name="PivotTableSource">The pivottable source for a pivotchart</param>    
            <returns>The chart</returns>
        </member>
        <member name="M:OfficeOpenXml.Drawing.ExcelDrawings.AddChart(System.String,OfficeOpenXml.Drawing.Chart.eChartType)">
            <summary>
            Add a new chart to the worksheet.
            Do not support Bubble-, Radar-, Stock- or Surface charts. 
            </summary>
            <param name="Name"></param>
            <param name="ChartType">Type of chart</param>
            <returns>The chart</returns>
        </member>
        <member name="M:OfficeOpenXml.Drawing.ExcelDrawings.AddPicture(System.String,System.Drawing.Image)">
            <summary>
            Add a picure to the worksheet
            </summary>
            <param name="Name"></param>
            <param name="image">An image. Allways saved in then JPeg format</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.Drawing.ExcelDrawings.AddPicture(System.String,System.Drawing.Image,System.Uri)">
            <summary>
            Add a picure to the worksheet
            </summary>
            <param name="Name"></param>
            <param name="image">An image. Allways saved in then JPeg format</param>
            <param name="Hyperlink">Picture Hyperlink</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.Drawing.ExcelDrawings.AddPicture(System.String,System.IO.FileInfo)">
            <summary>
            Add a picure to the worksheet
            </summary>
            <param name="Name"></param>
            <param name="ImageFile">The image file</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.Drawing.ExcelDrawings.AddPicture(System.String,System.IO.FileInfo,System.Uri)">
            <summary>
            Add a picure to the worksheet
            </summary>
            <param name="Name"></param>
            <param name="ImageFile">The image file</param>
            <param name="Hyperlink">Picture Hyperlink</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.Drawing.ExcelDrawings.AddShape(System.String,eShapeStyle)">
            <summary>
            Add a new shape to the worksheet
            </summary>
            <param name="Name">Name</param>
            <param name="Style">Shape style</param>
            <returns>The shape object</returns>
        </member>
        <member name="M:OfficeOpenXml.Drawing.ExcelDrawings.AddShape(System.String,OfficeOpenXml.Drawing.ExcelShape)">
            <summary>
            Add a new shape to the worksheet
            </summary>
            <param name="Name">Name</param>
            <param name="Source">Source shape</param>
            <returns>The shape object</returns>
        </member>
        <member name="M:OfficeOpenXml.Drawing.ExcelDrawings.Remove(System.Int32)">
            <summary>
            Removes a drawing.
            </summary>
            <param name="Index">The index of the drawing</param>
        </member>
        <member name="M:OfficeOpenXml.Drawing.ExcelDrawings.Remove(OfficeOpenXml.Drawing.ExcelDrawing)">
            <summary>
            Removes a drawing.
            </summary>
            <param name="Drawing">The drawing</param>
        </member>
        <member name="M:OfficeOpenXml.Drawing.ExcelDrawings.Remove(System.String)">
            <summary>
            Removes a drawing.
            </summary>
            <param name="Name">The name of the drawing</param>
        </member>
        <member name="M:OfficeOpenXml.Drawing.ExcelDrawings.Clear">
            <summary>
            Removes all drawings from the collection
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.ExcelShape">
            <summary>
            An Excel shape.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelShape.Style">
            <summary>
            Shape style
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelShape.Fill">
            <summary>
            Fill
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelShape.Border">
            <summary>
            Border
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelShape.LineEnds">
            <summary>
            Line Ends
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelShape.Text">
            <summary>
            Text inside the shape
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelShape.LockText">
            <summary>
            Lock drawing
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelShape.RichText">
            <summary>
            Richtext collection. Used to format specific parts of the text
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelShape.TextAnchoring">
            <summary>
            Text Anchoring
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelShape.TextAnchoringControl">
            <summary>
            Specifies the centering of the text box.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelShape.TextAlignment">
            <summary>
            How the text is aligned
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelShape.Indent">
            <summary>
            Indentation
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelShape.TextVertical">
            <summary>
            Vertical text
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.eLineCap">
            <summary>
            Type of Line cap
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.eLineStyle">
            <summary>
            Line style.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.ExcelDrawingBorder">
            <summary>
            Border for drawings
            </summary>    
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawingBorder.Fill">
            <summary>
            Fill
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawingBorder.LineStyle">
            <summary>
            Linestyle
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawingBorder.LineCap">
            <summary>
            Linecap
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawingBorder.Width">
            <summary>
            Width in pixels
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.ExcelDrawingFill">
            <summary>
            Fill properties for drawing objects
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawingFill.Style">
            <summary>
            Fill style
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawingFill.Color">
            <summary>
            Fill color for solid fills
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelDrawingFill.Transparancy">
            <summary>
            Transparancy in percent
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Drawing.ExcelView3D">
            <summary>
            3D settings
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelView3D.Perspective">
            <summary>
            Degree of perspective 
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelView3D.RotX">
            <summary>
            Rotation X-axis
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelView3D.RotY">
            <summary>
            Rotation Y-axis
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelView3D.RightAngleAxes">
            <summary>
            Right Angle Axes
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelView3D.DepthPercent">
            <summary>
            Depth % of base
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Drawing.ExcelView3D.HeightPercent">
            <summary>
            Height % of base
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Encryption.EncryptedPackageHandler">
            <summary>
            Handels encrypted Excel documents 
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Encryption.EncryptedPackageHandler.DecryptPackage(System.IO.FileInfo,OfficeOpenXml.ExcelEncryption)">
            <summary>
            Read the package from the OLE document and decrypt it using the supplied password
            </summary>
            <param name="fi">The file</param>
            <param name="encryption"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.Encryption.EncryptedPackageHandler.DecryptPackage(System.IO.MemoryStream,OfficeOpenXml.ExcelEncryption)">
            <summary>
            Read the package from the OLE document and decrypt it using the supplied password
            </summary>
            <param name="stream">The memory stream. </param>
            <param name="encryption">The encryption object from the Package</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.Encryption.EncryptedPackageHandler.EncryptPackage(System.Byte[],OfficeOpenXml.ExcelEncryption)">
            <summary>
            Encrypts a package
            </summary>
            <param name="package">The package as a byte array</param>
            <param name="encryption">The encryption info from the workbook</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.Encryption.EncryptedPackageHandler.CreateEncryptionInfo(System.String,OfficeOpenXml.Encryption.AlgorithmID,System.Byte[]@)">
            <summary>
            Create an EncryptionInfo object to encrypt a workbook
            </summary>
            <param name="password">The password</param>
            <param name="algID"></param>
            <param name="key">The Encryption key</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.Encryption.EncryptedPackageHandler.DecryptDocument(System.Byte[],OfficeOpenXml.Encryption.EncryptionInfo,System.String)">
            <summary>
            Decrypt a document
            </summary>
            <param name="data">The Encrypted data</param>
            <param name="encryptionInfo">Encryption Info object</param>
            <param name="password">The password</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.Encryption.EncryptedPackageHandler.IsPasswordValid(System.Byte[],OfficeOpenXml.Encryption.EncryptionInfoBinary)">
            <summary>
            Validate the password
            </summary>
            <param name="key">The encryption key</param>
            <param name="encryptionInfo">The encryption info extracted from the ENCRYPTIOINFO stream inside the OLE document</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.Encryption.EncryptedPackageHandler.IsPasswordValid(System.Security.Cryptography.HashAlgorithm,OfficeOpenXml.Encryption.EncryptionInfoAgile.EncryptionKeyEncryptor)">
            <summary>
            Validate the password
            </summary>
            <param name="sha">The hash algorithm</param>
            <param name="encr">The encryption info extracted from the ENCRYPTIOINFO stream inside the OLE document</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.Encryption.EncryptedPackageHandler.GetPasswordHashBinary(System.String,OfficeOpenXml.Encryption.EncryptionInfoBinary)">
            <summary>
            Create the hash.
            This method is written with the help of Lyquidity library, many thanks for this nice sample
            </summary>
            <param name="password">The password</param>
            <param name="encryptionInfo">The encryption info extracted from the ENCRYPTIOINFO stream inside the OLE document</param>
            <returns>The hash to encrypt the document</returns>
        </member>
        <member name="M:OfficeOpenXml.Encryption.EncryptedPackageHandler.GetPasswordHashAgile(System.String,OfficeOpenXml.Encryption.EncryptionInfoAgile.EncryptionKeyEncryptor,System.Byte[])">
            <summary>
            Create the hash.
            This method is written with the help of Lyquidity library, many thanks for this nice sample
            </summary>
            <param name="password">The password</param>
            <param name="encr">The encryption info extracted from the ENCRYPTIOINFO stream inside the OLE document</param>
            <param name="blockKey">The block key appended to the hash to obtain the final hash</param>
            <returns>The hash to encrypt the document</returns>
        </member>
        <member name="T:OfficeOpenXml.Encryption.EncryptionHeader">
            <summary>
            Encryption Header inside the EncryptionInfo stream
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Encryption.eCipherAlgorithm.AES">
            <summary>
            AES. MUST conform to the AES algorithm.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Encryption.eCipherAlgorithm.RC2">
            <summary>
            RC2. MUST conform to [RFC2268].
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Encryption.eCipherAlgorithm.RC4">
            <summary>
            RC4. 
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Encryption.eCipherAlgorithm.DES">
            <summary>
            MUST conform to the DES algorithm.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Encryption.eCipherAlgorithm.DESX">
            <summary>
            MUST conform to the [DRAFT-DESX] algorithm.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Encryption.eCipherAlgorithm.TRIPLE_DES">
            <summary>
            3DES. MUST conform to the [RFC1851] algorithm. 
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Encryption.eCipherAlgorithm.TRIPLE_DES_112">
            3DES_112 MUST conform to the [RFC1851] algorithm. 
        </member>
        <member name="F:OfficeOpenXml.Encryption.eChainingMode.ChainingModeCBC">
            <summary>
            Cipher block chaining (CBC).
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Encryption.eChainingMode.ChainingModeCFB">
            <summary>
            Cipher feedback chaining (CFB), with 8-bit window.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Encryption.eHashAlogorithm">
            <summary>
            Hashalgorithm
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Encryption.eHashAlogorithm.SHA1">
            <summary>
            Sha 1-MUST conform to [RFC4634]
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Encryption.eHashAlogorithm.SHA256">
            <summary>
            Sha 256-MUST conform to [RFC4634]
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Encryption.eHashAlogorithm.SHA384">
            <summary>
            Sha 384-MUST conform to [RFC4634]
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Encryption.eHashAlogorithm.SHA512">
            <summary>
            Sha 512-MUST conform to [RFC4634]
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Encryption.eHashAlogorithm.MD5">
            <summary>
            MD5
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Encryption.eHashAlogorithm.MD4">
            <summary>
            MD4
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Encryption.eHashAlogorithm.MD2">
            <summary>
            MD2
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Encryption.eHashAlogorithm.RIPEMD128">
            <summary>
            RIPEMD-128 MUST conform to [ISO/IEC 10118]
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Encryption.eHashAlogorithm.RIPEMD160">
            <summary>
            RIPEMD-160 MUST conform to [ISO/IEC 10118]
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Encryption.eHashAlogorithm.WHIRLPOOL">
            <summary>
            WHIRLPOOL MUST conform to [ISO/IEC 10118]
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Encryption.EncryptionInfoAgile">
            <summary>
            Handels the agile encryption
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Encryption.EncryptionInfoBinary">
            <summary>
            Handles the EncryptionInfo stream
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Encryption.EncryptionVerifier">
            <summary>
            Encryption verifier inside the EncryptionInfo stream
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ExcelBackgroundImage">
            <summary>
            An image that fills the background of the worksheet.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelBackgroundImage.#ctor(System.Xml.XmlNamespaceManager,System.Xml.XmlNode,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            
            </summary>
            <param name="nsm"></param>
            <param name="topNode">The topnode of the worksheet</param>
            <param name="workSheet">Worksheet reference</param>
        </member>
        <member name="P:OfficeOpenXml.ExcelBackgroundImage.Image">
            <summary>
            The background image of the worksheet. 
            The image will be saved internally as a jpg.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelBackgroundImage.SetFromFile(System.IO.FileInfo)">
            <summary>
            Set the picture from an image file. 
            The image file will be saved as a blob, so make sure Excel supports the image format.
            </summary>
            <param name="PictureFile">The image file.</param>
        </member>
        <member name="T:OfficeOpenXml.EncryptionAlgorithm">
            <summary>
            Encryption Algorithm
            </summary>
        </member>
        <member name="F:OfficeOpenXml.EncryptionAlgorithm.AES128">
            <summary>
            128-bit AES. Default
            </summary>
        </member>
        <member name="F:OfficeOpenXml.EncryptionAlgorithm.AES192">
            <summary>
            192-bit AES.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.EncryptionAlgorithm.AES256">
            <summary>
            256-bit AES. 
            </summary>
        </member>
        <member name="T:OfficeOpenXml.EncryptionVersion">
            <summary>
            The major version of the Encryption 
            </summary>
        </member>
        <member name="F:OfficeOpenXml.EncryptionVersion.Standard">
            <summary>
            Standard Encryption.
            Used in Excel 2007 and previous version with compatibility pack.
            <remarks>Default AES 128 with SHA-1 as the hash algorithm. Spincount is hardcoded to 50000</remarks>
            </summary>
        </member>
        <member name="F:OfficeOpenXml.EncryptionVersion.Agile">
            <summary>
            Agile Encryption.
            Used in Excel 2010-
            Default.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ExcelEncryption">
             <summary>
             How and if the workbook is encrypted
            <seealso cref="T:OfficeOpenXml.ExcelProtection"/> 
            <seealso cref="T:OfficeOpenXml.ExcelSheetProtection"/> 
             </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelEncryption.#ctor">
            <summary>
            Constructor
            <remarks>Default AES 256 with SHA-512 as the hash algorithm. Spincount is set to 100000</remarks>
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelEncryption.#ctor(OfficeOpenXml.EncryptionAlgorithm)">
            <summary>
            Constructor
            </summary>
            <param name="encryptionAlgorithm">Algorithm used to encrypt the package. Default is AES128</param>
        </member>
        <member name="P:OfficeOpenXml.ExcelEncryption.IsEncrypted">
            <summary>
            Is the package encrypted
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelEncryption.Password">
            <summary>
            The password used to encrypt the workbook.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelEncryption.Algorithm">
            <summary>
            Algorithm used for encrypting the package. Default is AES 128-bit for standard and AES 256 for agile
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelEncryption.Version">
            <summary>
            The version of the encryption.        
            </summary>
        </member>
        <member name="T:OfficeOpenXml.eProtectedRangeAlgorithm">
            <summary>
            Algorithm for password hash
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eProtectedRangeAlgorithm.MD2">
            <summary>
            Specifies that the MD2 algorithm, as defined by RFC 1319, shall be used.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eProtectedRangeAlgorithm.MD4">
            <summary>
            Specifies that the MD4 algorithm, as defined by RFC 1319, shall be used.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eProtectedRangeAlgorithm.MD5">
            <summary>
            Specifies that the MD5 algorithm, as defined by RFC 1319, shall be used.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eProtectedRangeAlgorithm.RIPEMD128">
            <summary>
            Specifies that the RIPEMD-128 algorithm, as defined by RFC 1319, shall be used.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eProtectedRangeAlgorithm.RIPEMD160">
            <summary>
            Specifies that the RIPEMD-160 algorithm, as defined by ISO/IEC10118-3:2004 shall be used.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eProtectedRangeAlgorithm.SHA1">
            <summary>
            Specifies that the SHA-1 algorithm, as defined by ISO/IEC 10118-3:2004 shall be used.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eProtectedRangeAlgorithm.SHA256">
            <summary>
            Specifies that the SHA-256 algorithm, as defined by ISO/IEC10118-3:2004 shall be used.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eProtectedRangeAlgorithm.SHA384">
            <summary>
            Specifies that the SHA-384 algorithm, as defined by ISO/IEC 10118-3:2004 shall be used.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eProtectedRangeAlgorithm.SHA512">
            <summary>
            Specifies that the SHA-512 algorithm, as defined by ISO/IEC10118-3:2004 shall be used.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eProtectedRangeAlgorithm.WHIRLPOOL">
            <summary>
            Specifies that the WHIRLPOOL algorithm, as defined by ISO/IEC 10118-3:2004 shall be used.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelProtectedRange.SetPassword(System.String)">
            <summary>
            Sets the password for the range
            </summary>
            <param name="password"></param>
        </member>
        <member name="T:OfficeOpenXml.ExcelStyleCollection`1">
            <summary>
            Base collection class for styles.
            </summary>
            <typeparam name="T">The style type</typeparam>
        </member>
        <member name="M:OfficeOpenXml.ExcelStyleCollection`1.FindByID(System.String,`0@)">
            <summary>
            Finds the key 
            </summary>
            <param name="key">the key to be found</param>
            <param name="obj">The found object.</param>
            <returns>True if found</returns>
        </member>
        <member name="M:OfficeOpenXml.ExcelStyleCollection`1.FindIndexByID(System.String)">
            <summary>
            Find Index
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.ExcelColumn">
            <summary>
            Represents one or more columns within the worksheet
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelColumn.#ctor(OfficeOpenXml.ExcelWorksheet,System.Int32)">
            <summary>
            Creates a new instance of the ExcelColumn class.  
            For internal use only!
            </summary>
            <param name="Worksheet"></param>
            <param name="col"></param>
        </member>
        <member name="P:OfficeOpenXml.ExcelColumn.ColumnMin">
            <summary>
            Sets the first column the definition refers to.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelColumn.ColumnMax">
            <summary>
            Sets the last column the definition refers to.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelColumn.ColumnID">
            <summary>
            Internal range id for the column
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelColumn._hidden">
            <summary>
            Allows the column to be hidden in the worksheet
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelColumn.Width">
            <summary>
            Sets the width of the column in the worksheet
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelColumn.BestFit">
            <summary>
            If set to true a column automaticlly resize(grow wider) when a user inputs numbers in a cell. 
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelColumn.Collapsed">
            <summary>
            If the column is collapsed in outline mode
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelColumn.OutlineLevel">
            <summary>
            Outline level. Zero if no outline
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelColumn.Phonetic">
            <summary>
            Phonetic
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelColumn.Style">
            <summary>
            The Style applied to the whole column. Only effects cells with no individual style set. 
            Use Range object if you want to set specific styles.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelColumn.StyleName">
            <summary>
            Sets the style for the entire column using a style name.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelColumn.StyleID">
            <summary>
            Sets the style for the entire column using the style ID.  
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelColumn.PageBreak">
            <summary>
            Adds a manual page break after the column.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelColumn.ToString">
            <summary>
            Returns the range of columns covered by the column definition.
            </summary>
            <returns>A string describing the range of columns covered by the column definition.</returns>
        </member>
        <member name="M:OfficeOpenXml.ExcelColumn.AutoFit">
            <summary>
            Set the column width from the content of the range. The minimum width is the value of the ExcelWorksheet.defaultColumnWidth property.
            Note: Cells containing formulas are ignored since EPPlus don't have a calculation engine.
                  Wrapped and merged cells are also ignored.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelColumn.AutoFit(System.Double)">
            <summary>
            Set the column width from the content.
            Note: Cells containing formulas are ignored since EPPlus don't have a calculation engine.
                  Wrapped and merged cells are also ignored.
            </summary>
            <param name="MinimumWidth">Minimum column width</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelColumn.AutoFit(System.Double,System.Double)">
            <summary>
            Set the column width from the content.
            Note: Cells containing formulas are ignored since EPPlus don't have a calculation engine.
                  Wrapped and merged cells are also ignored.
            </summary>
            <param name="MinimumWidth">Minimum column width</param>
            <param name="MaximumWidth">Maximum column width</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelColumn.GetColumnID(System.Int32,System.Int32)">
            <summary>
            Get the internal RangeID
            </summary>
            <param name="sheetID">Sheet no</param>
            <param name="column">Column</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ExcelColumn.Clone(OfficeOpenXml.ExcelWorksheet)">
            <summary>
            Copies the current column to a new worksheet
            </summary>
            <param name="added">The worksheet where the copy will be created</param>
        </member>
        <member name="T:OfficeOpenXml.PictureAlignment">
            <summary>
            How a picture will be aligned in the header/footer
            </summary>
        </member>
        <member name="F:OfficeOpenXml.PictureAlignment.Left">
            <summary>
            The picture will be added to the left aligned text
            </summary>
        </member>
        <member name="F:OfficeOpenXml.PictureAlignment.Centered">
            <summary>
            The picture will be added to the centered text
            </summary>
        </member>
        <member name="F:OfficeOpenXml.PictureAlignment.Right">
            <summary>
            The picture will be added to the right aligned text
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ExcelHeaderFooterText">
            <summary>
            Print header and footer 
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelHeaderFooterText.LeftAlignedText">
            <summary>
            Get/set the text to appear on the left hand side of the header (or footer) on the worksheet.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelHeaderFooterText.CenteredText">
            <summary>
            Get/set the text to appear in the center of the header (or footer) on the worksheet.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelHeaderFooterText.RightAlignedText">
            <summary>
            Get/set the text to appear on the right hand side of the header (or footer) on the worksheet.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelHeaderFooterText.InsertPicture(System.Drawing.Image,OfficeOpenXml.PictureAlignment)">
            <summary>
            Inserts a picture at the end of the text in the header or footer
            </summary>
            <param name="Picture">The image object containing the Picture</param>
            <param name="Alignment">Alignment. The image object will be inserted at the end of the Text.</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelHeaderFooterText.InsertPicture(System.IO.FileInfo,OfficeOpenXml.PictureAlignment)">
            <summary>
            Inserts a picture at the end of the text in the header or footer
            </summary>
            <param name="PictureFile">The image object containing the Picture</param>
            <param name="Alignment">Alignment. The image object will be inserted at the end of the Text.</param>
        </member>
        <member name="T:OfficeOpenXml.ExcelHeaderFooter">
            <summary>
            Represents the Header and Footer on an Excel Worksheet
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelHeaderFooter.PageNumber">
            <summary>
            The code for "current page #"
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelHeaderFooter.NumberOfPages">
            <summary>
            The code for "total pages"
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelHeaderFooter.FontColor">
            <summary>
            The code for "text font color"
            RGB Color is specified as RRGGBB
            Theme Color is specified as TTSNN where TT is the theme color Id, S is either "+" or "-" of the tint/shade value, NN is the tint/shade value.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelHeaderFooter.SheetName">
            <summary>
            The code for "sheet tab name"
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelHeaderFooter.FilePath">
            <summary>
            The code for "this workbook's file path"
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelHeaderFooter.FileName">
            <summary>
            The code for "this workbook's file name"
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelHeaderFooter.CurrentDate">
            <summary>
            The code for "date"
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelHeaderFooter.CurrentTime">
            <summary>
            The code for "time"
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelHeaderFooter.Image">
            <summary>
            The code for "picture as background"
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelHeaderFooter.OutlineStyle">
            <summary>
            The code for "outline style"
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelHeaderFooter.ShadowStyle">
            <summary>
            The code for "shadow style"
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelHeaderFooter.#ctor(System.Xml.XmlNamespaceManager,System.Xml.XmlNode,OfficeOpenXml.ExcelWorksheet)">
            <summary>
            ExcelHeaderFooter Constructor
            </summary>
            <param name="nameSpaceManager"></param>
            <param name="topNode"></param>
            <param name="ws">The worksheet</param>
        </member>
        <member name="P:OfficeOpenXml.ExcelHeaderFooter.AlignWithMargins">
            <summary>
            Gets/sets the alignWithMargins attribute
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelHeaderFooter.differentOddEven">
            <summary>
            Gets/sets the flag that tells Excel to display different headers and footers on odd and even pages.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelHeaderFooter.differentFirst">
            <summary>
            Gets/sets the flag that tells Excel to display different headers and footers on the first page of the worksheet.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelHeaderFooter.OddHeader">
            <summary>
            Provides access to the header on odd numbered pages of the document.
            If you want the same header on both odd and even pages, then only set values in this ExcelHeaderFooterText class.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelHeaderFooter.OddFooter">
            <summary>
            Provides access to the footer on odd numbered pages of the document.
            If you want the same footer on both odd and even pages, then only set values in this ExcelHeaderFooterText class.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelHeaderFooter.EvenHeader">
            <summary>
            Provides access to the header on even numbered pages of the document.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelHeaderFooter.EvenFooter">
            <summary>
            Provides access to the footer on even numbered pages of the document.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelHeaderFooter.FirstHeader">
            <summary>
            Provides access to the header on the first page of the document.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelHeaderFooter.FirstFooter">
            <summary>
            Provides access to the footer on the first page of the document.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelHeaderFooter.Pictures">
            <summary>
            Vml drawings. Underlaying object for Header footer images
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelHeaderFooter.Save">
            <summary>
            Saves the header and footer information to the worksheet XML
            </summary>
        </member>
        <member name="T:OfficeOpenXml.CompressionLevel">
            <summary>
            Maps to DotNetZips CompressionLevel enum
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ExcelPackage">
             <summary>
             Represents an Excel 2007/2010 XLSX file package.  
             This is the top-level object to access all parts of the document.
             <code>
                 FileInfo newFile = new FileInfo(outputDir.FullName + @"\sample1.xlsx");
             	if (newFile.Exists)
             	{
             		newFile.Delete();  // ensures we create a new workbook
             		newFile = new FileInfo(outputDir.FullName + @"\sample1.xlsx");
             	}
             	using (ExcelPackage package = new ExcelPackage(newFile))
                 {
                     // add a new worksheet to the empty workbook
                     ExcelWorksheet worksheet = package.Workbook.Worksheets.Add("Inventory");
                     //Add the headers
                     worksheet.Cells[1, 1].Value = "ID";
                     worksheet.Cells[1, 2].Value = "Product";
                     worksheet.Cells[1, 3].Value = "Quantity";
                     worksheet.Cells[1, 4].Value = "Price";
                     worksheet.Cells[1, 5].Value = "Value";
            
                     //Add some items...
                     worksheet.Cells["A2"].Value = "12001";
                     worksheet.Cells["B2"].Value = "Nails";
                     worksheet.Cells["C2"].Value = 37;
                     worksheet.Cells["D2"].Value = 3.99;
            
                     worksheet.Cells["A3"].Value = "12002";
                     worksheet.Cells["B3"].Value = "Hammer";
                     worksheet.Cells["C3"].Value = 5;
                     worksheet.Cells["D3"].Value = 12.10;
            
                     worksheet.Cells["A4"].Value = "12003";
                     worksheet.Cells["B4"].Value = "Saw";
                     worksheet.Cells["C4"].Value = 12;
                     worksheet.Cells["D4"].Value = 15.37;
            
                     //Add a formula for the value-column
                     worksheet.Cells["E2:E4"].Formula = "C2*D2";
            
                        //Ok now format the values;
                     using (var range = worksheet.Cells[1, 1, 1, 5]) 
                      {
                         range.Style.Font.Bold = true;
                         range.Style.Fill.PatternType = ExcelFillStyle.Solid;
                         range.Style.Fill.BackgroundColor.SetColor(Color.DarkBlue);
                         range.Style.Font.Color.SetColor(Color.White);
                     }
            
                     worksheet.Cells["A5:E5"].Style.Border.Top.Style = ExcelBorderStyle.Thin;
                     worksheet.Cells["A5:E5"].Style.Font.Bold = true;
            
                     worksheet.Cells[5, 3, 5, 5].Formula = string.Format("SUBTOTAL(9,{0})", new ExcelAddress(2,3,4,3).Address);
                     worksheet.Cells["C2:C5"].Style.Numberformat.Format = "#,##0";
                     worksheet.Cells["D2:E5"].Style.Numberformat.Format = "#,##0.00";
            
                     //Create an autofilter for the range
                     worksheet.Cells["A1:E4"].AutoFilter = true;
            
                     worksheet.Cells["A1:E5"].AutoFitColumns(0);
            
                     // lets set the header text 
                     worksheet.HeaderFooter.oddHeader.CenteredText = "&amp;24&amp;U&amp;\"Arial,Regular Bold\" Inventory";
                     // add the page number to the footer plus the total number of pages
                     worksheet.HeaderFooter.oddFooter.RightAlignedText =
                     string.Format("Page {0} of {1}", ExcelHeaderFooter.PageNumber, ExcelHeaderFooter.NumberOfPages);
                     // add the sheet name to the footer
                     worksheet.HeaderFooter.oddFooter.CenteredText = ExcelHeaderFooter.SheetName;
                     // add the file path to the footer
                     worksheet.HeaderFooter.oddFooter.LeftAlignedText = ExcelHeaderFooter.FilePath + ExcelHeaderFooter.FileName;
            
                     worksheet.PrinterSettings.RepeatRows = worksheet.Cells["1:2"];
                     worksheet.PrinterSettings.RepeatColumns = worksheet.Cells["A:G"];
            
                      // Change the sheet view to show it in page layout mode
                       worksheet.View.PageLayoutView = true;
            
                     // set some document properties
                     package.Workbook.Properties.Title = "Invertory";
                     package.Workbook.Properties.Author = "Jan Källman";
                     package.Workbook.Properties.Comments = "This sample demonstrates how to create an Excel 2007 workbook using EPPlus";
            
                     // set some extended property values
                     package.Workbook.Properties.Company = "AdventureWorks Inc.";
            
                     // set some custom property values
                     package.Workbook.Properties.SetCustomPropertyValue("Checked by", "Jan Källman");
                     package.Workbook.Properties.SetCustomPropertyValue("AssemblyName", "EPPlus");
            
                     // save our new workbook and we are done!
                     package.Save();
            
                   }
            
                   return newFile.FullName;
             </code>
             More samples can be found at  <a href="http://epplus.codeplex.com/">http://epplus.codeplex.com/</a>
             </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelPackage.schemaXmlExtension">
            <summary>
            Extention Schema types
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelPackage.schemaMain">
            <summary>
            Main Xml schema name
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelPackage.schemaRelationships">
            <summary>
            Relationship schema name
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelPackage.MaxColumns">
            <summary>
            Maximum number of columns in a worksheet (16384). 
            </summary>
        </member>
        <member name="F:OfficeOpenXml.ExcelPackage.MaxRows">
            <summary>
            Maximum number of rows in a worksheet (1048576). 
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.#ctor">
            <summary>
            Create a new instance of the ExcelPackage. Output is accessed through the Stream property.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.#ctor(System.IO.FileInfo)">
            <summary>
            Create a new instance of the ExcelPackage class based on a existing file or creates a new file. 
            </summary>
            <param name="newFile">If newFile exists, it is opened.  Otherwise it is created from scratch.</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.#ctor(System.IO.FileInfo,System.String)">
            <summary>
            Create a new instance of the ExcelPackage class based on a existing file or creates a new file. 
            </summary>
            <param name="newFile">If newFile exists, it is opened.  Otherwise it is created from scratch.</param>
            <param name="password">Password for an encrypted package</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.#ctor(System.IO.FileInfo,System.IO.FileInfo)">
            <summary>
            Create a new instance of the ExcelPackage class based on a existing template.
            If newFile exists, it will be overwritten when the Save method is called
            </summary>
            <param name="newFile">The name of the Excel file to be created</param>
            <param name="template">The name of the Excel template to use as the basis of the new Excel file</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.#ctor(System.IO.FileInfo,System.IO.FileInfo,System.String)">
            <summary>
            Create a new instance of the ExcelPackage class based on a existing template.
            If newFile exists, it will be overwritten when the Save method is called
            </summary>
            <param name="newFile">The name of the Excel file to be created</param>
            <param name="template">The name of the Excel template to use as the basis of the new Excel file</param>
            <param name="password">Password to decrypted the template</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.#ctor(System.IO.FileInfo,System.Boolean)">
            <summary>
            Create a new instance of the ExcelPackage class based on a existing template.
            </summary>
            <param name="template">The name of the Excel template to use as the basis of the new Excel file</param>
            <param name="useStream">if true use a stream. If false create a file in the temp dir with a random name</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.#ctor(System.IO.FileInfo,System.Boolean,System.String)">
            <summary>
            Create a new instance of the ExcelPackage class based on a existing template.
            </summary>
            <param name="template">The name of the Excel template to use as the basis of the new Excel file</param>
            <param name="useStream">if true use a stream. If false create a file in the temp dir with a random name</param>
            <param name="password">Password to decrypted the template</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.#ctor(System.IO.Stream)">
            <summary>
            Create a new instance of the ExcelPackage class based on a stream
            </summary>
            <param name="newStream">The stream object can be empty or contain a package. The stream must be Read/Write</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.#ctor(System.IO.Stream,System.String)">
            <summary>
            Create a new instance of the ExcelPackage class based on a stream
            </summary>
            <param name="newStream">The stream object can be empty or contain a package. The stream must be Read/Write</param>
            <param name="Password">The password to decrypt the document</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.#ctor(System.IO.Stream,System.IO.Stream)">
            <summary>
            Create a new instance of the ExcelPackage class based on a stream
            </summary>
            <param name="newStream">The output stream. Must be an empty read/write stream.</param>
            <param name="templateStream">This stream is copied to the output stream at load</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.#ctor(System.IO.Stream,System.IO.Stream,System.String)">
            <summary>
            Create a new instance of the ExcelPackage class based on a stream
            </summary>
            <param name="newStream">The output stream. Must be an empty read/write stream.</param>
            <param name="templateStream">This stream is copied to the output stream at load</param>
            <param name="Password">Password to decrypted the template</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.Init">
            <summary>
            Init values here
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.CreateFromTemplate(System.IO.FileInfo,System.String)">
            <summary>
            Create a new file from a template
            </summary>
            <param name="template">An existing xlsx file to use as a template</param>
            <param name="password">The password to decrypt the package.</param>
            <returns></returns>
        </member>
        <member name="P:OfficeOpenXml.ExcelPackage.Package">
            <summary>
            Returns a reference to the package
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelPackage.Encryption">
            <summary>
            Information how and if the package is encrypted
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelPackage.Workbook">
            <summary>
            Returns a reference to the workbook component within the package.
            All worksheets and cells can be accessed through the workbook.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelPackage.DoAdjustDrawings">
            <summary>
            Automaticlly adjust drawing size when column width/row height are adjusted, depending on the drawings editBy property.
            Default True
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.SavePart(System.Uri,System.Xml.XmlDocument)">
            <summary>
            Saves the XmlDocument into the package at the specified Uri.
            </summary>
            <param name="uri">The Uri of the component</param>
            <param name="xmlDoc">The XmlDocument to save</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.SaveWorkbook(System.Uri,System.Xml.XmlDocument)">
            <summary>
            Saves the XmlDocument into the package at the specified Uri.
            </summary>
            <param name="uri">The Uri of the component</param>
            <param name="xmlDoc">The XmlDocument to save</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.Dispose">
            <summary>
            Closes the package.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.Save">
            <summary>
            Saves all the components back into the package.
            This method recursively calls the Save method on all sub-components.
            We close the package after the save is done.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.Save(System.String)">
            <summary>
            Saves all the components back into the package.
            This method recursively calls the Save method on all sub-components.
            The package is closed after it ha
            d to encrypt the workbook with. 
            </summary>
            <param name="password">This parameter overrides the Workbook.Encryption.Password.</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.SaveAs(System.IO.FileInfo)">
            <summary>
            Saves the workbook to a new file
            The package is closed after it has been saved        
            </summary>
            <param name="file">The file location</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.SaveAs(System.IO.FileInfo,System.String)">
            <summary>
            Saves the workbook to a new file
            The package is closed after it has been saved
            </summary>
            <param name="file">The file</param>
            <param name="password">The password to encrypt the workbook with. 
            This parameter overrides the Encryption.Password.</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.SaveAs(System.IO.Stream)">
            <summary>
            Copies the Package to the Outstream
            The package is closed after it has been saved
            </summary>
            <param name="OutputStream">The stream to copy the package to</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.SaveAs(System.IO.Stream,System.String)">
            <summary>
            Copies the Package to the Outstream
            The package is closed after it has been saved
            </summary>
            <param name="OutputStream">The stream to copy the package to</param>
            <param name="password">The password to encrypt the workbook with. 
            This parameter overrides the Encryption.Password.</param>
        </member>
        <member name="P:OfficeOpenXml.ExcelPackage.File">
            <summary>
            The output file. Null if no file is used
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelPackage.Stream">
            <summary>
            The output stream. This stream is the not the encrypted package.
            To get the encrypted package use the SaveAs(stream) method.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelPackage.Compression">
            <summary>
            Compression option for the package
            </summary>        
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.GetXmlFromUri(System.Uri)">
            <summary>
            Get the XmlDocument from an URI
            </summary>
            <param name="uri">The Uri to the part</param>
            <returns>The XmlDocument</returns>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.GetAsByteArray">
            <summary>
            Saves and returns the Excel files as a bytearray.
            Note that the package is closed upon save
            </summary>
            <example>      
            Example how to return a document from a Webserver...
            <code> 
             ExcelPackage package=new ExcelPackage();
             /**** ... Create the document ****/
             Byte[] bin = package.GetAsByteArray();
             Response.ContentType = "Application/vnd.ms-Excel";
             Response.AddHeader("content-disposition", "attachment;  filename=TheFile.xlsx");
             Response.BinaryWrite(bin);
            </code>
            </example>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.GetAsByteArray(System.String)">
            <summary>
            Saves and returns the Excel files as a bytearray
            Note that the package is closed upon save
            </summary>
            <example>      
            Example how to return a document from a Webserver...
            <code> 
             ExcelPackage package=new ExcelPackage();
             /**** ... Create the document ****/
             Byte[] bin = package.GetAsByteArray();
             Response.ContentType = "Application/vnd.ms-Excel";
             Response.AddHeader("content-disposition", "attachment;  filename=TheFile.xlsx");
             Response.BinaryWrite(bin);
            </code>
            </example>
            <param name="password">The password to encrypt the workbook with. 
            This parameter overrides the Encryption.Password.</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.Load(System.IO.Stream)">
            <summary>
            Loads the specified package data from a stream.
            </summary>
            <param name="input">The input.</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.Load(System.IO.Stream,System.String)">
            <summary>
            Loads the specified package data from a stream.
            </summary>
            <param name="input">The input.</param>
            <param name="Password">The password to decrypt the document</param>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.Load(System.IO.Stream,System.IO.Stream,System.String)">
            <summary>
            
            </summary>
            <param name="input"></param>    
            <param name="output"></param>
            <param name="Password"></param>
        </member>
        <member name="M:OfficeOpenXml.ExcelPackage.CopyStream(System.IO.Stream,System.IO.Stream@)">
            <summary>
            Copies the input stream to the output stream.
            </summary>
            <param name="inputStream">The input stream.</param>
            <param name="outputStream">The output stream.</param>
        </member>
        <member name="T:OfficeOpenXml.ExcelRange">
            <summary>
            A range of cells. 
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelRange.Item(System.String)">
            <summary>
            Access the range using an address
            </summary>
            <param name="Address">The address</param>
            <returns>A range object</returns>
        </member>
        <member name="P:OfficeOpenXml.ExcelRange.Item(System.Int32,System.Int32)">
            <summary>
            Access a single cell
            </summary>
            <param name="Row">The row</param>
            <param name="Col">The column</param>
            <returns>A range object</returns>
        </member>
        <member name="P:OfficeOpenXml.ExcelRange.Item(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Access a range of cells
            </summary>
            <param name="FromRow">Start row</param>
            <param name="FromCol">Start column</param>
            <param name="ToRow">End Row</param>
            <param name="ToCol">End Column</param>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.ExcelRow">
            <summary>
            Represents an individual row in the spreadsheet.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelRow.RowID">
            <summary>
            Internal RowID.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelRow.#ctor(OfficeOpenXml.ExcelWorksheet,System.Int32)">
            <summary>
            Creates a new instance of the ExcelRow class. 
            For internal use only!
            </summary>
            <param name="Worksheet">The parent worksheet</param>
            <param name="row">The row number</param>
        </member>
        <member name="P:OfficeOpenXml.ExcelRow.Node">
            <summary>
            Provides access to the node representing the row.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelRow.Hidden">
            <summary>
            Allows the row to be hidden in the worksheet
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelRow.Height">
            <summary>
            Sets the height of the row
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelRow.CustomHeight">
            <summary>
            Set to true if You don't want the row to Autosize
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelRow.StyleName">
            <summary>
            Sets the style for the entire column using a style name.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelRow.StyleID">
            <summary>
            Sets the style for the entire row using the style ID.  
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelRow.Row">
            <summary>
            Rownumber
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelRow.Collapsed">
            <summary>
            If outline level is set this tells that the row is collapsed
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelRow.OutlineLevel">
            <summary>
            Outline level.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelRow.Phonetic">
            <summary>
            Show phonetic Information
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelRow.Style">
            <summary>
            The Style applied to the whole row. Only effekt cells with no individual style set. 
            Use ExcelRange object if you want to set specific styles.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelRow.PageBreak">
            <summary>
            Adds a manual page break after the row.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelRow.Clone(OfficeOpenXml.ExcelWorksheet)">
            <summary>
            Copies the current row to a new worksheet
            </summary>
            <param name="added">The worksheet where the copy will be created</param>
        </member>
        <member name="T:OfficeOpenXml.ExcelStyles">
            <summary>
            Containts all shared cell styles for a workbook
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelStyles.LoadFromDocument">
            <summary>
            Loads the style XML to memory
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelStyles.PropertyChange(OfficeOpenXml.Style.StyleBase,OfficeOpenXml.Style.StyleChangeEventArgs)">
            <summary>
            Handels changes of properties on the style objects
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ExcelStyles.NamedStylePropertyChange(OfficeOpenXml.Style.StyleBase,OfficeOpenXml.Style.StyleChangeEventArgs)">
            <summary>
            Handles property changes on Named styles.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.ExcelProtection">
             <summary>
             Sets protection on the workbook level
            <seealso cref="T:OfficeOpenXml.ExcelEncryption"/> 
            <seealso cref="T:OfficeOpenXml.ExcelSheetProtection"/> 
             </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelProtection.SetPassword(System.String)">
            <summary>
            Sets a password for the workbook. This does not encrypt the workbook. 
            </summary>
            <param name="Password">The password. </param>
        </member>
        <member name="P:OfficeOpenXml.ExcelProtection.LockStructure">
            <summary>
            Locks the structure,which prevents users from adding or deleting worksheets or from displaying hidden worksheets.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelProtection.LockWindows">
            <summary>
            Locks the position of the workbook window.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelProtection.LockRevision">
            <summary>
            Lock the workbook for revision
            </summary>
        </member>
        <member name="T:OfficeOpenXml.eDataTypes">
            <summary>
            Discribes a column when reading a text using the ExcelRangeBase.LoadFromText method
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eDataTypes.Unknown">
            <summary>
            Let the the import decide.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eDataTypes.String">
            <summary>
            Always a string.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eDataTypes.Number">
            <summary>
            Try to convert it to a number. If it fails then add it as a string.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eDataTypes.DateTime">
            <summary>
            Try to convert it to a date. If it fails then add it as a string.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eDataTypes.Percent">
            <summary>
            Try to convert it to a number and divide with 100. 
            Removes any tailing percent sign (%). If it fails then add it as a string.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ExcelTextFormat">
            <summary>
            Describes how to split a CSV text. Used by the ExcelRange.LoadFromText method
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelTextFormat.#ctor">
            <summary>
            Describes how to split a CSV text
            
            Default values
            <list>
            <listheader><term>Property</term><description>Value</description></listheader>
            <item><term>Delimiter</term><description>,</description></item>
            <item><term>TextQualifier</term><description>None (\0)</description></item>
            <item><term>EOL</term><description>CRLF</description></item>
            <item><term>Culture</term><description>CultureInfo.InvariantCulture</description></item>
            <item><term>DataTypes</term><description>End of line default CRLF</description></item>
            <item><term>SkipLinesBeginning</term><description>0</description></item>
            <item><term>SkipLinesEnd</term><description>0</description></item>
            <item><term>Encoding</term><description>Encoding.ASCII</description></item>
            </list>
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelTextFormat.Delimiter">
            <summary>
            Delimiter character
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelTextFormat.TextQualifier">
            <summary>
            Text qualifier character 
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelTextFormat.EOL">
            <summary>
            End of line characters. Default CRLF
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelTextFormat.DataTypes">
            <summary>
            Datatypes list for each column (if column is not present Unknown is assumed)
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelTextFormat.Culture">
            <summary>
            Culture used when parsing. Default CultureInfo.InvariantCulture
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelTextFormat.SkipLinesBeginning">
            <summary>
            Number of lines skiped in the begining of the file. Default 0.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelTextFormat.SkipLinesEnd">
            <summary>
            Number of lines skiped at the end of the file. Default 0.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.ExcelTextFormat.Encoding">
            <summary>
            Only used when reading files from disk using a FileInfo object. Default AscII
            </summary>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.DependencyChainFactory.FollowChain(OfficeOpenXml.FormulaParsing.DependencyChain,OfficeOpenXml.FormulaParsing.LexicalAnalysis.ILexer,OfficeOpenXml.ExcelWorkbook,OfficeOpenXml.ExcelWorksheet,OfficeOpenXml.FormulaParsing.FormulaCell,OfficeOpenXml.FormulaParsing.ExcelCalculationOption)">
            <summary>
            This method follows the calculation chain to get the order of the calculation
            Goto (!) is used internally to prevent stackoverflow on extremly larget dependency trees (that is, many recursive formulas).
            </summary>
            <param name="depChain">The dependency chain object</param>
            <param name="lexer">The formula tokenizer</param>
            <param name="wb">The workbook where the formula comes from</param>
            <param name="ws">The worksheet where the formula comes from</param>
            <param name="f">The cell function object</param>
            <param name="options">Calcultaiton options</param>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.ExcelDataProvider">
            <summary>
            This class should be implemented to be able to deliver excel data
            to the formula parser.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.ExcelDataProvider.IRangeInfo">
            <summary>
            A range of cells in a worksheet.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.ExcelDataProvider.ICellInfo">
            <summary>
            Information and help methods about a cell
            </summary>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.ExcelDataProvider.GetWorksheetNames(System.String)">
            <summary>
            Returns the names of all worksheet names
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.ExcelDataProvider.GetWorkbookNameValues">
            <summary>
            Returns all defined names in a workbook
            </summary>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.ExcelDataProvider.GetRange(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Returns values from the required range.
            </summary>
            <param name="worksheetName">The name of the worksheet</param>
            <param name="row">Row</param>
            <param name="column">Column</param>
            <param name="address">The reference address</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.ExcelDataProvider.GetCellValue(System.String,System.Int32,System.Int32)">
            <summary>
            Returns a single cell value
            </summary>
            <param name="sheetName"></param>
            <param name="row"></param>
            <param name="col"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.ExcelDataProvider.GetDimensionEnd(System.String)">
            <summary>
            Returns the address of the lowest rightmost cell on the worksheet.
            </summary>
            <param name="worksheet"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.ExcelDataProvider.Dispose">
            <summary>
            Use this method to free unmanaged resources.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.FormulaParsing.ExcelDataProvider.ExcelMaxColumns">
            <summary>
            Max number of columns in a worksheet that the Excel data provider can handle.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.FormulaParsing.ExcelDataProvider.ExcelMaxRows">
            <summary>
            Max number of rows in a worksheet that the Excel data provider can handle
            </summary>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.ExcelUtilities.AddressTranslator">
            <summary>
            Handles translations from Spreadsheet addresses to 0-based numeric index.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.ExcelUtilities.AddressTranslator.ToColAndRow(System.String,System.Int32@,System.Int32@)">
            <summary>
            Translates an address in format "A1" to col- and rowindex.
            
            If the supplied address is a range, the address of the first part will be calculated.
            </summary>
            <param name="address"></param>
            <param name="col"></param>
            <param name="row"></param>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.ExcelUtilities.AddressTranslator.ToColAndRow(System.String,System.Int32@,System.Int32@,OfficeOpenXml.FormulaParsing.ExcelUtilities.AddressTranslator.RangeCalculationBehaviour)">
            <summary>
            Translates an address in format "A1" to col- and rowindex.
            </summary>
            <param name="address"></param>
            <param name="col"></param>
            <param name="row"></param>
            <param name="behaviour"></param>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.ExcelUtilities.RangeAddress.CollidesWith(OfficeOpenXml.FormulaParsing.ExcelUtilities.RangeAddress)">
            <summary>
            Returns true if this range collides (full or partly) with the supplied range
            </summary>
            <param name="other">The range to check</param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.ExcelUtilities.RangeAddressFactory.Create(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="worksheetName">will be used if no worksheet name is specified in <paramref name="address"/></param>
            <param name="address">address of a range</param>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.DateValue">
            <summary>
            Simple implementation of DateValue function, just using .NET built-in
            function System.DateTime.TryParse, based on current culture
            </summary>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.IsoWeekNum.WeekNumber(System.DateTime)">
            <summary>
            This implementation was found on http://stackoverflow.com/questions/1285191/get-week-of-date-from-linq-query
            </summary>
            <param name="fromDate"></param>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.TimeValue">
            <summary>
            Simple implementation of TimeValue function, just using .NET built-in
            function System.DateTime.TryParse, based on current culture
            </summary>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.Excel.Functions.ErrorHandlingFunction">
            <summary>
            Base class for functions that handles an error that occurs during the
            normal execution of the function.
            If an exception occurs during the Execute-call that exception will be
            caught by the compiler, then the HandleError-method will be called.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.FormulaParsing.Excel.Functions.ErrorHandlingFunction.IsErrorHandlingFunction">
            <summary>
            Indicates that the function is an ErrorHandlingFunction.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ErrorHandlingFunction.HandleError(System.String)">
            <summary>
            Method that should be implemented to handle the error.
            </summary>
            <param name="errorCode"></param>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction">
            <summary>
            Base class for Excel function implementations.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.Execute(System.Collections.Generic.IEnumerable{OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionArgument},OfficeOpenXml.FormulaParsing.ParsingContext)">
            <summary>
            
            </summary>
            <param name="arguments">Arguments to the function, each argument can contain primitive types, lists or <see cref="T:OfficeOpenXml.FormulaParsing.ExcelDataProvider.IRangeInfo">Excel ranges</see></param>
            <param name="context">The <see cref="T:OfficeOpenXml.FormulaParsing.ParsingContext"/> contains various data that can be useful in functions.</param>
            <returns>A <see cref="T:OfficeOpenXml.FormulaParsing.ExpressionGraph.CompileResult"/> containing the calculated value</returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.BeforeInvoke(OfficeOpenXml.FormulaParsing.ParsingContext)">
            <summary>
            If overridden, this method is called before Execute is called.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.SkipArgumentEvaluation">
            <summary>
            Used for some Lookupfunctions to indicate that function arguments should
            not be compiled before the function is called.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.ValidateArguments(System.Collections.Generic.IEnumerable{OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionArgument},System.Int32,OfficeOpenXml.eErrorType)">
            <summary>
            This functions validates that the supplied <paramref name="arguments"/> contains at least
            (the value of) <paramref name="minLength"/> elements. If one of the arguments is an
            <see cref="T:OfficeOpenXml.FormulaParsing.ExcelDataProvider.IRangeInfo">Excel range</see> the number of cells in
            that range will be counted as well.
            </summary>
            <param name="arguments"></param>
            <param name="minLength"></param>
            <param name="errorTypeToThrow">The <see cref="T:OfficeOpenXml.eErrorType"/> of the <see cref="T:OfficeOpenXml.FormulaParsing.Exceptions.ExcelErrorValueException"/> that will be thrown if <paramref name="minLength"/> is not met.</param>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.ValidateArguments(System.Collections.Generic.IEnumerable{OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionArgument},System.Int32)">
            <summary>
            This functions validates that the supplied <paramref name="arguments"/> contains at least
            (the value of) <paramref name="minLength"/> elements. If one of the arguments is an
            <see cref="T:OfficeOpenXml.FormulaParsing.ExcelDataProvider.IRangeInfo">Excel range</see> the number of cells in
            that range will be counted as well.
            </summary>
            <param name="arguments"></param>
            <param name="minLength"></param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.ArgToInt(System.Collections.Generic.IEnumerable{OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionArgument},System.Int32)">
            <summary>
            Returns the value of the argument att the position of the 0-based
            <paramref name="index"/> as an integer.
            </summary>
            <param name="arguments"></param>
            <param name="index"></param>
            <returns>Value of the argument as an integer.</returns>
            <exception cref="T:OfficeOpenXml.FormulaParsing.Exceptions.ExcelErrorValueException"></exception>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.ArgToString(System.Collections.Generic.IEnumerable{OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionArgument},System.Int32)">
            <summary>
            Returns the value of the argument att the position of the 0-based
            <paramref name="index"/> as a string.
            </summary>
            <param name="arguments"></param>
            <param name="index"></param>
            <returns>Value of the argument as a string.</returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.ArgToDecimal(System.Object)">
            <summary>
            Returns the value of the argument att the position of the 0-based
            </summary>
            <param name="obj"></param>
            <returns>Value of the argument as a double.</returns>
            <exception cref="T:OfficeOpenXml.FormulaParsing.Exceptions.ExcelErrorValueException"></exception>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.ArgToDecimal(System.Collections.Generic.IEnumerable{OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionArgument},System.Int32)">
            <summary>
            Returns the value of the argument att the position of the 0-based
            <paramref name="index"/> as a <see cref="T:System.Double"/>.
            </summary>
            <param name="arguments"></param>
            <param name="index"></param>
            <returns>Value of the argument as an integer.</returns>
            <exception cref="T:OfficeOpenXml.FormulaParsing.Exceptions.ExcelErrorValueException"></exception>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.ArgToBool(System.Collections.Generic.IEnumerable{OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionArgument},System.Int32)">
            <summary>
            If the argument is a boolean value its value will be returned.
            If the argument is an integer value, true will be returned if its
            value is not 0, otherwise false.
            </summary>
            <param name="arguments"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.ThrowArgumentExceptionIf(System.Func{System.Boolean},System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentException"/> if <paramref name="condition"/> evaluates to true.
            </summary>
            <param name="condition"></param>
            <param name="message"></param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.ThrowArgumentExceptionIf(System.Func{System.Boolean},System.String,System.Object[])">
            <summary>
            Throws an <see cref="T:System.ArgumentException"/> if <paramref name="condition"/> evaluates to true.
            </summary>
            <param name="condition"></param>
            <param name="message"></param>
            <param name="formats">Formats to the message string.</param>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.ThrowExcelErrorValueException(OfficeOpenXml.eErrorType)">
            <summary>
            Throws an <see cref="T:OfficeOpenXml.FormulaParsing.Exceptions.ExcelErrorValueException"/> with the given <paramref name="errorType"/> set.
            </summary>
            <param name="errorType"></param>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.ThrowExcelErrorValueExceptionIf(System.Func{System.Boolean},OfficeOpenXml.eErrorType)">
            <summary>
            Throws an <see cref="T:System.ArgumentException"/> if <paramref name="condition"/> evaluates to true.
            </summary>
            <param name="condition"></param>
            <param name="errorType"></param>
            <exception cref="T:OfficeOpenXml.FormulaParsing.Exceptions.ExcelErrorValueException"></exception>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.AreEqual(System.Double,System.Double)">
            <summary>
            Helper method for comparison of two doubles.
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.ArgsToDoubleEnumerable(System.Collections.Generic.IEnumerable{OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionArgument},OfficeOpenXml.FormulaParsing.ParsingContext)">
            <summary>
            Will return the arguments as an enumerable of doubles.
            </summary>
            <param name="arguments"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.ArgsToDoubleEnumerable(System.Boolean,System.Boolean,System.Collections.Generic.IEnumerable{OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionArgument},OfficeOpenXml.FormulaParsing.ParsingContext)">
            <summary>
            Will return the arguments as an enumerable of doubles.
            </summary>
            <param name="ignoreHiddenCells">If a cell is hidden and this value is true the value of that cell will be ignored</param>
            <param name="ignoreErrors">If a cell contains an error, that error will be ignored if this method is set to true</param>
            <param name="arguments"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.ArgsToDoubleEnumerable(System.Boolean,System.Collections.Generic.IEnumerable{OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionArgument},OfficeOpenXml.FormulaParsing.ParsingContext)">
            <summary>
            Will return the arguments as an enumerable of doubles.
            </summary>
            <param name="ignoreHiddenCells">If a cell is hidden and this value is true the value of that cell will be ignored</param>
            <param name="arguments"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.ArgsToObjectEnumerable(System.Boolean,System.Collections.Generic.IEnumerable{OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionArgument},OfficeOpenXml.FormulaParsing.ParsingContext)">
            <summary>
            Will return the arguments as an enumerable of objects.
            </summary>
            <param name="ignoreHiddenCells">If a cell is hidden and this value is true the value of that cell will be ignored</param>
            <param name="arguments"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.CreateResult(System.Object,OfficeOpenXml.FormulaParsing.ExpressionGraph.DataType)">
            <summary>
            Use this method to create a result to return from Excel functions. 
            </summary>
            <param name="result"></param>
            <param name="dataType"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.CalculateCollection(System.Collections.Generic.IEnumerable{OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionArgument},System.Double,System.Func{OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionArgument,System.Double,System.Double})">
            <summary>
            Use this method to apply a function on a collection of arguments. The <paramref name="result"/>
            should be modifyed in the supplied <paramref name="action"/> and will contain the result
            after this operation has been performed.
            </summary>
            <param name="collection"></param>
            <param name="result"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.CheckForAndHandleExcelError(OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionArgument)">
            <summary>
            if the supplied <paramref name="arg">argument</paramref> contains an Excel error
            an <see cref="T:OfficeOpenXml.FormulaParsing.Exceptions.ExcelErrorValueException"/> with that errorcode will be thrown
            </summary>
            <param name="arg"></param>
            <exception cref="T:OfficeOpenXml.FormulaParsing.Exceptions.ExcelErrorValueException"></exception>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction.CheckForAndHandleExcelError(OfficeOpenXml.FormulaParsing.ExcelDataProvider.ICellInfo)">
            <summary>
            If the supplied <paramref name="cell"/> contains an Excel error
            an <see cref="T:OfficeOpenXml.FormulaParsing.Exceptions.ExcelErrorValueException"/> with that errorcode will be thrown
            </summary>
            <param name="cell"></param>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionRepository">
            <summary>
            This class provides methods for accessing/modifying VBA Functions.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionRepository.LoadModule(OfficeOpenXml.FormulaParsing.Excel.Functions.IFunctionModule)">
            <summary>
            Loads a module of <see cref="T:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction"/>s to the function repository.
            </summary>
            <param name="module">A <see cref="T:OfficeOpenXml.FormulaParsing.Excel.Functions.IFunctionModule"/> that can be used for adding functions</param>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionRepository.Clear">
            <summary>
            Removes all functions from the repository
            </summary>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionRepository.IsFunctionName(System.String)">
            <summary>
            Returns true if the the supplied <paramref name="name"/> exists in the repository.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionRepository.FunctionNames">
            <summary>
            Returns the names of all implemented functions.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionRepository.AddOrReplaceFunction(System.String,OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction)">
            <summary>
            Adds or replaces a function.
            </summary>
            <param name="functionName"> Case-insensitive name of the function that should be added or replaced.</param>
            <param name="functionImpl">An implementation of an <see cref="T:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction"/>.</param>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionsModule">
            <summary>
            Base class 
            </summary>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.Excel.Functions.HiddenValuesHandlingFunction">
            <summary>
            Base class for functions that needs to handle cells that is not visible.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.FormulaParsing.Excel.Functions.HiddenValuesHandlingFunction.IgnoreHiddenValues">
            <summary>
            Set to true or false to indicate whether the function should ignore hidden values.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.Excel.Functions.Math.MathHelper">
            <summary>
            Thanks to the guys in this thread: http://stackoverflow.com/questions/2840798/c-sharp-math-class-question
            </summary>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.Exceptions.ExcelErrorValueException">
            <summary>
            This Exception represents an Excel error. When this exception is thrown
            from an Excel function, the ErrorValue code will be set as the value of the
            parsed cell.
            </summary>
            <seealso cref="T:OfficeOpenXml.ExcelErrorValue"/>
        </member>
        <member name="P:OfficeOpenXml.FormulaParsing.Exceptions.ExcelErrorValueException.ErrorValue">
            <summary>
            The error value
            </summary>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.ExpressionGraph.FunctionCompilers.IfFunctionCompiler">
            <summary>
            Why do the If function require a compiler of its own you might ask;)
            
            It is because it only needs to evaluate one of the two last expressions. This
            compiler handles this - it ignores the irrelevant expression.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.ExpressionGraph.FunctionExpression">
            <summary>
            Expression that handles execution of a function.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.ExpressionGraph.FunctionExpression.#ctor(System.String,OfficeOpenXml.FormulaParsing.ParsingContext,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="expression">should be the of the function</param>
            <param name="parsingContext"></param>
            <param name="isNegated">True if the numeric result of the function should be negated.</param>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.FormulaParserManager">
            <summary>
            Provides access to various functionality regarding 
            excel formula evaluation.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.FormulaParserManager.LoadFunctionModule(OfficeOpenXml.FormulaParsing.Excel.Functions.IFunctionModule)">
            <summary>
            Loads a module containing custom functions to the formula parser. By using
            this method you can add your own implementations of Excel functions, by
            implementing a <see cref="T:OfficeOpenXml.FormulaParsing.Excel.Functions.IFunctionModule"/>.
            </summary>
            <param name="module">A <see cref="T:OfficeOpenXml.FormulaParsing.Excel.Functions.IFunctionModule"/> containing <see cref="T:OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction"/>s.</param>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.FormulaParserManager.AddOrReplaceFunction(System.String,OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction)">
            <summary>
            If the supplied <paramref name="functionName"/> does not exist, the supplied
            <paramref name="functionImpl"/> implementation will be added to the formula parser.
            If it exists, the existing function will be replaced by the supplied <paramref name="functionImpl">function implementation</paramref>
            </summary>
            <param name="functionName"></param>
            <param name="functionImpl"></param>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.FormulaParserManager.GetImplementedFunctionNames">
            <summary>
            Returns an enumeration of all functions implemented, both the built in functions
            and functions added using the LoadFunctionModule method of this class.
            </summary>
            <returns>Function names in lower case</returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.FormulaParserManager.Parse(System.String)">
            <summary>
            Parses the supplied <paramref name="formula"/> and returns the result.
            </summary>
            <param name="formula"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.FormulaParserManager.AttachLogger(OfficeOpenXml.FormulaParsing.Logging.IFormulaParserLogger)">
            <summary>
            Attaches a logger to the <see cref="T:OfficeOpenXml.FormulaParsing.FormulaParser"/>.
            </summary>
            <param name="logger">An instance of <see cref="T:OfficeOpenXml.FormulaParsing.Logging.IFormulaParserLogger"/></param>
            <see cref="T:OfficeOpenXml.FormulaParsing.Logging.LoggerFactory"/>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.FormulaParserManager.AttachLogger(System.IO.FileInfo)">
            <summary>
            Attaches a logger to the formula parser that produces output to the supplied logfile.
            </summary>
            <param name="logfile"></param>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.FormulaParserManager.DetachLogger">
            <summary>
            Detaches any attached logger from the formula parser.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.LexicalAnalysis.TokenSeparatorHandlers.TokenSeparatorHandler">
            <summary>
            This class provides access to <see cref="T:OfficeOpenXml.FormulaParsing.LexicalAnalysis.TokenSeparatorHandlers.SeparatorHandler"/>s - classes that exposes functionatlity
            needed when parsing strings to tokens.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.LexicalAnalysis.TokenSeparatorHandlers.TokenSeparatorHandler.Handle(System.Char,OfficeOpenXml.FormulaParsing.LexicalAnalysis.Token,OfficeOpenXml.FormulaParsing.LexicalAnalysis.TokenizerContext,OfficeOpenXml.FormulaParsing.LexicalAnalysis.ITokenIndexProvider)">
            <summary>
            Handles a tokenseparator.
            </summary>
            <param name="c"></param>
            <param name="tokenSeparator"></param>
            <param name="context"></param>
            <param name="tokenIndexProvider"></param>
            <returns>Returns true if the tokenseparator was handled.</returns>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.Logging.IFormulaParserLogger">
            <summary>
            Used for logging during FormulaParsing
            </summary>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Logging.IFormulaParserLogger.Log(OfficeOpenXml.FormulaParsing.ParsingContext,System.Exception)">
            <summary>
            Called each time an exception occurs during formula parsing.
            </summary>
            <param name="context"></param>
            <param name="ex"></param>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Logging.IFormulaParserLogger.Log(OfficeOpenXml.FormulaParsing.ParsingContext,System.String)">
            <summary>
            Called each time information should be logged during formula parsing.
            </summary>
            <param name="context"></param>
            <param name="message"></param>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Logging.IFormulaParserLogger.Log(System.String)">
            <summary>
            Called to log a message outside the parsing context.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Logging.IFormulaParserLogger.LogCellCounted">
            <summary>
            Called each time a cell within the calc chain is accessed during formula parsing.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Logging.IFormulaParserLogger.LogFunction(System.String)">
            <summary>
            Called each time a function is called during formula parsing.
            </summary>
            <param name="func"></param>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Logging.IFormulaParserLogger.LogFunction(System.String,System.Int64)">
            <summary>
            Some functions measure performance, if so this function will be called.
            </summary>
            <param name="func"></param>
            <param name="milliseconds"></param>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.Logging.LoggerFactory">
            <summary>
            Create loggers that can be used for logging the formula parser.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.Logging.LoggerFactory.CreateTextFileLogger(System.IO.FileInfo)">
            <summary>
            Creates a logger that logs to a simple textfile.
            </summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.ParsingConfiguration.AttachLogger(OfficeOpenXml.FormulaParsing.Logging.IFormulaParserLogger)">
            <summary>
            Attaches a logger, errors and log entries will be written to the logger during the parsing process.
            </summary>
            <param name="logger"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.ParsingConfiguration.DetachLogger">
            <summary>
            if a logger is attached it will be removed.
            </summary>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.ParsingContext">
            <summary>
            Parsing context
            </summary>
        </member>
        <member name="P:OfficeOpenXml.FormulaParsing.ParsingContext.Parser">
            <summary>
            The <see cref="T:OfficeOpenXml.FormulaParsing.FormulaParser"/> of the current context.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.FormulaParsing.ParsingContext.ExcelDataProvider">
            <summary>
            The <see cref="P:OfficeOpenXml.FormulaParsing.ParsingContext.ExcelDataProvider"/> is an abstraction on top of
            Excel, in this case EPPlus.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.FormulaParsing.ParsingContext.RangeAddressFactory">
            <summary>
            Utility for handling addresses
            </summary>
        </member>
        <member name="P:OfficeOpenXml.FormulaParsing.ParsingContext.NameValueProvider">
            <summary>
            <see cref="T:OfficeOpenXml.FormulaParsing.INameValueProvider"/> of the current context
            </summary>
        </member>
        <member name="P:OfficeOpenXml.FormulaParsing.ParsingContext.Configuration">
            <summary>
            Configuration
            </summary>
        </member>
        <member name="P:OfficeOpenXml.FormulaParsing.ParsingContext.Scopes">
            <summary>
            Scopes, a scope represents the parsing of a cell or a value.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.FormulaParsing.ParsingContext.Debug">
            <summary>
            Returns true if a <see cref="T:OfficeOpenXml.FormulaParsing.Logging.IFormulaParserLogger"/> is attached to the parser.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.ParsingContext.Create">
            <summary>
            Factory method.
            </summary>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.ParsingScope">
            <summary>
            Represents a parsing of a single input or workbook addrses.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.FormulaParsing.ParsingScope.ScopeId">
            <summary>
            Id of the scope.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.FormulaParsing.ParsingScope.Parent">
            <summary>
            The calling scope.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.FormulaParsing.ParsingScope.Address">
            <summary>
            The address of the cell currently beeing parsed.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.FormulaParsing.ParsingScope.IsSubtotal">
            <summary>
            True if the current scope is a Subtotal function beeing executed.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.FormulaParsing.ParsingScopes">
            <summary>
            This class implements a stack on which instances of <see cref="T:OfficeOpenXml.FormulaParsing.ParsingScope"/>
            are put. Each ParsingScope represents the parsing of an address in the workbook.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.ParsingScopes.NewScope(OfficeOpenXml.FormulaParsing.ExcelUtilities.RangeAddress)">
            <summary>
            Creates a new <see cref="T:OfficeOpenXml.FormulaParsing.ParsingScope"/> and puts it on top of the stack.
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="P:OfficeOpenXml.FormulaParsing.ParsingScopes.Current">
            <summary>
            The current parsing scope.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.FormulaParsing.ParsingScopes.KillScope(OfficeOpenXml.FormulaParsing.ParsingScope)">
            <summary>
            Removes the current scope, setting the calling scope to current.
            </summary>
            <param name="parsingScope"></param>
        </member>
        <member name="T:OfficeOpenXml.eErrorType">
            <summary>
            Represents the errortypes in excel
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eErrorType.Div0">
            <summary>
            Division by zero
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eErrorType.NA">
            <summary>
            Not applicable
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eErrorType.Name">
            <summary>
            Name error
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eErrorType.Null">
            <summary>
            Null error
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eErrorType.Num">
            <summary>
            Num error
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eErrorType.Ref">
            <summary>
            Reference error
            </summary>
        </member>
        <member name="F:OfficeOpenXml.eErrorType.Value">
            <summary>
            Value error
            </summary>
        </member>
        <member name="T:OfficeOpenXml.ExcelErrorValue">
            <summary>
            Represents an Excel error.
            </summary>
            <seealso cref="T:OfficeOpenXml.eErrorType"/>
        </member>
        <member name="T:OfficeOpenXml.ExcelErrorValue.Values">
            <summary>
            Handles the convertion between <see cref="T:OfficeOpenXml.eErrorType"/> and the string values
            used by Excel.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelErrorValue.Values.IsErrorValue(System.Object)">
            <summary>
            Returns true if the supplied <paramref name="candidate"/> is an excel error.
            </summary>
            <param name="candidate"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ExcelErrorValue.Values.StringIsErrorValue(System.String)">
            <summary>
            Returns true if the supplied <paramref name="candidate"/> is an excel error.
            </summary>
            <param name="candidate"></param>
            <returns></returns>
        </member>
        <member name="M:OfficeOpenXml.ExcelErrorValue.Values.ToErrorType(System.String)">
            <summary>
            Converts a string to an <see cref="T:OfficeOpenXml.eErrorType"/>
            </summary>
            <param name="val"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException">Thrown if the supplied value is not an Excel error</exception>
        </member>
        <member name="P:OfficeOpenXml.ExcelErrorValue.Type">
            <summary>
            The error type
            </summary>
        </member>
        <member name="M:OfficeOpenXml.ExcelErrorValue.ToString">
            <summary>
            Returns the string representation of the error type
            </summary>
            <returns></returns>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.ComHelper">
            <summary>
            This class exposes a set of COM-accessible wrappers for static
            methods available on the ZipFile class.  You don't need this
            class unless you are using DotNetZip from a COM environment.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ComHelper.IsZipFile(System.String)">
            <summary>
             A wrapper for <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.IsZipFile(System.String)">ZipFile.IsZipFile(string)</see>
            </summary>
            <param name="filename">The filename to of the zip file to check.</param>
            <returns>true if the file contains a valid zip file.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ComHelper.IsZipFileWithExtract(System.String)">
            <summary>
             A wrapper for <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)">ZipFile.IsZipFile(string, bool)</see>
            </summary>
            <remarks>
            We cannot use "overloaded" Method names in COM interop.
            So, here, we use a unique name.
            </remarks>
            <param name="filename">The filename to of the zip file to check.</param>
            <returns>true if the file contains a valid zip file.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ComHelper.CheckZip(System.String)">
             <summary>
              A wrapper for <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CheckZip(System.String)">ZipFile.CheckZip(string)</see>
             </summary>
             <param name="filename">The filename to of the zip file to check.</param>
            
             <returns>true if the named zip file checks OK. Otherwise, false. </returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ComHelper.CheckZipPassword(System.String,System.String)">
             <summary>
              A COM-friendly wrapper for the static method <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CheckZipPassword(System.String,System.String)"/>.
             </summary>
            
             <param name="filename">The filename to of the zip file to check.</param>
            
             <param name="password">The password to check.</param>
            
             <returns>true if the named zip file checks OK. Otherwise, false. </returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ComHelper.FixZipDirectory(System.String)">
            <summary>
             A wrapper for <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.FixZipDirectory(System.String)">ZipFile.FixZipDirectory(string)</see>
            </summary>
            <param name="filename">The filename to of the zip file to fix.</param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ComHelper.GetZipLibraryVersion">
            <summary>
             A wrapper for <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.LibraryVersion">ZipFile.LibraryVersion</see>
            </summary>
            <returns>
             the version number on the DotNetZip assembly, formatted as a string.
            </returns>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.EncryptionAlgorithm">
             <summary>
             An enum that provides the various encryption algorithms supported by this
             library.
             </summary>
            
             <remarks>
            
             <para>
               <c>PkzipWeak</c> implies the use of Zip 2.0 encryption, which is known to be
               weak and subvertible.
             </para>
            
             <para>
               A note on interoperability: Values of <c>PkzipWeak</c> and <c>None</c> are
               specified in <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's zip
               specification</see>, and are considered to be "standard".  Zip archives
               produced using these options will be interoperable with many other zip tools
               and libraries, including Windows Explorer.
             </para>
            
             <para>
               Values of <c>WinZipAes128</c> and <c>WinZipAes256</c> are not part of the Zip
               specification, but rather imply the use of a vendor-specific extension from
               WinZip. If you want to produce interoperable Zip archives, do not use these
               values.  For example, if you produce a zip archive using WinZipAes256, you
               will be able to open it in Windows Explorer on Windows XP and Vista, but you
               will not be able to extract entries; trying this will lead to an "unspecified
               error". For this reason, some people have said that a zip archive that uses
               WinZip's AES encryption is not actually a zip archive at all.  A zip archive
               produced this way will be readable with the WinZip tool (Version 11 and
               beyond).
             </para>
            
             <para>
               There are other third-party tools and libraries, both commercial and
               otherwise, that support WinZip's AES encryption. These will be able to read
               AES-encrypted zip archives produced by DotNetZip, and conversely applications
               that use DotNetZip to read zip archives will be able to read AES-encrypted
               archives produced by those tools or libraries.  Consult the documentation for
               those other tools and libraries to find out if WinZip's AES encryption is
               supported.
             </para>
            
             <para>
               In case you care: According to <see
               href="http://www.winzip.com/aes_info.htm">the WinZip specification</see>, the
               actual AES key used is derived from the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Password"/> via an
               algorithm that complies with <see
               href="http://www.ietf.org/rfc/rfc2898.txt">RFC 2898</see>, using an iteration
               count of 1000.  The algorithm is sometimes referred to as PBKDF2, which stands
               for "Password Based Key Derivation Function #2".
             </para>
            
             <para>
               A word about password strength and length: The AES encryption technology is
               very good, but any system is only as secure as the weakest link.  If you want
               to secure your data, be sure to use a password that is hard to guess.  To make
               it harder to guess (increase its "entropy"), you should make it longer.  If
               you use normal characters from an ASCII keyboard, a password of length 20 will
               be strong enough that it will be impossible to guess.  For more information on
               that, I'd encourage you to read <see
               href="http://www.redkestrel.co.uk/Articles/RandomPasswordStrength.html">this
               article.</see>
             </para>
            
             <para>
               The WinZip AES algorithms are not supported with the version of DotNetZip that
               runs on the .NET Compact Framework.  This is because .NET CF lacks the
               HMACSHA1 class that is required for producing the archive.
             </para>
             </remarks>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.EncryptionAlgorithm.None">
            <summary>
            No encryption at all.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.EncryptionAlgorithm.PkzipWeak">
            <summary>
            Traditional or Classic pkzip encryption.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.EncryptionAlgorithm.Unsupported">
            <summary>
            An encryption algorithm that is not supported by DotNetZip.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.WriteDelegate">
             <summary>
               Delegate in which the application writes the <c>ZipEntry</c> content for the named entry.
             </summary>
            
             <param name="entryName">The name of the entry that must be written.</param>
             <param name="stream">The stream to which the entry data should be written.</param>
            
             <remarks>
               When you add an entry and specify a <c>WriteDelegate</c>, via <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,OfficeOpenXml.Packaging.Ionic.Zip.WriteDelegate)"/>, the application
               code provides the logic that writes the entry data directly into the zip file.
             </remarks>
            
             <example>
            
             This example shows how to define a WriteDelegate that obtains a DataSet, and then
             writes the XML for the DataSet into the zip archive.  There's no need to
             save the XML to a disk file first.
            
             <code lang="C#">
             private void WriteEntry (String filename, Stream output)
             {
                 DataSet ds1 = ObtainDataSet();
                 ds1.WriteXml(output);
             }
            
             private void Run()
             {
                 using (var zip = new ZipFile())
                 {
                     zip.AddEntry(zipEntryName, WriteEntry);
                     zip.Save(zipFileName);
                 }
             }
             </code>
            
             <code lang="vb">
             Private Sub WriteEntry (ByVal filename As String, ByVal output As Stream)
                 DataSet ds1 = ObtainDataSet()
                 ds1.WriteXml(stream)
             End Sub
            
             Public Sub Run()
                 Using zip = New ZipFile
                     zip.AddEntry(zipEntryName, New WriteDelegate(AddressOf WriteEntry))
                     zip.Save(zipFileName)
                 End Using
             End Sub
             </code>
             </example>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,OfficeOpenXml.Packaging.Ionic.Zip.WriteDelegate)"/>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.OpenDelegate">
             <summary>
               Delegate in which the application opens the stream, just-in-time, for the named entry.
             </summary>
            
             <param name="entryName">
             The name of the ZipEntry that the application should open the stream for.
             </param>
            
             <remarks>
               When you add an entry via <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,OfficeOpenXml.Packaging.Ionic.Zip.OpenDelegate,OfficeOpenXml.Packaging.Ionic.Zip.CloseDelegate)"/>, the application code provides the logic that
               opens and closes the stream for the given ZipEntry.
             </remarks>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,OfficeOpenXml.Packaging.Ionic.Zip.OpenDelegate,OfficeOpenXml.Packaging.Ionic.Zip.CloseDelegate)"/>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.CloseDelegate">
             <summary>
               Delegate in which the application closes the stream, just-in-time, for the named entry.
             </summary>
            
             <param name="entryName">
             The name of the ZipEntry that the application should close the stream for.
             </param>
            
             <param name="stream">The stream to be closed.</param>
            
             <remarks>
               When you add an entry via <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,OfficeOpenXml.Packaging.Ionic.Zip.OpenDelegate,OfficeOpenXml.Packaging.Ionic.Zip.CloseDelegate)"/>, the application code provides the logic that
               opens and closes the stream for the given ZipEntry.
             </remarks>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,OfficeOpenXml.Packaging.Ionic.Zip.OpenDelegate,OfficeOpenXml.Packaging.Ionic.Zip.CloseDelegate)"/>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.SetCompressionCallback">
             <summary>
               Delegate for the callback by which the application tells the
               library the CompressionLevel to use for a file.
             </summary>
            
             <remarks>
             <para>
               Using this callback, the application can, for example, specify that
               previously-compressed files (.mp3, .png, .docx, etc) should use a
               <c>CompressionLevel</c> of <c>None</c>, or can set the compression level based
               on any other factor.
             </para>
             </remarks>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType">
            <summary>
              In an EventArgs type, indicates which sort of progress event is being
              reported.
            </summary>
            <remarks>
              There are events for reading, events for saving, and events for
              extracting. This enumeration allows a single EventArgs type to be sued to
              describe one of multiple subevents. For example, a SaveProgress event is
              invoked before, after, and during the saving of a single entry.  The value
              of an enum with this type, specifies which event is being triggered.  The
              same applies to Extraction, Reading and Adding events.
            </remarks>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Adding_Started">
            <summary>
            Indicates that a Add() operation has started.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Adding_AfterAddEntry">
            <summary>
            Indicates that an individual entry in the archive has been added.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Adding_Completed">
            <summary>
            Indicates that a Add() operation has completed.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Reading_Started">
            <summary>
            Indicates that a Read() operation has started.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Reading_BeforeReadEntry">
            <summary>
            Indicates that an individual entry in the archive is about to be read.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Reading_AfterReadEntry">
            <summary>
            Indicates that an individual entry in the archive has just been read.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Reading_Completed">
            <summary>
            Indicates that a Read() operation has completed.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Reading_ArchiveBytesRead">
            <summary>
            The given event reports the number of bytes read so far
            during a Read() operation.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Saving_Started">
            <summary>
            Indicates that a Save() operation has started.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry">
            <summary>
            Indicates that an individual entry in the archive is about to be written.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry">
            <summary>
            Indicates that an individual entry in the archive has just been saved.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Saving_Completed">
            <summary>
            Indicates that a Save() operation has completed.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Saving_AfterSaveTempArchive">
            <summary>
            Indicates that the zip archive has been created in a
            temporary location during a Save() operation.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Saving_BeforeRenameTempArchive">
            <summary>
            Indicates that the temporary file is about to be renamed to the final archive
            name during a Save() operation.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Saving_AfterRenameTempArchive">
            <summary>
            Indicates that the temporary file is has just been renamed to the final archive
            name during a Save() operation.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Saving_AfterCompileSelfExtractor">
            <summary>
            Indicates that the self-extracting archive has been compiled
            during a Save() operation.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Saving_EntryBytesRead">
            <summary>
            The given event is reporting the number of source bytes that have run through the compressor so far
            during a Save() operation.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Extracting_BeforeExtractEntry">
            <summary>
            Indicates that an entry is about to be extracted.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Extracting_AfterExtractEntry">
            <summary>
            Indicates that an entry has just been extracted.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite">
            <summary>
              Indicates that extraction of an entry would overwrite an existing
              filesystem file. You must use
              <see cref="F:OfficeOpenXml.Packaging.Ionic.Zip.ExtractExistingFileAction.InvokeExtractProgressEvent">
              ExtractExistingFileAction.InvokeExtractProgressEvent</see> in the call
              to <c>ZipEntry.Extract()</c> in order to receive this event.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Extracting_EntryBytesWritten">
            <summary>
              The given event is reporting the number of bytes written so far for
              the current entry during an Extract() operation.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Extracting_BeforeExtractAll">
            <summary>
            Indicates that an ExtractAll operation is about to begin.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Extracting_AfterExtractAll">
            <summary>
            Indicates that an ExtractAll operation has completed.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Error_Saving">
            <summary>
            Indicates that an error has occurred while saving a zip file.
            This generally means the file cannot be opened, because it has been
            removed, or because it is locked by another process.  It can also
            mean that the file cannot be Read, because of a range lock conflict.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventArgs">
            <summary>
            Provides information about the progress of a save, read, or extract operation.
            This is a base class; you will probably use one of the classes derived from this one.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventArgs.EntriesTotal">
            <summary>
            The total number of entries to be saved or extracted.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventArgs.CurrentEntry">
            <summary>
            The name of the last entry saved or extracted.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventArgs.Cancel">
            <summary>
            In an event handler, set this to cancel the save or extract
            operation that is in progress.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventArgs.EventType">
            <summary>
            The type of event being reported.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventArgs.ArchiveName">
            <summary>
            Returns the archive name associated to this event.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventArgs.BytesTransferred">
            <summary>
            The number of bytes read or written so far for this entry.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventArgs.TotalBytesToTransfer">
            <summary>
            Total number of bytes that will be read or written for this entry.
            This number will be -1 if the value cannot be determined.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.ReadProgressEventArgs">
            <summary>
            Provides information about the progress of a Read operation.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.AddProgressEventArgs">
            <summary>
            Provides information about the progress of a Add operation.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.SaveProgressEventArgs">
            <summary>
            Provides information about the progress of a save operation.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.SaveProgressEventArgs.#ctor(System.String,System.Boolean,System.Int32,System.Int32,OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry)">
            <summary>
            Constructor for the SaveProgressEventArgs.
            </summary>
            <param name="archiveName">the name of the zip archive.</param>
            <param name="before">whether this is before saving the entry, or after</param>
            <param name="entriesTotal">The total number of entries in the zip archive.</param>
            <param name="entriesSaved">Number of entries that have been saved.</param>
            <param name="entry">The entry involved in the event.</param>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.SaveProgressEventArgs.EntriesSaved">
            <summary>
            Number of entries saved so far.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.ExtractProgressEventArgs">
            <summary>
            Provides information about the progress of the extract operation.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ExtractProgressEventArgs.#ctor(System.String,System.Boolean,System.Int32,System.Int32,OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry,System.String)">
            <summary>
            Constructor for the ExtractProgressEventArgs.
            </summary>
            <param name="archiveName">the name of the zip archive.</param>
            <param name="before">whether this is before saving the entry, or after</param>
            <param name="entriesTotal">The total number of entries in the zip archive.</param>
            <param name="entriesExtracted">Number of entries that have been extracted.</param>
            <param name="entry">The entry involved in the event.</param>
            <param name="extractLocation">The location to which entries are extracted.</param>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ExtractProgressEventArgs.EntriesExtracted">
            <summary>
            Number of entries extracted so far.  This is set only if the
            EventType is Extracting_BeforeExtractEntry or Extracting_AfterExtractEntry, and
            the Extract() is occurring witin the scope of a call to ExtractAll().
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ExtractProgressEventArgs.ExtractLocation">
            <summary>
            Returns the extraction target location, a filesystem path.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.ZipErrorEventArgs">
            <summary>
            Provides information about the an error that occurred while zipping.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipErrorEventArgs.Exception">
            <summary>
            Returns the exception that occurred, if any.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipErrorEventArgs.FileName">
            <summary>
            Returns the name of the file that caused the exception, if any.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.BadPasswordException">
            <summary>
            Issued when an <c>ZipEntry.ExtractWithPassword()</c> method is invoked
            with an incorrect password.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.BadPasswordException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.BadPasswordException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.BadPasswordException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.BadPasswordException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.BadReadException">
            <summary>
            Indicates that a read was attempted on a stream, and bad or incomplete data was
            received.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.BadReadException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.BadReadException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.BadReadException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.BadReadException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.BadCrcException">
            <summary>
            Issued when an CRC check fails upon extracting an entry from a zip archive.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.BadCrcException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.BadCrcException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.BadCrcException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.SfxGenerationException">
            <summary>
            Issued when errors occur saving a self-extracting archive.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.SfxGenerationException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.SfxGenerationException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.SfxGenerationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.BadStateException">
            <summary>
            Indicates that an operation was attempted on a ZipFile which was not possible
            given the state of the instance. For example, if you call <c>Save()</c> on a ZipFile
            which has no filename set, you can get this exception.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.BadStateException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.BadStateException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.BadStateException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.BadStateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.ZipException">
            <summary>
            Base class for all exceptions defined by and throw by the Zip library.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipException.#ctor">
            <summary>
            Default ctor.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipException.#ctor(System.String)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipException.#ctor(System.String,System.Exception)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="message">The message in the exception.</param>
            <param name="innerException">The innerException for this exception.</param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
            <param name="info">The serialization info for the exception.</param>
            <param name="context">The streaming context from which to deserialize.</param>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.ExtractExistingFileAction">
             <summary>
             An enum for the options when extracting an entry would overwrite an existing file. 
             </summary>
             
             <remarks>
               <para>
                 This enum describes the actions that the library can take when an
                 <c>Extract()</c> or <c>ExtractWithPassword()</c> method is called to extract an
                 entry to a filesystem, and the extraction would overwrite an existing filesystem
                 file.
               </para>
             </remarks>
            
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ExtractExistingFileAction.Throw">
            <summary>
            Throw an exception when extraction would overwrite an existing file. (For
            COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ExtractExistingFileAction.OverwriteSilently">
            <summary>
            When extraction would overwrite an existing file, overwrite the file silently.
            The overwrite will happen even if the target file is marked as read-only.
            (For COM clients, this is a 1.)
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ExtractExistingFileAction.DoNotOverwrite">
            <summary>
            When extraction would overwrite an existing file, don't overwrite the file, silently. 
            (For COM clients, this is a 2.)
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ExtractExistingFileAction.InvokeExtractProgressEvent">
            <summary>
            When extraction would overwrite an existing file, invoke the ExtractProgress
            event, using an event type of <see
            cref="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite"/>.  In
            this way, the application can decide, just-in-time, whether to overwrite the
            file. For example, a GUI application may wish to pop up a dialog to allow
            the user to choose. You may want to examine the <see
            cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ExtractProgressEventArgs.ExtractLocation"/> property before making
            the decision. If, after your processing in the Extract progress event, you
            want to NOT extract the file, set <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ExtractExistingFile"/>
            on the <c>ZipProgressEventArgs.CurrentEntry</c> to <c>DoNotOverwrite</c>.
            If you do want to extract the file, set <c>ZipEntry.ExtractExistingFile</c>
            to <c>OverwriteSilently</c>.  If you want to cancel the Extraction, set
            <c>ZipProgressEventArgs.Cancel</c> to true.  Cancelling differs from using
            DoNotOverwrite in that a cancel will not extract any further entries, if
            there are any.  (For COM clients, the value of this enum is a 3.)
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.SharedUtilities">
            <summary>
            Collects general purpose utility methods.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.SharedUtilities.GetFileLength(System.String)">
            private null constructor
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.SharedUtilities.NormalizePathForUseInZipFile(System.String)">
            <summary>
            Utility routine for transforming path names from filesystem format (on Windows that means backslashes) to
            a format suitable for use within zipfiles. This means trimming the volume letter and colon (if any) And
            swapping backslashes for forward slashes.
            </summary>
            <param name="pathName">source path.</param>
            <returns>transformed path</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.SharedUtilities.FindSignature(System.IO.Stream,System.Int32)">
             <summary>
               Finds a signature in the zip stream. This is useful for finding
               the end of a zip entry, for example, or the beginning of the next ZipEntry.
             </summary>
            
             <remarks>
               <para>
                 Scans through 64k at a time.
               </para>
            
               <para>
                 If the method fails to find the requested signature, the stream Position
                 after completion of this method is unchanged. If the method succeeds in
                 finding the requested signature, the stream position after completion is
                 direct AFTER the signature found in the stream.
               </para>
             </remarks>
            
             <param name="stream">The stream to search</param>
             <param name="SignatureToFind">The 4-byte signature to find</param>
             <returns>The number of bytes read</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.SharedUtilities.CreateAndOpenUniqueTempFile(System.String,System.IO.Stream@,System.String@)">
            <summary>
              Create a pseudo-random filename, suitable for use as a temporary
              file, and open it.
            </summary>
            <remarks>
            <para>
              The System.IO.Path.GetRandomFileName() method is not available on
              the Compact Framework, so this library provides its own substitute
              on NETCF.
            </para>
            <para>
              This method produces a filename of the form
              DotNetZip-xxxxxxxx.tmp, where xxxxxxxx is replaced by randomly
              chosen characters, and creates that file.
            </para>
            </remarks>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.SharedUtilities.ReadWithRetry(System.IO.Stream,System.Byte[],System.Int32,System.Int32,System.String)">
            <summary>
            Workitem 7889: handle ERROR_LOCK_VIOLATION during read
            </summary>
            <remarks>
            This could be gracefully handled with an extension attribute, but
            This assembly is built for .NET 2.0, so I cannot use them.
            </remarks>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.CountingStream">
            <summary>
              A decorator stream. It wraps another stream, and performs bookkeeping
              to keep track of the stream Position.
            </summary>
            <remarks>
              <para>
                In some cases, it is not possible to get the Position of a stream, let's
                say, on a write-only output stream like ASP.NET's
                <c>Response.OutputStream</c>, or on a different write-only stream
                provided as the destination for the zip by the application.  In this
                case, programmers can use this counting stream to count the bytes read
                or written.
              </para>
              <para>
                Consider the scenario of an application that saves a self-extracting
                archive (SFX), that uses a custom SFX stub.
              </para>
              <para>
                Saving to a filesystem file, the application would open the
                filesystem file (getting a <c>FileStream</c>), save the custom sfx stub
                into it, and then call <c>ZipFile.Save()</c>, specifying the same
                FileStream. <c>ZipFile.Save()</c> does the right thing for the zipentry
                offsets, by inquiring the Position of the <c>FileStream</c> before writing
                any data, and then adding that initial offset into any ZipEntry
                offsets in the zip directory. Everything works fine.
              </para>
              <para>
                Now suppose the application is an ASPNET application and it saves
                directly to <c>Response.OutputStream</c>. It's not possible for DotNetZip to
                inquire the <c>Position</c>, so the offsets for the SFX will be wrong.
              </para>
              <para>
                The workaround is for the application to use this class to wrap
                <c>HttpResponse.OutputStream</c>, then write the SFX stub and the ZipFile
                into that wrapper stream. Because <c>ZipFile.Save()</c> can inquire the
                <c>Position</c>, it will then do the right thing with the offsets.
              </para>
            </remarks>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.CountingStream.#ctor(System.IO.Stream)">
            <summary>
            The constructor.
            </summary>
            <param name="stream">The underlying stream</param>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.CountingStream.WrappedStream">
            <summary>
              Gets the wrapped stream.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.CountingStream.BytesWritten">
            <summary>
              The count of bytes written out to the stream.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.CountingStream.BytesRead">
            <summary>
              the count of bytes that have been read from the stream.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.CountingStream.Adjust(System.Int64)">
             <summary>
                Adjust the byte count on the stream.
             </summary>
            
             <param name='delta'>
               the number of bytes to subtract from the count.
             </param>
            
             <remarks>
               <para>
                 Subtract delta from the count of bytes written to the stream.
                 This is necessary when seeking back, and writing additional data,
                 as happens in some cases when saving Zip files.
               </para>
             </remarks>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.CountingStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
              The read method.
            </summary>
            <param name="buffer">The buffer to hold the data read from the stream.</param>
            <param name="offset">the offset within the buffer to copy the first byte read.</param>
            <param name="count">the number of bytes to read.</param>
            <returns>the number of bytes read, after decryption and decompression.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.CountingStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Write data into the stream.
            </summary>
            <param name="buffer">The buffer holding data to write to the stream.</param>
            <param name="offset">the offset within that data array to find the first byte to write.</param>
            <param name="count">the number of bytes to write.</param>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.CountingStream.CanRead">
            <summary>
              Whether the stream can be read.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.CountingStream.CanSeek">
            <summary>
              Whether it is possible to call Seek() on the stream.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.CountingStream.CanWrite">
            <summary>
              Whether it is possible to call Write() on the stream.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.CountingStream.Flush">
            <summary>
              Flushes the underlying stream.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.CountingStream.Length">
            <summary>
              The length of the underlying stream.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.CountingStream.ComputedPosition">
            <summary>
              Returns the sum of number of bytes written, plus the initial
              offset before writing.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.CountingStream.Position">
            <summary>
              The Position of the stream.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.CountingStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
              Seek in the stream.
            </summary>
            <param name="offset">the offset point to seek to</param>
            <param name="origin">the reference point from which to seek</param>
            <returns>The new position</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.CountingStream.SetLength(System.Int64)">
             <summary>
               Set the length of the underlying stream.  Be careful with this!
             </summary>
            
             <param name='value'>the length to set on the underlying stream.</param>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.ZipCrypto">
             <summary>
               This class implements the "traditional" or "classic" PKZip encryption,
               which today is considered to be weak. On the other hand it is
               ubiquitous. This class is intended for use only by the DotNetZip
               library.
             </summary>
            
             <remarks>
               Most uses of the DotNetZip library will not involve direct calls into
               the ZipCrypto class.  Instead, the ZipCrypto class is instantiated and
               used by the ZipEntry() class when encryption or decryption on an entry
               is employed.  If for some reason you really wanted to use a weak
               encryption algorithm in some other application, you might use this
               library.  But you would be much better off using one of the built-in
               strong encryption libraries in the .NET Framework, like the AES
               algorithm or SHA.
             </remarks>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipCrypto.#ctor">
             <summary>
               The default constructor for ZipCrypto.
             </summary>
            
             <remarks>
               This class is intended for internal use by the library only. It's
               probably not useful to you. Seriously.  Stop reading this
               documentation.  It's a waste of your time.  Go do something else.
               Check the football scores. Go get an ice cream with a friend.
               Seriously.
             </remarks>
            
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipCrypto.MagicByte">
            <summary>
            From AppNote.txt:
            unsigned char decrypt_byte()
                local unsigned short temp
                temp :=- Key(2) | 2
                decrypt_byte := (temp * (temp ^ 1)) bitshift-right 8
            end decrypt_byte
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipCrypto.DecryptMessage(System.Byte[],System.Int32)">
             <summary>
               Call this method on a cipher text to render the plaintext. You must
               first initialize the cipher with a call to InitCipher.
             </summary>
            
             <example>
               <code>
                 var cipher = new ZipCrypto();
                 cipher.InitCipher(Password);
                 // Decrypt the header.  This has a side effect of "further initializing the
                 // encryption keys" in the traditional zip encryption.
                 byte[] DecryptedMessage = cipher.DecryptMessage(EncryptedMessage);
               </code>
             </example>
            
             <param name="cipherText">The encrypted buffer.</param>
             <param name="length">
               The number of bytes to encrypt.
               Should be less than or equal to CipherText.Length.
             </param>
            
             <returns>The plaintext.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipCrypto.EncryptMessage(System.Byte[],System.Int32)">
             <summary>
               This is the converse of DecryptMessage.  It encrypts the plaintext
               and produces a ciphertext.
             </summary>
            
             <param name="plainText">The plain text buffer.</param>
            
             <param name="length">
               The number of bytes to encrypt.
               Should be less than or equal to plainText.Length.
             </param>
            
             <returns>The ciphertext.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipCrypto.InitCipher(System.String)">
             <summary>
               This initializes the cipher with the given password.
               See AppNote.txt for details.
             </summary>
            
             <param name="passphrase">
               The passphrase for encrypting or decrypting with this cipher.
             </param>
            
             <remarks>
             <code>
             Step 1 - Initializing the encryption keys
             -----------------------------------------
             Start with these keys:
             Key(0) := 305419896 (0x12345678)
             Key(1) := 591751049 (0x23456789)
             Key(2) := 878082192 (0x34567890)
            
             Then, initialize the keys with a password:
            
             loop for i from 0 to length(password)-1
                 update_keys(password(i))
             end loop
            
             Where update_keys() is defined as:
            
             update_keys(char):
               Key(0) := crc32(key(0),char)
               Key(1) := Key(1) + (Key(0) bitwiseAND 000000ffH)
               Key(1) := Key(1) * 134775813 + 1
               Key(2) := crc32(key(2),key(1) rightshift 24)
             end update_keys
            
             Where crc32(old_crc,char) is a routine that given a CRC value and a
             character, returns an updated CRC value after applying the CRC-32
             algorithm described elsewhere in this document.
            
             </code>
            
             <para>
               After the keys are initialized, then you can use the cipher to
               encrypt the plaintext.
             </para>
            
             <para>
               Essentially we encrypt the password with the keys, then discard the
               ciphertext for the password. This initializes the keys for later use.
             </para>
            
             </remarks>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.ZipCipherStream">
            <summary>
              A Stream for reading and concurrently decrypting data from a zip file,
              or for writing and concurrently encrypting data to a zip file.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipCipherStream.#ctor(System.IO.Stream,OfficeOpenXml.Packaging.Ionic.Zip.ZipCrypto,OfficeOpenXml.Packaging.Ionic.Zip.CryptoMode)">
            <summary>  The constructor. </summary>
            <param name="s">The underlying stream</param>
            <param name="mode">To either encrypt or decrypt.</param>
            <param name="cipher">The pre-initialized ZipCrypto object.</param>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry">
            <summary>
            Represents a single entry in a ZipFile. Typically, applications get a ZipEntry
            by enumerating the entries within a ZipFile, or by adding an entry to a ZipFile.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AttributesIndicateDirectory">
            <summary>
            True if the referenced entry is a directory.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Info">
            <summary>
            Provides a human-readable string with information about the ZipEntry.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ReadDirEntry(OfficeOpenXml.Packaging.Ionic.Zip.ZipFile,System.Collections.Generic.Dictionary{System.String,System.Object})">
             <summary>
               Reads one entry from the zip directory structure in the zip file.
             </summary>
            
             <param name="zf">
               The zipfile for which a directory entry will be read.  From this param, the
               method gets the ReadStream and the expected text encoding
               (ProvisionalAlternateEncoding) which is used if the entry is not marked
               UTF-8.
             </param>
            
             <param name="previouslySeen">
               a list of previously seen entry names; used to prevent duplicates.
             </param>
            
             <returns>the entry read from the archive.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.IsNotValidZipDirEntrySig(System.Int32)">
            <summary>
            Returns true if the passed-in value is a valid signature for a ZipDirEntry.
            </summary>
            <param name="signature">the candidate 4-byte signature value.</param>
            <returns>true, if the signature is valid according to the PKWare spec.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.#ctor">
            <summary>
            Default constructor.
            </summary>
            <remarks>
            Applications should never need to call this directly.  It is exposed to
            support COM Automation environments.
            </remarks>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.LastModified">
             <summary>
               The time and date at which the file indicated by the <c>ZipEntry</c> was
               last modified.
             </summary>
            
             <remarks>
             <para>
               The DotNetZip library sets the LastModified value for an entry, equal to
               the Last Modified time of the file in the filesystem.  If an entry is
               added from a stream, the library uses <c>System.DateTime.Now</c> for this
               value, for the given entry.
             </para>
            
             <para>
               This property allows the application to retrieve and possibly set the
               LastModified value on an entry, to an arbitrary value.  <see
               cref="T:System.DateTime"/> values with a <see cref="T:System.DateTimeKind" />
               setting of <c>DateTimeKind.Unspecified</c> are taken to be expressed as
               <c>DateTimeKind.Local</c>.
             </para>
            
             <para>
               Be aware that because of the way <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWare's
               Zip specification</see> describes how times are stored in the zip file,
               the full precision of the <c>System.DateTime</c> datatype is not stored
               for the last modified time when saving zip files.  For more information on
               how times are formatted, see the PKZip specification.
             </para>
            
             <para>
               The actual last modified time of a file can be stored in multiple ways in
               the zip file, and they are not mutually exclusive:
             </para>
            
             <list type="bullet">
               <item>
                 In the so-called "DOS" format, which has a 2-second precision. Values
                 are rounded to the nearest even second. For example, if the time on the
                 file is 12:34:43, then it will be stored as 12:34:44. This first value
                 is accessible via the <c>LastModified</c> property. This value is always
                 present in the metadata for each zip entry.  In some cases the value is
                 invalid, or zero.
               </item>
            
               <item>
                 In the so-called "Windows" or "NTFS" format, as an 8-byte integer
                 quantity expressed as the number of 1/10 milliseconds (in other words
                 the number of 100 nanosecond units) since January 1, 1601 (UTC).  This
                 format is how Windows represents file times.  This time is accessible
                 via the <c>ModifiedTime</c> property.
               </item>
            
               <item>
                 In the "Unix" format, a 4-byte quantity specifying the number of seconds since
                 January 1, 1970 UTC.
               </item>
            
               <item>
                 In an older format, now deprecated but still used by some current
                 tools. This format is also a 4-byte quantity specifying the number of
                 seconds since January 1, 1970 UTC.
               </item>
            
             </list>
            
             <para>
               Zip tools and libraries will always at least handle (read or write) the
               DOS time, and may also handle the other time formats.  Keep in mind that
               while the names refer to particular operating systems, there is nothing in
               the time formats themselves that prevents their use on other operating
               systems.
             </para>
            
             <para>
               When reading ZIP files, the DotNetZip library reads the Windows-formatted
               time, if it is stored in the entry, and sets both <c>LastModified</c> and
               <c>ModifiedTime</c> to that value. When writing ZIP files, the DotNetZip
               library by default will write both time quantities. It can also emit the
               Unix-formatted time if desired (See <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/>.)
             </para>
            
             <para>
               The last modified time of the file created upon a call to
               <c>ZipEntry.Extract()</c> may be adjusted during extraction to compensate
               for differences in how the .NET Base Class Library deals with daylight
               saving time (DST) versus how the Windows filesystem deals with daylight
               saving time.  Raymond Chen <see
               href="http://blogs.msdn.com/oldnewthing/archive/2003/10/24/55413.aspx">provides
               some good context</see>.
             </para>
            
             <para>
               In a nutshell: Daylight savings time rules change regularly.  In 2007, for
               example, the inception week of DST changed.  In 1977, DST was in place all
               year round. In 1945, likewise.  And so on.  Win32 does not attempt to
               guess which time zone rules were in effect at the time in question.  It
               will render a time as "standard time" and allow the app to change to DST
               as necessary.  .NET makes a different choice.
             </para>
            
             <para>
               Compare the output of FileInfo.LastWriteTime.ToString("f") with what you
               see in the Windows Explorer property sheet for a file that was last
               written to on the other side of the DST transition. For example, suppose
               the file was last modified on October 17, 2003, during DST but DST is not
               currently in effect. Explorer's file properties reports Thursday, October
               17, 2003, 8:45:38 AM, but .NETs FileInfo reports Thursday, October 17,
               2003, 9:45 AM.
             </para>
            
             <para>
               Win32 says, "Thursday, October 17, 2002 8:45:38 AM PST". Note: Pacific
               STANDARD Time. Even though October 17 of that year occurred during Pacific
               Daylight Time, Win32 displays the time as standard time because that's
               what time it is NOW.
             </para>
            
             <para>
               .NET BCL assumes that the current DST rules were in place at the time in
               question.  So, .NET says, "Well, if the rules in effect now were also in
               effect on October 17, 2003, then that would be daylight time" so it
               displays "Thursday, October 17, 2003, 9:45 AM PDT" - daylight time.
             </para>
            
             <para>
               So .NET gives a value which is more intuitively correct, but is also
               potentially incorrect, and which is not invertible. Win32 gives a value
               which is intuitively incorrect, but is strictly correct.
             </para>
            
             <para>
               Because of this funkiness, this library adds one hour to the LastModified
               time on the extracted file, if necessary.  That is to say, if the time in
               question had occurred in what the .NET Base Class Library assumed to be
               DST. This assumption may be wrong given the constantly changing DST rules,
               but it is the best we can do.
             </para>
            
             </remarks>
            
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ModifiedTime">
             <summary>
             Last Modified time for the file represented by the entry.
             </summary>
            
             <remarks>
            
             <para>
               This value corresponds to the "last modified" time in the NTFS file times
               as described in <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</see>.  When getting this property, the value may be
               different from <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.LastModified" />.  When setting the property,
               the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.LastModified"/> property also gets set, but with a lower
               precision.
             </para>
            
             <para>
               Let me explain. It's going to take a while, so get
               comfortable. Originally, waaaaay back in 1989 when the ZIP specification
               was originally described by the esteemed Mr. Phil Katz, the dominant
               operating system of the time was MS-DOS. MSDOS stored file times with a
               2-second precision, because, c'mon, <em>who is ever going to need better
               resolution than THAT?</em> And so ZIP files, regardless of the platform on
               which the zip file was created, store file times in exactly <see
               href="http://www.vsft.com/hal/dostime.htm">the same format that DOS used
               in 1989</see>.
             </para>
            
             <para>
               Since then, the ZIP spec has evolved, but the internal format for file
               timestamps remains the same.  Despite the fact that the way times are
               stored in a zip file is rooted in DOS heritage, any program on any
               operating system can format a time in this way, and most zip tools and
               libraries DO - they round file times to the nearest even second and store
               it just like DOS did 25+ years ago.
             </para>
            
             <para>
               PKWare extended the ZIP specification to allow a zip file to store what
               are called "NTFS Times" and "Unix(tm) times" for a file.  These are the
               <em>last write</em>, <em>last access</em>, and <em>file creation</em>
               times of a particular file. These metadata are not actually specific
               to NTFS or Unix. They are tracked for each file by NTFS and by various
               Unix filesystems, but they are also tracked by other filesystems, too.
               The key point is that the times are <em>formatted in the zip file</em>
               in the same way that NTFS formats the time (ticks since win32 epoch),
               or in the same way that Unix formats the time (seconds since Unix
               epoch). As with the DOS time, any tool or library running on any
               operating system is capable of formatting a time in one of these ways
               and embedding it into the zip file.
             </para>
            
             <para>
               These extended times are higher precision quantities than the DOS time.
               As described above, the (DOS) LastModified has a precision of 2 seconds.
               The Unix time is stored with a precision of 1 second. The NTFS time is
               stored with a precision of 0.0000001 seconds. The quantities are easily
               convertible, except for the loss of precision you may incur.
             </para>
            
             <para>
               A zip archive can store the {C,A,M} times in NTFS format, in Unix format,
               or not at all.  Often a tool running on Unix or Mac will embed the times
               in Unix format (1 second precision), while WinZip running on Windows might
               embed the times in NTFS format (precision of of 0.0000001 seconds).  When
               reading a zip file with these "extended" times, in either format,
               DotNetZip represents the values with the
               <c>ModifiedTime</c>, <c>AccessedTime</c> and <c>CreationTime</c>
               properties on the <c>ZipEntry</c>.
             </para>
            
             <para>
               While any zip application or library, regardless of the platform it
               runs on, could use any of the time formats allowed by the ZIP
               specification, not all zip tools or libraries do support all these
               formats.  Storing the higher-precision times for each entry is
               optional for zip files, and many tools and libraries don't use the
               higher precision quantities at all. The old DOS time, represented by
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.LastModified"/>, is guaranteed to be present, though it
               sometimes unset.
             </para>
            
             <para>
               Ok, getting back to the question about how the <c>LastModified</c>
               property relates to this <c>ModifiedTime</c>
               property... <c>LastModified</c> is always set, while
               <c>ModifiedTime</c> is not. (The other times stored in the <em>NTFS
               times extension</em>, <c>CreationTime</c> and <c>AccessedTime</c> also
               may not be set on an entry that is read from an existing zip file.)
               When reading a zip file, then <c>LastModified</c> takes the DOS time
               that is stored with the file. If the DOS time has been stored as zero
               in the zipfile, then this library will use <c>DateTime.Now</c> for the
               <c>LastModified</c> value.  If the ZIP file was created by an evolved
               tool, then there will also be higher precision NTFS or Unix times in
               the zip file.  In that case, this library will read those times, and
               set <c>LastModified</c> and <c>ModifiedTime</c> to the same value, the
               one corresponding to the last write time of the file.  If there are no
               higher precision times stored for the entry, then <c>ModifiedTime</c>
               remains unset (likewise <c>AccessedTime</c> and <c>CreationTime</c>),
               and <c>LastModified</c> keeps its DOS time.
             </para>
            
             <para>
               When creating zip files with this library, by default the extended time
               properties (<c>ModifiedTime</c>, <c>AccessedTime</c>, and
               <c>CreationTime</c>) are set on the ZipEntry instance, and these data are
               stored in the zip archive for each entry, in NTFS format. If you add an
               entry from an actual filesystem file, then the entry gets the actual file
               times for that file, to NTFS-level precision.  If you add an entry from a
               stream, or a string, then the times get the value <c>DateTime.Now</c>.  In
               this case <c>LastModified</c> and <c>ModifiedTime</c> will be identical,
               to 2 seconds of precision.  You can explicitly set the
               <c>CreationTime</c>, <c>AccessedTime</c>, and <c>ModifiedTime</c> of an
               entry using the property setters.  If you want to set all of those
               quantities, it's more efficient to use the <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/> method.  Those
               changes are not made permanent in the zip file until you call <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Save"/> or one of its cousins.
             </para>
            
             <para>
               When creating a zip file, you can override the default behavior of
               this library for formatting times in the zip file, disabling the
               embedding of file times in NTFS format or enabling the storage of file
               times in Unix format, or both.  You may want to do this, for example,
               when creating a zip file on Windows, that will be consumed on a Mac,
               by an application that is not hip to the "NTFS times" format. To do
               this, use the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/> and
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/> properties.  A valid zip
               file may store the file times in both formats.  But, there are no
               guarantees that a program running on Mac or Linux will gracefully
               handle the NTFS-formatted times when Unix times are present, or that a
               non-DotNetZip-powered application running on Windows will be able to
               handle file times in Unix format. DotNetZip will always do something
               reasonable; other libraries or tools may not. When in doubt, test.
             </para>
            
             <para>
               I'll bet you didn't think one person could type so much about time, eh?
               And reading it was so enjoyable, too!  Well, in appreciation, <see
               href="http://cheeso.members.winisp.net/DotNetZipDonate.aspx">maybe you
               should donate</see>?
             </para>
             </remarks>
            
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.CreationTime"/>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.LastModified"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AccessedTime">
            <summary>
            Last Access time for the file represented by the entry.
            </summary>
            <remarks>
            This value may or may not be meaningful.  If the <c>ZipEntry</c> was read from an existing
            Zip archive, this information may not be available. For an explanation of why, see
            <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ModifiedTime"/>.
            </remarks>
            <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ModifiedTime"/>
            <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.CreationTime"/>
            <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.CreationTime">
             <summary>
             The file creation time for the file represented by the entry.
             </summary>
            
             <remarks>
             This value may or may not be meaningful.  If the <c>ZipEntry</c> was read
             from an existing zip archive, and the creation time was not set on the entry
             when the zip file was created, then this property may be meaningless. For an
             explanation of why, see <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ModifiedTime"/>.
             </remarks>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ModifiedTime"/>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)">
             <summary>
               Sets the NTFS Creation, Access, and Modified times for the given entry.
             </summary>
            
             <remarks>
             <para>
               When adding an entry from a file or directory, the Creation, Access, and
               Modified times for the given entry are automatically set from the
               filesystem values. When adding an entry from a stream or string, the
               values are implicitly set to DateTime.Now.  The application may wish to
               set these values to some arbitrary value, before saving the archive, and
               can do so using the various setters.  If you want to set all of the times,
               this method is more efficient.
             </para>
            
             <para>
               The values you set here will be retrievable with the <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ModifiedTime"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.CreationTime"/> and <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AccessedTime"/> properties.
             </para>
            
             <para>
               When this method is called, if both <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/> and <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/> are false, then the
               <c>EmitTimesInWindowsFormatWhenSaving</c> flag is automatically set.
             </para>
            
             <para>
               DateTime values provided here without a DateTimeKind are assumed to be Local Time.
             </para>
            
             </remarks>
             <param name="created">the creation time of the entry.</param>
             <param name="accessed">the last access time of the entry.</param>
             <param name="modified">the last modified time of the entry.</param>
            
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving" />
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving" />
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.CreationTime"/>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ModifiedTime"/>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving">
             <summary>
               Specifies whether the Creation, Access, and Modified times for the given
               entry will be emitted in "Windows format" when the zip archive is saved.
             </summary>
            
             <remarks>
             <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entry should or should not be stored
               in the zip archive in the format used by Windows. The default value of
               this property is <c>true</c>.
             </para>
            
             <para>
               When adding an entry from a file or directory, the Creation (<see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.CreationTime"/>), Access (<see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AccessedTime"/>), and Modified
               (<see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ModifiedTime"/>) times for the given entry are automatically
               set from the filesystem values. When adding an entry from a stream or
               string, all three values are implicitly set to DateTime.Now.  Applications
               can also explicitly set those times by calling <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)" />.
             </para>
            
             <para>
               <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since Jan 1, 1601 UTC.  The other is a format Unix applications typically
               use: seconds since January 1, 1970 UTC.  Each format can be stored in an
               "extra field" in the zip entry when saving the zip archive. The former
               uses an extra field with a Header Id of 0x000A, while the latter uses a
               header ID of 0x5455.
             </para>
            
             <para>
               Not all zip tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe the <see href="http://www.info-zip.org/">Infozip</see>
               tools can read the Unix format timestamps. Although the time values are
               easily convertible, subject to a loss of precision, some tools and
               libraries may be able to read only one or the other. DotNetZip can read or
               write times in either or both formats.
             </para>
            
             <para>
               The times stored are taken from <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ModifiedTime"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AccessedTime"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.CreationTime"/>.
             </para>
            
             <para>
               This property is not mutually exclusive from the <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/> property.  It is
               possible that a zip entry can embed the timestamps in both forms, one
               form, or neither.  But, there are no guarantees that a program running on
               Mac or Linux will gracefully handle NTFS Formatted times, or that a
               non-DotNetZip-powered application running on Windows will be able to
               handle file times in Unix format. When in doubt, test.
             </para>
            
             <para>
               Normally you will use the <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.EmitTimesInWindowsFormatWhenSaving">ZipFile.EmitTimesInWindowsFormatWhenSaving</see>
               property, to specify the behavior for all entries in a zip, rather than
               the property on each individual entry.
             </para>
            
             </remarks>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.CreationTime"/>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ModifiedTime"/>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving">
             <summary>
               Specifies whether the Creation, Access, and Modified times for the given
               entry will be emitted in &quot;Unix(tm) format&quot; when the zip archive is saved.
             </summary>
            
             <remarks>
             <para>
               An application creating a zip archive can use this flag to explicitly
               specify that the file times for the entry should or should not be stored
               in the zip archive in the format used by Unix. By default this flag is
               <c>false</c>, meaning the Unix-format times are not stored in the zip
               archive.
             </para>
            
             <para>
               When adding an entry from a file or directory, the Creation (<see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.CreationTime"/>), Access (<see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AccessedTime"/>), and Modified
               (<see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ModifiedTime"/>) times for the given entry are automatically
               set from the filesystem values. When adding an entry from a stream or
               string, all three values are implicitly set to DateTime.Now.  Applications
               can also explicitly set those times by calling <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>.
             </para>
            
             <para>
               <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see> describes multiple ways to format these times in a
               zip file. One is the format Windows applications normally use: 100ns ticks
               since Jan 1, 1601 UTC.  The other is a format Unix applications typically
               use: seconds since Jan 1, 1970 UTC.  Each format can be stored in an
               "extra field" in the zip entry when saving the zip archive. The former
               uses an extra field with a Header Id of 0x000A, while the latter uses a
               header ID of 0x5455.
             </para>
            
             <para>
               Not all tools and libraries can interpret these fields.  Windows
               compressed folders is one that can read the Windows Format timestamps,
               while I believe the <see href="http://www.info-zip.org/">Infozip</see>
               tools can read the Unix format timestamps. Although the time values are
               easily convertible, subject to a loss of precision, some tools and
               libraries may be able to read only one or the other. DotNetZip can read or
               write times in either or both formats.
             </para>
            
             <para>
               The times stored are taken from <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ModifiedTime"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AccessedTime"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.CreationTime"/>.
             </para>
            
             <para>
               This property is not mutually exclusive from the <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/> property.  It is
               possible that a zip entry can embed the timestamps in both forms, one
               form, or neither.  But, there are no guarantees that a program running on
               Mac or Linux will gracefully handle NTFS Formatted times, or that a
               non-DotNetZip-powered application running on Windows will be able to
               handle file times in Unix format. When in doubt, test.
             </para>
            
             <para>
               Normally you will use the <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving">ZipFile.EmitTimesInUnixFormatWhenSaving</see>
               property, to specify the behavior for all entries, rather than the
               property on each individual entry.
             </para>
             </remarks>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.SetEntryTimes(System.DateTime,System.DateTime,System.DateTime)"/>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.EmitTimesInUnixFormatWhenSaving"/>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.CreationTime"/>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AccessedTime"/>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ModifiedTime"/>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Timestamp">
             <summary>
             The type of timestamp attached to the ZipEntry.
             </summary>
            
             <remarks>
             This property is valid only for a ZipEntry that was read from a zip archive.
             It indicates the type of timestamp attached to the entry.
             </remarks>
            
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.EmitTimesInWindowsFormatWhenSaving"/>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.EmitTimesInUnixFormatWhenSaving"/>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Attributes">
             <summary>
               The file attributes for the entry.
             </summary>
            
             <remarks>
            
             <para>
               The <see cref="T:System.IO.FileAttributes">attributes</see> in NTFS include
               ReadOnly, Archive, Hidden, System, and Indexed.  When adding a
               <c>ZipEntry</c> to a ZipFile, these attributes are set implicitly when
               adding an entry from the filesystem.  When adding an entry from a stream
               or string, the Attributes are not set implicitly.  Regardless of the way
               an entry was added to a <c>ZipFile</c>, you can set the attributes
               explicitly if you like.
             </para>
            
             <para>
               When reading a <c>ZipEntry</c> from a <c>ZipFile</c>, the attributes are
               set according to the data stored in the <c>ZipFile</c>. If you extract the
               entry from the archive to a filesystem file, DotNetZip will set the
               attributes on the resulting file accordingly.
             </para>
            
             <para>
               The attributes can be set explicitly by the application.  For example the
               application may wish to set the <c>FileAttributes.ReadOnly</c> bit for all
               entries added to an archive, so that on unpack, this attribute will be set
               on the extracted file.  Any changes you make to this property are made
               permanent only when you call a <c>Save()</c> method on the <c>ZipFile</c>
               instance that contains the ZipEntry.
             </para>
            
             <para>
               For example, an application may wish to zip up a directory and set the
               ReadOnly bit on every file in the archive, so that upon later extraction,
               the resulting files will be marked as ReadOnly.  Not every extraction tool
               respects these attributes, but if you unpack with DotNetZip, as for
               example in a self-extracting archive, then the attributes will be set as
               they are stored in the <c>ZipFile</c>.
             </para>
            
             <para>
               These attributes may not be interesting or useful if the resulting archive
               is extracted on a non-Windows platform.  How these attributes get used
               upon extraction depends on the platform and tool used.
             </para>
            
             <para>
               This property is only partially supported in the Silverlight version
               of the library: applications can read attributes on entries within
               ZipFiles. But extracting entries within Silverlight will not set the
               attributes on the extracted files.
             </para>
            
             </remarks>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.LocalFileName">
             <summary>
               The name of the filesystem file, referred to by the ZipEntry.
             </summary>
            
             <remarks>
              <para>
                This property specifies the thing-to-be-zipped on disk, and is set only
                when the <c>ZipEntry</c> is being created from a filesystem file.  If the
                <c>ZipFile</c> is instantiated by reading an existing .zip archive, then
                the LocalFileName will be <c>null</c> (<c>Nothing</c> in VB).
              </para>
            
              <para>
                When it is set, the value of this property may be different than <see
                cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.FileName"/>, which is the path used in the archive itself.  If you
                call <c>Zip.AddFile("foop.txt", AlternativeDirectory)</c>, then the path
                used for the <c>ZipEntry</c> within the zip archive will be different
                than this path.
              </para>
            
              <para>
               If the entry is being added from a stream, then this is null (Nothing in VB).
              </para>
            
             </remarks>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.FileName"/>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.FileName">
             <summary>
               The name of the file contained in the ZipEntry.
             </summary>
            
             <remarks>
            
             <para>
               This is the name of the entry in the <c>ZipFile</c> itself.  When creating
               a zip archive, if the <c>ZipEntry</c> has been created from a filesystem
               file, via a call to <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddFile(System.String,System.String)"/> or <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddItem(System.String,System.String)"/>, or a related overload, the value
               of this property is derived from the name of that file. The
               <c>FileName</c> property does not include drive letters, and may include a
               different directory path, depending on the value of the
               <c>directoryPathInArchive</c> parameter used when adding the entry into
               the <c>ZipFile</c>.
             </para>
            
             <para>
               In some cases there is no related filesystem file - for example when a
               <c>ZipEntry</c> is created using <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,System.String)"/> or one of the similar overloads.  In this case, the value of
               this property is derived from the fileName and the directory path passed
               to that method.
             </para>
            
             <para>
               When reading a zip file, this property takes the value of the entry name
               as stored in the zip file. If you extract such an entry, the extracted
               file will take the name given by this property.
             </para>
            
             <para>
               Applications can set this property when creating new zip archives or when
               reading existing archives. When setting this property, the actual value
               that is set will replace backslashes with forward slashes, in accordance
               with <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</see>, for compatibility with Unix(tm) and ... get
               this.... Amiga!
             </para>
            
             <para>
               If an application reads a <c>ZipFile</c> via <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Read(System.String)"/> or a related overload, and then explicitly
               sets the FileName on an entry contained within the <c>ZipFile</c>, and
               then calls <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Save"/>, the application will effectively
               rename the entry within the zip archive.
             </para>
            
             <para>
               If an application sets the value of <c>FileName</c>, then calls
               <c>Extract()</c> on the entry, the entry is extracted to a file using the
               newly set value as the filename.  The <c>FileName</c> value is made
               permanent in the zip archive only <em>after</em> a call to one of the
               <c>ZipFile.Save()</c> methods on the <c>ZipFile</c> that contains the
               ZipEntry.
             </para>
            
             <para>
               If an application attempts to set the <c>FileName</c> to a value that
               would result in a duplicate entry in the <c>ZipFile</c>, an exception is
               thrown.
             </para>
            
             <para>
               When a <c>ZipEntry</c> is contained within a <c>ZipFile</c>, applications
               cannot rename the entry within the context of a <c>foreach</c> (<c>For
               Each</c> in VB) loop, because of the way the <c>ZipFile</c> stores
               entries.  If you need to enumerate through all the entries and rename one
               or more of them, use <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.EntriesSorted">ZipFile.EntriesSorted</see> as the
               collection.  See also, <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.GetEnumerator">ZipFile.GetEnumerator()</see>.
             </para>
            
             </remarks>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.InputStream">
             <summary>
             The stream that provides content for the ZipEntry.
             </summary>
            
             <remarks>
            
             <para>
               The application can use this property to set the input stream for an
               entry on a just-in-time basis. Imagine a scenario where the application
               creates a <c>ZipFile</c> comprised of content obtained from hundreds of
               files, via calls to <c>AddFile()</c>. The DotNetZip library opens streams
               on these files on a just-in-time basis, only when writing the entry out to
               an external store within the scope of a <c>ZipFile.Save()</c> call.  Only
               one input stream is opened at a time, as each entry is being written out.
             </para>
            
             <para>
               Now imagine a different application that creates a <c>ZipFile</c>
               with content obtained from hundreds of streams, added through <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)"/>.  Normally the
               application would supply an open stream to that call.  But when large
               numbers of streams are being added, this can mean many open streams at one
               time, unnecessarily.
             </para>
            
             <para>
               To avoid this, call <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,OfficeOpenXml.Packaging.Ionic.Zip.OpenDelegate,OfficeOpenXml.Packaging.Ionic.Zip.CloseDelegate)"/> and specify delegates that open and close the stream at
               the time of Save.
             </para>
            
            
             <para>
               Setting the value of this property when the entry was not added from a
               stream (for example, when the <c>ZipEntry</c> was added with <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddFile(System.String)"/> or <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddDirectory(System.String)"/>, or when the entry was added by
               reading an existing zip archive) will throw an exception.
             </para>
            
             </remarks>
            
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.InputStreamWasJitProvided">
             <summary>
               A flag indicating whether the InputStream was provided Just-in-time.
             </summary>
            
             <remarks>
            
             <para>
               When creating a zip archive, an application can obtain content for one or
               more of the <c>ZipEntry</c> instances from streams, using the <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)"/> method.  At the time
               of calling that method, the application can supply null as the value of
               the stream parameter.  By doing so, the application indicates to the
               library that it will provide a stream for the entry on a just-in-time
               basis, at the time one of the <c>ZipFile.Save()</c> methods is called and
               the data for the various entries are being compressed and written out.
             </para>
            
             <para>
               In this case, the application can set the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.InputStream"/>
               property, typically within the SaveProgress event (event type: <see
               cref="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry"/>) for that entry.
             </para>
            
             <para>
               The application will later want to call Close() and Dispose() on that
               stream.  In the SaveProgress event, when the event type is <see
               cref="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry"/>, the application can
               do so.  This flag indicates that the stream has been provided by the
               application on a just-in-time basis and that it is the application's
               responsibility to call Close/Dispose on that stream.
             </para>
            
             </remarks>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.InputStream"/>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Source">
            <summary>
            An enum indicating the source of the ZipEntry.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.VersionNeeded">
             <summary>
             The version of the zip engine needed to read the ZipEntry.
             </summary>
            
             <remarks>
             <para>
               This is a readonly property, indicating the version of <a
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</a> that the extracting tool or library must support to
               extract the given entry.  Generally higher versions indicate newer
               features.  Older zip engines obviously won't know about new features, and
               won't be able to extract entries that depend on those newer features.
             </para>
            
             <list type="table">
             <listheader>
             <term>value</term>
             <description>Features</description>
             </listheader>
            
             <item>
             <term>20</term>
             <description>a basic Zip Entry, potentially using PKZIP encryption.
             </description>
             </item>
            
             <item>
             <term>45</term>
             <description>The ZIP64 extension is used on the entry.
             </description>
             </item>
            
             <item>
             <term>46</term>
             <description> File is compressed using BZIP2 compression*</description>
             </item>
            
             <item>
             <term>50</term>
             <description> File is encrypted using PkWare's DES, 3DES, (broken) RC2 or RC4</description>
             </item>
            
             <item>
             <term>51</term>
             <description> File is encrypted using PKWare's AES encryption or corrected RC2 encryption.</description>
             </item>
            
             <item>
             <term>52</term>
             <description> File is encrypted using corrected RC2-64 encryption**</description>
             </item>
            
             <item>
             <term>61</term>
             <description> File is encrypted using non-OAEP key wrapping***</description>
             </item>
            
             <item>
             <term>63</term>
             <description> File is compressed using LZMA, PPMd+, Blowfish, or Twofish</description>
             </item>
            
             </list>
            
             <para>
               There are other values possible, not listed here. DotNetZip supports
               regular PKZip encryption, and ZIP64 extensions.  DotNetZip cannot extract
               entries that require a zip engine higher than 45.
             </para>
            
             <para>
               This value is set upon reading an existing zip file, or after saving a zip
               archive.
             </para>
             </remarks>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Comment">
             <summary>
             The comment attached to the ZipEntry.
             </summary>
            
             <remarks>
             <para>
               Each entry in a zip file can optionally have a comment associated to
               it. The comment might be displayed by a zip tool during extraction, for
               example.
             </para>
            
             <para>
               By default, the <c>Comment</c> is encoded in IBM437 code page. You can
               specify an alternative with <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AlternateEncoding"/> and
              <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AlternateEncodingUsage"/>.
             </para>
             </remarks>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AlternateEncoding"/>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AlternateEncodingUsage"/>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.RequiresZip64">
             <summary>
             Indicates whether the entry requires ZIP64 extensions.
             </summary>
            
             <remarks>
            
             <para>
               This property is null (Nothing in VB) until a <c>Save()</c> method on the
               containing <see cref="T:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile"/> instance has been called. The property is
               non-null (<c>HasValue</c> is true) only after a <c>Save()</c> method has
               been called.
             </para>
            
             <para>
               After the containing <c>ZipFile</c> has been saved, the Value of this
               property is true if any of the following three conditions holds: the
               uncompressed size of the entry is larger than 0xFFFFFFFF; the compressed
               size of the entry is larger than 0xFFFFFFFF; the relative offset of the
               entry within the zip archive is larger than 0xFFFFFFFF.  These quantities
               are not known until a <c>Save()</c> is attempted on the zip archive and
               the compression is applied.
             </para>
            
             <para>
               If none of the three conditions holds, then the <c>Value</c> is false.
             </para>
            
             <para>
               A <c>Value</c> of false does not indicate that the entry, as saved in the
               zip archive, does not use ZIP64.  It merely indicates that ZIP64 is
               <em>not required</em>.  An entry may use ZIP64 even when not required if
               the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property on the containing
               <c>ZipFile</c> instance is set to <see cref="F:OfficeOpenXml.Packaging.Ionic.Zip.Zip64Option.Always"/>, or if
               the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UseZip64WhenSaving"/> property on the containing
               <c>ZipFile</c> instance is set to <see cref="F:OfficeOpenXml.Packaging.Ionic.Zip.Zip64Option.AsNecessary"/>
               and the output stream was not seekable.
             </para>
            
             </remarks>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.OutputUsedZip64"/>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.OutputUsedZip64">
             <summary>
               Indicates whether the entry actually used ZIP64 extensions, as it was most
               recently written to the output file or stream.
             </summary>
            
             <remarks>
            
             <para>
               This Nullable property is null (Nothing in VB) until a <c>Save()</c>
               method on the containing <see cref="T:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile"/> instance has been
               called. <c>HasValue</c> is true only after a <c>Save()</c> method has been
               called.
             </para>
            
             <para>
               The value of this property for a particular <c>ZipEntry</c> may change
               over successive calls to <c>Save()</c> methods on the containing ZipFile,
               even if the file that corresponds to the <c>ZipEntry</c> does not. This
               may happen if other entries contained in the <c>ZipFile</c> expand,
               causing the offset for this particular entry to exceed 0xFFFFFFFF.
             </para>
             </remarks>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.RequiresZip64"/>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.BitField">
             <summary>
               The bitfield for the entry as defined in the zip spec. You probably
               never need to look at this.
             </summary>
            
             <remarks>
             <para>
               You probably do not need to concern yourself with the contents of this
               property, but in case you do:
             </para>
            
             <list type="table">
             <listheader>
             <term>bit</term>
             <description>meaning</description>
             </listheader>
            
             <item>
             <term>0</term>
             <description>set if encryption is used.</description>
             </item>
            
             <item>
             <term>1-2</term>
             <description>
             set to determine whether normal, max, fast deflation.  DotNetZip library
             always leaves these bits unset when writing (indicating "normal"
             deflation"), but can read an entry with any value here.
             </description>
             </item>
            
             <item>
             <term>3</term>
             <description>
             Indicates that the Crc32, Compressed and Uncompressed sizes are zero in the
             local header.  This bit gets set on an entry during writing a zip file, when
             it is saved to a non-seekable output stream.
             </description>
             </item>
            
            
             <item>
             <term>4</term>
             <description>reserved for "enhanced deflating". This library doesn't do enhanced deflating.</description>
             </item>
            
             <item>
             <term>5</term>
             <description>set to indicate the zip is compressed patched data.  This library doesn't do that.</description>
             </item>
            
             <item>
             <term>6</term>
             <description>
             set if PKWare's strong encryption is used (must also set bit 1 if bit 6 is
             set). This bit is not set if WinZip's AES encryption is set.</description>
             </item>
            
             <item>
             <term>7</term>
             <description>not used</description>
             </item>
            
             <item>
             <term>8</term>
             <description>not used</description>
             </item>
            
             <item>
             <term>9</term>
             <description>not used</description>
             </item>
            
             <item>
             <term>10</term>
             <description>not used</description>
             </item>
            
             <item>
             <term>11</term>
             <description>
             Language encoding flag (EFS).  If this bit is set, the filename and comment
             fields for this file must be encoded using UTF-8. This library currently
             does not support UTF-8.
             </description>
             </item>
            
             <item>
             <term>12</term>
             <description>Reserved by PKWARE for enhanced compression.</description>
             </item>
            
             <item>
             <term>13</term>
             <description>
               Used when encrypting the Central Directory to indicate selected data
               values in the Local Header are masked to hide their actual values.  See
               the section in <a
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</a> describing the Strong Encryption Specification for
               details.
             </description>
             </item>
            
             <item>
             <term>14</term>
             <description>Reserved by PKWARE.</description>
             </item>
            
             <item>
             <term>15</term>
             <description>Reserved by PKWARE.</description>
             </item>
            
             </list>
            
             </remarks>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.CompressionMethod">
             <summary>
               The compression method employed for this ZipEntry.
             </summary>
            
             <remarks>
            
             <para>
               <see href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">The
               Zip specification</see> allows a variety of compression methods.  This
               library supports just two: 0x08 = Deflate.  0x00 = Store (no compression),
               for reading or writing.
             </para>
            
             <para>
               When reading an entry from an existing zipfile, the value you retrieve
               here indicates the compression method used on the entry by the original
               creator of the zip.  When writing a zipfile, you can specify either 0x08
               (Deflate) or 0x00 (None).  If you try setting something else, you will get
               an exception.
             </para>
            
             <para>
               You may wish to set <c>CompressionMethod</c> to <c>CompressionMethod.None</c> (0)
               when zipping already-compressed data like a jpg, png, or mp3 file.
               This can save time and cpu cycles.
             </para>
            
             <para>
               When setting this property on a <c>ZipEntry</c> that is read from an
               existing zip file, calling <c>ZipFile.Save()</c> will cause the new
               CompressionMethod to be used on the entry in the newly saved zip file.
             </para>
            
             <para>
               Setting this property may have the side effect of modifying the
               <c>CompressionLevel</c> property. If you set the <c>CompressionMethod</c> to a
               value other than <c>None</c>, and <c>CompressionLevel</c> is previously
               set to <c>None</c>, then <c>CompressionLevel</c> will be set to
               <c>Default</c>.
             </para>
             </remarks>
            
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.CompressionMethod"/>
            
             <example>
               In this example, the first entry added to the zip archive uses the default
               behavior - compression is used where it makes sense.  The second entry,
               the MP3 file, is added to the archive without being compressed.
             <code>
             using (ZipFile zip = new ZipFile(ZipFileToCreate))
             {
               ZipEntry e1= zip.AddFile(@"notes\Readme.txt");
               ZipEntry e2= zip.AddFile(@"music\StopThisTrain.mp3");
               e2.CompressionMethod = CompressionMethod.None;
               zip.Save();
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile(ZipFileToCreate)
               zip.AddFile("notes\Readme.txt")
               Dim e2 as ZipEntry = zip.AddFile("music\StopThisTrain.mp3")
               e2.CompressionMethod = CompressionMethod.None
               zip.Save
             End Using
             </code>
             </example>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.CompressionLevel">
             <summary>
               Sets the compression level to be used for the entry when saving the zip
               archive. This applies only for CompressionMethod = DEFLATE.
             </summary>
            
             <remarks>
              <para>
                When using the DEFLATE compression method, Varying the compression
                level used on entries can affect the size-vs-speed tradeoff when
                compression and decompressing data streams or files.
              </para>
            
              <para>
                If you do not set this property, the default compression level is used,
                which normally gives a good balance of compression efficiency and
                compression speed.  In some tests, using <c>BestCompression</c> can
                double the time it takes to compress, while delivering just a small
                increase in compression efficiency.  This behavior will vary with the
                type of data you compress.  If you are in doubt, just leave this setting
                alone, and accept the default.
              </para>
            
              <para>
                When setting this property on a <c>ZipEntry</c> that is read from an
                existing zip file, calling <c>ZipFile.Save()</c> will cause the new
                <c>CompressionLevel</c> to be used on the entry in the newly saved zip file.
              </para>
            
              <para>
                Setting this property may have the side effect of modifying the
                <c>CompressionMethod</c> property. If you set the <c>CompressionLevel</c>
                to a value other than <c>None</c>, <c>CompressionMethod</c> will be set
                to <c>Deflate</c>, if it was previously <c>None</c>.
              </para>
            
              <para>
                Setting this property has no effect if the <c>CompressionMethod</c> is something
                other than <c>Deflate</c> or <c>None</c>.
              </para>
             </remarks>
            
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.CompressionMethod"/>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.CompressedSize">
             <summary>
               The compressed size of the file, in bytes, within the zip archive.
             </summary>
            
             <remarks>
               When reading a <c>ZipFile</c>, this value is read in from the existing
               zip file. When creating or updating a <c>ZipFile</c>, the compressed
               size is computed during compression.  Therefore the value on a
               <c>ZipEntry</c> is valid after a call to <c>Save()</c> (or one of its
               overloads) in that case.
             </remarks>
            
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.UncompressedSize"/>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.UncompressedSize">
             <summary>
               The size of the file, in bytes, before compression, or after extraction.
             </summary>
            
             <remarks>
               When reading a <c>ZipFile</c>, this value is read in from the existing
               zip file. When creating or updating a <c>ZipFile</c>, the uncompressed
               size is computed during compression.  Therefore the value on a
               <c>ZipEntry</c> is valid after a call to <c>Save()</c> (or one of its
               overloads) in that case.
             </remarks>
            
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.CompressedSize"/>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.CompressionRatio">
             <summary>
             The ratio of compressed size to uncompressed size of the ZipEntry.
             </summary>
            
             <remarks>
             <para>
               This is a ratio of the compressed size to the uncompressed size of the
               entry, expressed as a double in the range of 0 to 100+. A value of 100
               indicates no compression at all.  It could be higher than 100 when the
               compression algorithm actually inflates the data, as may occur for small
               files, or uncompressible data that is encrypted.
             </para>
            
             <para>
               You could format it for presentation to a user via a format string of
               "{3,5:F0}%" to see it as a percentage.
             </para>
            
             <para>
               If the size of the original uncompressed file is 0, implying a
               denominator of 0, the return value will be zero.
             </para>
            
             <para>
               This property is valid after reading in an existing zip file, or after
               saving the <c>ZipFile</c> that contains the ZipEntry. You cannot know the
               effect of a compression transform until you try it.
             </para>
            
             </remarks>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Crc">
             <summary>
             The 32-bit CRC (Cyclic Redundancy Check) on the contents of the ZipEntry.
             </summary>
            
             <remarks>
            
             <para> You probably don't need to concern yourself with this. It is used
             internally by DotNetZip to verify files or streams upon extraction.  </para>
            
             <para> The value is a <see href="http://en.wikipedia.org/wiki/CRC32">32-bit
             CRC</see> using 0xEDB88320 for the polynomial. This is the same CRC-32 used in
             PNG, MPEG-2, and other protocols and formats.  It is a read-only property; when
             creating a Zip archive, the CRC for each entry is set only after a call to
             <c>Save()</c> on the containing ZipFile. When reading an existing zip file, the value
             of this property reflects the stored CRC for the entry.  </para>
            
             </remarks>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.IsDirectory">
            <summary>
            True if the entry is a directory (not a file).
            This is a readonly property on the entry.
            </summary>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.UsesEncryption">
             <summary>
             A derived property that is <c>true</c> if the entry uses encryption.
             </summary>
            
             <remarks>
             <para>
               This is a readonly property on the entry.  When reading a zip file,
               the value for the <c>ZipEntry</c> is determined by the data read
               from the zip file.  After saving a ZipFile, the value of this
               property for each <c>ZipEntry</c> indicates whether encryption was
               actually used (which will have been true if the <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Password"/> was set and the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Encryption"/> property
               was something other than <see cref="F:OfficeOpenXml.Packaging.Ionic.Zip.EncryptionAlgorithm.None"/>.
             </para>
             </remarks>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Encryption">
             <summary>
               Set this to specify which encryption algorithm to use for the entry when
               saving it to a zip archive.
             </summary>
            
             <remarks>
            
             <para>
               Set this property in order to encrypt the entry when the <c>ZipFile</c> is
               saved. When setting this property, you must also set a <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Password"/> on the entry.  If you set a value other than <see
               cref="F:OfficeOpenXml.Packaging.Ionic.Zip.EncryptionAlgorithm.None"/> on this property and do not set a
               <c>Password</c> then the entry will not be encrypted. The <c>ZipEntry</c>
               data is encrypted as the <c>ZipFile</c> is saved, when you call <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Save"/> or one of its cousins on the containing
               <c>ZipFile</c> instance. You do not need to specify the <c>Encryption</c>
               when extracting entries from an archive.
             </para>
            
             <para>
               The Zip specification from PKWare defines a set of encryption algorithms,
               and the data formats for the zip archive that support them, and PKWare
               supports those algorithms in the tools it produces. Other vendors of tools
               and libraries, such as WinZip or Xceed, typically support <em>a
               subset</em> of the algorithms specified by PKWare. These tools can
               sometimes support additional different encryption algorithms and data
               formats, not specified by PKWare. The AES Encryption specified and
               supported by WinZip is the most popular example. This library supports a
               subset of the complete set of algorithms specified by PKWare and other
               vendors.
             </para>
            
             <para>
               There is no common, ubiquitous multi-vendor standard for strong encryption
               within zip files. There is broad support for so-called "traditional" Zip
               encryption, sometimes called Zip 2.0 encryption, as <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specified
               by PKWare</see>, but this encryption is considered weak and
               breakable. This library currently supports the Zip 2.0 "weak" encryption,
               and also a stronger WinZip-compatible AES encryption, using either 128-bit
               or 256-bit key strength. If you want DotNetZip to support an algorithm
               that is not currently supported, call the author of this library and maybe
               we can talk business.
             </para>
            
             <para>
               The <see cref="T:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile"/> class also has a <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/> property.  In most cases you will use
               <em>that</em> property when setting encryption. This property takes
               precedence over any <c>Encryption</c> set on the <c>ZipFile</c> itself.
               Typically, you would use the per-entry Encryption when most entries in the
               zip archive use one encryption algorithm, and a few entries use a
               different one.  If all entries in the zip file use the same Encryption,
               then it is simpler to just set this property on the ZipFile itself, when
               creating a zip archive.
             </para>
            
             <para>
               Some comments on updating archives: If you read a <c>ZipFile</c>, you can
               modify the Encryption on an encrypted entry: you can remove encryption
               from an entry that was encrypted; you can encrypt an entry that was not
               encrypted previously; or, you can change the encryption algorithm.  The
               changes in encryption are not made permanent until you call Save() on the
               <c>ZipFile</c>.  To effect changes in encryption, the entry content is
               streamed through several transformations, depending on the modification
               the application has requested. For example if the entry is not encrypted
               and the application sets <c>Encryption</c> to <c>PkzipWeak</c>, then at
               the time of <c>Save()</c>, the original entry is read and decompressed,
               then re-compressed and encrypted.  Conversely, if the original entry is
               encrypted with <c>PkzipWeak</c> encryption, and the application sets the
               <c>Encryption</c> property to <c>WinZipAes128</c>, then at the time of
               <c>Save()</c>, the original entry is decrypted via PKZIP encryption and
               decompressed, then re-compressed and re-encrypted with AES.  This all
               happens automatically within the library, but it can be time-consuming for
               large entries.
             </para>
            
             <para>
               Additionally, when updating archives, it is not possible to change the
               password when changing the encryption algorithm.  To change both the
               algorithm and the password, you need to Save() the zipfile twice.  First
               set the <c>Encryption</c> to None, then call <c>Save()</c>.  Then set the
               <c>Encryption</c> to the new value (not "None"), then call <c>Save()</c>
               once again.
             </para>
            
             <para>
               The WinZip AES encryption algorithms are not supported on the .NET Compact
               Framework.
             </para>
             </remarks>
            
             <example>
             <para>
               This example creates a zip archive that uses encryption, and then extracts
               entries from the archive.  When creating the zip archive, the ReadMe.txt
               file is zipped without using a password or encryption.  The other file
               uses encryption.
             </para>
             <code>
             // Create a zip archive with AES Encryption.
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddFile("ReadMe.txt")
                 ZipEntry e1= zip.AddFile("2008-Regional-Sales-Report.pdf");
                 e1.Encryption= EncryptionAlgorithm.WinZipAes256;
                 e1.Password= "Top.Secret.No.Peeking!";
                 zip.Save("EncryptedArchive.zip");
             }
            
             // Extract a zip archive that uses AES Encryption.
             // You do not need to specify the algorithm during extraction.
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 // Specify the password that is used during extraction, for
                 // all entries that require a password:
                 zip.Password= "Top.Secret.No.Peeking!";
                 zip.ExtractAll("extractDirectory");
             }
             </code>
            
             <code lang="VB">
             ' Create a zip that uses Encryption.
             Using zip As New ZipFile()
                 zip.AddFile("ReadMe.txt")
                 Dim e1 as ZipEntry
                 e1= zip.AddFile("2008-Regional-Sales-Report.pdf")
                 e1.Encryption= EncryptionAlgorithm.WinZipAes256
                 e1.Password= "Top.Secret.No.Peeking!"
                 zip.Save("EncryptedArchive.zip")
             End Using
            
             ' Extract a zip archive that uses AES Encryption.
             ' You do not need to specify the algorithm during extraction.
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 ' Specify the password that is used during extraction, for
                 ' all entries that require a password:
                 zip.Password= "Top.Secret.No.Peeking!"
                 zip.ExtractAll("extractDirectory")
             End Using
             </code>
            
             </example>
            
             <exception cref="T:System.InvalidOperationException">
             Thrown in the setter if EncryptionAlgorithm.Unsupported is specified.
             </exception>
            
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Password">ZipEntry.Password</seealso>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption">ZipFile.Encryption</seealso>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Password">
             <summary>
             The Password to be used when encrypting a <c>ZipEntry</c> upon
             <c>ZipFile.Save()</c>, or when decrypting an entry upon Extract().
             </summary>
            
             <remarks>
             <para>
               This is a write-only property on the entry. Set this to request that the
               entry be encrypted when writing the zip archive, or set it to specify the
               password to be used when extracting an existing entry that is encrypted.
             </para>
            
             <para>
               The password set here is implicitly used to encrypt the entry during the
               <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Save"/> operation, or to decrypt during the <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Extract"/> or <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.OpenReader"/> operation.  If you set
               the Password on a <c>ZipEntry</c> after calling <c>Save()</c>, there is no
               effect.
             </para>
            
             <para>
               Consider setting the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Encryption"/> property when using a
               password. Answering concerns that the standard password protection
               supported by all zip tools is weak, WinZip has extended the ZIP
               specification with a way to use AES Encryption to protect entries in the
               Zip file. Unlike the "PKZIP 2.0" encryption specified in the PKZIP
               specification, <see href=
               "http://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES
               Encryption</see> uses a standard, strong, tested, encryption
               algorithm. DotNetZip can create zip archives that use WinZip-compatible
               AES encryption, if you set the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Encryption"/> property. But,
               archives created that use AES encryption may not be readable by all other
               tools and libraries. For example, Windows Explorer cannot read a
               "compressed folder" (a zip file) that uses AES encryption, though it can
               read a zip file that uses "PKZIP encryption."
             </para>
            
             <para>
               The <see cref="T:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile"/> class also has a <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>
               property.  This property takes precedence over any password set on the
               ZipFile itself.  Typically, you would use the per-entry Password when most
               entries in the zip archive use one password, and a few entries use a
               different password.  If all entries in the zip file use the same password,
               then it is simpler to just set this property on the ZipFile itself,
               whether creating a zip archive or extracting a zip archive.
             </para>
            
             <para>
               Some comments on updating archives: If you read a <c>ZipFile</c>, you
               cannot modify the password on any encrypted entry, except by extracting
               the entry with the original password (if any), removing the original entry
               via <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.RemoveEntry(OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry)"/>, and then adding a new
               entry with a new Password.
             </para>
            
             <para>
               For example, suppose you read a <c>ZipFile</c>, and there is an encrypted
               entry.  Setting the Password property on that <c>ZipEntry</c> and then
               calling <c>Save()</c> on the <c>ZipFile</c> does not update the password
               on that entry in the archive.  Neither is an exception thrown. Instead,
               what happens during the <c>Save()</c> is the existing entry is copied
               through to the new zip archive, in its original encrypted form. Upon
               re-reading that archive, the entry can be decrypted with its original
               password.
             </para>
            
             <para>
               If you read a ZipFile, and there is an un-encrypted entry, you can set the
               <c>Password</c> on the entry and then call Save() on the ZipFile, and get
               encryption on that entry.
             </para>
            
             </remarks>
            
             <example>
             <para>
               This example creates a zip file with two entries, and then extracts the
               entries from the zip file.  When creating the zip file, the two files are
               added to the zip file using password protection. Each entry uses a
               different password.  During extraction, each file is extracted with the
               appropriate password.
             </para>
             <code>
             // create a file with encryption
             using (ZipFile zip = new ZipFile())
             {
                 ZipEntry entry;
                 entry= zip.AddFile("Declaration.txt");
                 entry.Password= "123456!";
                 entry = zip.AddFile("Report.xls");
                 entry.Password= "1Secret!";
                 zip.Save("EncryptedArchive.zip");
             }
            
             // extract entries that use encryption
             using (ZipFile zip = ZipFile.Read("EncryptedArchive.zip"))
             {
                 ZipEntry entry;
                 entry = zip["Declaration.txt"];
                 entry.Password = "123456!";
                 entry.Extract("extractDir");
                 entry = zip["Report.xls"];
                 entry.Password = "1Secret!";
                 entry.Extract("extractDir");
             }
            
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 Dim entry as ZipEntry
                 entry= zip.AddFile("Declaration.txt")
                 entry.Password= "123456!"
                 entry = zip.AddFile("Report.xls")
                 entry.Password= "1Secret!"
                 zip.Save("EncryptedArchive.zip")
             End Using
            
            
             ' extract entries that use encryption
             Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))
                 Dim entry as ZipEntry
                 entry = zip("Declaration.txt")
                 entry.Password = "123456!"
                 entry.Extract("extractDir")
                 entry = zip("Report.xls")
                 entry.Password = "1Secret!"
                 entry.Extract("extractDir")
             End Using
            
             </code>
            
             </example>
            
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Encryption"/>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password">ZipFile.Password</seealso>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ExtractExistingFile">
             <summary>
             The action the library should take when extracting a file that already exists.
             </summary>
            
             <remarks>
               <para>
                 This property affects the behavior of the Extract methods (one of the
                 <c>Extract()</c> or <c>ExtractWithPassword()</c> overloads), when
                 extraction would would overwrite an existing filesystem file. If you do
                 not set this property, the library throws an exception when extracting
                 an entry would overwrite an existing file.
               </para>
            
               <para>
                 This property has no effect when extracting to a stream, or when the file to be
                 extracted does not already exist.
               </para>
            
             </remarks>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>
            
             <example>
               This example shows how to set the <c>ExtractExistingFile</c> property in
               an <c>ExtractProgress</c> event, in response to user input. The
               <c>ExtractProgress</c> event is invoked if and only if the
               <c>ExtractExistingFile</c> property was previously set to
               <c>ExtractExistingFileAction.InvokeExtractProgressEvent</c>.
             <code lang="C#">
             public static void ExtractProgress(object sender, ExtractProgressEventArgs e)
             {
                 if (e.EventType == ZipProgressEventType.Extracting_BeforeExtractEntry)
                     Console.WriteLine("extract {0} ", e.CurrentEntry.FileName);
            
                 else if (e.EventType == ZipProgressEventType.Extracting_ExtractEntryWouldOverwrite)
                 {
                     ZipEntry entry = e.CurrentEntry;
                     string response = null;
                     // Ask the user if he wants overwrite the file
                     do
                     {
                         Console.Write("Overwrite {0} in {1} ? (y/n/C) ", entry.FileName, e.ExtractLocation);
                         response = Console.ReadLine();
                         Console.WriteLine();
            
                     } while (response != null &amp;&amp; response[0]!='Y' &amp;&amp;
                              response[0]!='N' &amp;&amp; response[0]!='C');
            
                     if  (response[0]=='C')
                         e.Cancel = true;
                     else if (response[0]=='Y')
                         entry.ExtractExistingFile = ExtractExistingFileAction.OverwriteSilently;
                     else
                         entry.ExtractExistingFile= ExtractExistingFileAction.DoNotOverwrite;
                 }
             }
             </code>
             </example>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ZipErrorAction">
             <summary>
               The action to take when an error is encountered while
               opening or reading files as they are saved into a zip archive.
             </summary>
            
             <remarks>
              <para>
                 Errors can occur within a call to <see
                 cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Save">ZipFile.Save</see>, as the various files contained
                 in a ZipFile are being saved into the zip archive.  During the
                 <c>Save</c>, DotNetZip will perform a <c>File.Open</c> on the file
                 associated to the ZipEntry, and then will read the entire contents of
                 the file as it is zipped. Either the open or the Read may fail, because
                 of lock conflicts or other reasons.  Using this property, you can
                 specify the action to take when such errors occur.
              </para>
            
              <para>
                 Typically you will NOT set this property on individual ZipEntry
                 instances.  Instead, you will set the <see
                 cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction">ZipFile.ZipErrorAction</see> property on
                 the ZipFile instance, before adding any entries to the
                 <c>ZipFile</c>. If you do this, errors encountered on behalf of any of
                 the entries in the ZipFile will be handled the same way.
              </para>
            
              <para>
                 But, if you use a <see cref="E:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipError"/> handler, you will want
                 to set this property on the <c>ZipEntry</c> within the handler, to
                 communicate back to DotNetZip what you would like to do with the
                 particular error.
              </para>
            
             </remarks>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>
             <seealso cref="E:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipError"/>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.IncludedInMostRecentSave">
            <summary>
            Indicates whether the entry was included in the most recent save.
            </summary>
            <remarks>
            An entry can be excluded or skipped from a save if there is an error
            opening or reading the entry.
            </remarks>
            <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ZipErrorAction"/>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.SetCompression">
             <summary>
               A callback that allows the application to specify the compression to use
               for a given entry that is about to be added to the zip archive.
             </summary>
            
             <remarks>
             <para>
               See <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression" />
             </para>
             </remarks>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.UseUnicodeAsNecessary">
             <summary>
               Set to indicate whether to use UTF-8 encoding for filenames and comments.
             </summary>
            
             <remarks>
            
             <para>
               If this flag is set, the comment and filename for the entry will be
               encoded with UTF-8, as described in <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">the Zip
               specification</see>, if necessary. "Necessary" means, the filename or
               entry comment (if any) cannot be reflexively encoded and decoded using the
               default code page, IBM437.
             </para>
            
             <para>
               Setting this flag to true is equivalent to setting <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ProvisionalAlternateEncoding"/> to <c>System.Text.Encoding.UTF8</c>.
             </para>
            
             <para>
               This flag has no effect or relation to the text encoding used within the
               file itself.
             </para>
            
             </remarks>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ProvisionalAlternateEncoding">
             <summary>
               The text encoding to use for the FileName and Comment on this ZipEntry,
               when the default encoding is insufficient.
             </summary>
            
             <remarks>
            
             <para>
               Don't use this property.  See <see cref='P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AlternateEncoding'/>.
             </para>
            
             </remarks>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AlternateEncoding">
            <summary>
              Specifies the alternate text encoding used by this ZipEntry
            </summary>
            <remarks>
              <para>
                The default text encoding used in Zip files for encoding filenames and
                comments is IBM437, which is something like a superset of ASCII.  In
                cases where this is insufficient, applications can specify an
                alternate encoding.
              </para>
              <para>
                When creating a zip file, the usage of the alternate encoding is
                governed by the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AlternateEncodingUsage"/> property.
                Typically you would set both properties to tell DotNetZip to employ an
                encoding that is not IBM437 in the zipfile you are creating.
              </para>
              <para>
                Keep in mind that because the ZIP specification states that the only
                valid encodings to use are IBM437 and UTF-8, if you use something
                other than that, then zip tools and libraries may not be able to
                successfully read the zip archive you generate.
              </para>
              <para>
                The zip specification states that applications should presume that
                IBM437 is in use, except when a special bit is set, which indicates
                UTF-8. There is no way to specify an arbitrary code page, within the
                zip file itself. When you create a zip file encoded with gb2312 or
                ibm861 or anything other than IBM437 or UTF-8, then the application
                that reads the zip file needs to "know" which code page to use. In
                some cases, the code page used when reading is chosen implicitly. For
                example, WinRar uses the ambient code page for the host desktop
                operating system. The pitfall here is that if you create a zip in
                Copenhagen and send it to Tokyo, the reader of the zipfile may not be
                able to decode successfully.
              </para>
            </remarks>
            <example>
              This example shows how to create a zipfile encoded with a
              language-specific encoding:
            <code>
              using (var zip = new ZipFile())
              {
                 zip.AlternateEnoding = System.Text.Encoding.GetEncoding("ibm861");
                 zip.AlternateEnodingUsage = ZipOption.Always;
                 zip.AddFileS(arrayOfFiles);
                 zip.Save("Myarchive-Encoded-in-IBM861.zip");
              }
            </code>
            </example>
            <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AlternateEncodingUsage" />
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.AlternateEncodingUsage">
            <summary>
              Describes if and when this instance should apply
              AlternateEncoding to encode the FileName and Comment, when
              saving.
            </summary>
            <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AlternateEncoding" />
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.IsText">
             <summary>
               Indicates whether an entry is marked as a text file. Be careful when
               using on this property. Unless you have a good reason, you should
               probably ignore this property.
             </summary>
            
             <remarks>
             <para>
               The ZIP format includes a provision for specifying whether an entry in
               the zip archive is a text or binary file.  This property exposes that
               metadata item. Be careful when using this property: It's not clear
               that this property as a firm meaning, across tools and libraries.
             </para>
            
             <para>
               To be clear, when reading a zip file, the property value may or may
               not be set, and its value may or may not be valid.  Not all entries
               that you may think of as "text" entries will be so marked, and entries
               marked as "text" are not guaranteed in any way to be text entries.
               Whether the value is set and set correctly depends entirely on the
               application that produced the zip file.
             </para>
            
             <para>
               There are many zip tools available, and when creating zip files, some
               of them "respect" the IsText metadata field, and some of them do not.
               Unfortunately, even when an application tries to do "the right thing",
               it's not always clear what "the right thing" is.
             </para>
            
             <para>
               There's no firm definition of just what it means to be "a text file",
               and the zip specification does not help in this regard. Twenty years
               ago, text was ASCII, each byte was less than 127. IsText meant, all
               bytes in the file were less than 127.  These days, it is not the case
               that all text files have all bytes less than 127.  Any unicode file
               may have bytes that are above 0x7f.  The zip specification has nothing
               to say on this topic. Therefore, it's not clear what IsText really
               means.
             </para>
            
             <para>
               This property merely tells a reading application what is stored in the
               metadata for an entry, without guaranteeing its validity or its
               meaning.
             </para>
            
             <para>
               When DotNetZip is used to create a zipfile, it attempts to set this
               field "correctly." For example, if a file ends in ".txt", this field
               will be set. Your application may override that default setting.  When
               writing a zip file, you must set the property before calling
               <c>Save()</c> on the ZipFile.
             </para>
            
             <para>
               When reading a zip file, a more general way to decide just what kind
               of file is contained in a particular entry is to use the file type
               database stored in the operating system.  The operating system stores
               a table that says, a file with .jpg extension is a JPG image file, a
               file with a .xml extension is an XML document, a file with a .txt is a
               pure ASCII text document, and so on.  To get this information on
               Windows, <see
               href="http://www.codeproject.com/KB/cs/GetFileTypeAndIcon.aspx"> you
               need to read and parse the registry.</see> </para>
             </remarks>
            
             <example>
             <code>
             using (var zip = new ZipFile())
             {
                 var e = zip.UpdateFile("Descriptions.mme", "");
                 e.IsText = true;
                 zip.Save(zipPath);
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 Dim e2 as ZipEntry = zip.AddFile("Descriptions.mme", "")
                 e.IsText= True
                 zip.Save(zipPath)
             End Using
             </code>
             </example>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ToString">
            <summary>Provides a string representation of the instance.</summary>
            <returns>a string representation of the instance.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Extract">
             <summary>
               Extract the entry to the filesystem, starting at the current
               working directory.
             </summary>
            
             <overloads>
               This method has a bunch of overloads! One of them is sure to
               be the right one for you... If you don't like these, check
               out the <c>ExtractWithPassword()</c> methods.
             </overloads>
            
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ExtractExistingFile"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Extract(OfficeOpenXml.Packaging.Ionic.Zip.ExtractExistingFileAction)"/>
            
             <remarks>
            
             <para>
               This method extracts an entry from a zip file into the current
               working directory.  The path of the entry as extracted is the full
               path as specified in the zip archive, relative to the current
               working directory.  After the file is extracted successfully, the
               file attributes and timestamps are set.
             </para>
            
             <para>
               The action taken when extraction an entry would overwrite an
               existing file is determined by the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ExtractExistingFile"
               /> property.
             </para>
            
             <para>
               Within the call to <c>Extract()</c>, the content for the entry is
               written into a filesystem file, and then the last modified time of the
               file is set according to the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.LastModified"/> property on
               the entry. See the remarks the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.LastModified"/> property for
               some details about the last modified time.
             </para>
            
             </remarks>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Extract(OfficeOpenXml.Packaging.Ionic.Zip.ExtractExistingFileAction)">
             <summary>
               Extract the entry to a file in the filesystem, using the specified
               behavior when extraction would overwrite an existing file.
             </summary>
            
             <remarks>
             <para>
               See the remarks on the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.LastModified"/> property, for some
               details about how the last modified time of the file is set after
               extraction.
             </para>
             </remarks>
            
             <param name="extractExistingFile">
               The action to take if extraction would overwrite an existing file.
             </param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Extract(System.IO.Stream)">
             <summary>
               Extracts the entry to the specified stream.
             </summary>
            
             <remarks>
             <para>
               The caller can specify any write-able stream, for example a <see
               cref="T:System.IO.FileStream"/>, a <see
               cref="T:System.IO.MemoryStream"/>, or ASP.NET's
               <c>Response.OutputStream</c>.  The content will be decrypted and
               decompressed as necessary. If the entry is encrypted and no password
               is provided, this method will throw.
             </para>
             <para>
               The position on the stream is not reset by this method before it extracts.
               You may want to call stream.Seek() before calling ZipEntry.Extract().
             </para>
             </remarks>
            
             <param name="stream">
               the stream to which the entry should be extracted.
             </param>
            
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Extract(System.String)">
             <summary>
               Extract the entry to the filesystem, starting at the specified base
               directory.
             </summary>
            
             <param name="baseDirectory">the pathname of the base directory</param>
            
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ExtractExistingFile"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Extract(System.String,OfficeOpenXml.Packaging.Ionic.Zip.ExtractExistingFileAction)"/>
            
             <example>
             This example extracts only the entries in a zip file that are .txt files,
             into a directory called "textfiles".
             <code lang="C#">
             using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
             {
               foreach (string s1 in zip.EntryFilenames)
               {
                 if (s1.EndsWith(".txt"))
                 {
                   zip[s1].Extract("textfiles");
                 }
               }
             }
             </code>
             <code lang="VB">
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
                   Dim s1 As String
                   For Each s1 In zip.EntryFilenames
                       If s1.EndsWith(".txt") Then
                           zip(s1).Extract("textfiles")
                       End If
                   Next
               End Using
             </code>
             </example>
            
             <remarks>
            
             <para>
               Using this method, existing entries in the filesystem will not be
               overwritten. If you would like to force the overwrite of existing
               files, see the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ExtractExistingFile"/> property, or call
               <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Extract(System.String,OfficeOpenXml.Packaging.Ionic.Zip.ExtractExistingFileAction)"/>.
             </para>
            
             <para>
               See the remarks on the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.LastModified"/> property, for some
               details about how the last modified time of the created file is set.
             </para>
             </remarks>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Extract(System.String,OfficeOpenXml.Packaging.Ionic.Zip.ExtractExistingFileAction)">
             <summary>
               Extract the entry to the filesystem, starting at the specified base
               directory, and using the specified behavior when extraction would
               overwrite an existing file.
             </summary>
            
             <remarks>
             <para>
               See the remarks on the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.LastModified"/> property, for some
               details about how the last modified time of the created file is set.
             </para>
             </remarks>
            
             <example>
             <code lang="C#">
             String sZipPath = "Airborne.zip";
             String sFilePath = "Readme.txt";
             String sRootFolder = "Digado";
             using (ZipFile zip = ZipFile.Read(sZipPath))
             {
               if (zip.EntryFileNames.Contains(sFilePath))
               {
                 // use the string indexer on the zip file
                 zip[sFileName].Extract(sRootFolder,
                                        ExtractExistingFileAction.OverwriteSilently);
               }
             }
             </code>
            
             <code lang="VB">
             Dim sZipPath as String = "Airborne.zip"
             Dim sFilePath As String = "Readme.txt"
             Dim sRootFolder As String = "Digado"
             Using zip As ZipFile = ZipFile.Read(sZipPath)
               If zip.EntryFileNames.Contains(sFilePath)
                 ' use the string indexer on the zip file
                 zip(sFilePath).Extract(sRootFolder, _
                                        ExtractExistingFileAction.OverwriteSilently)
               End If
             End Using
             </code>
             </example>
            
             <param name="baseDirectory">the pathname of the base directory</param>
             <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ExtractWithPassword(System.String)">
             <summary>
               Extract the entry to the filesystem, using the current working directory
               and the specified password.
             </summary>
            
             <overloads>
               This method has a bunch of overloads! One of them is sure to be
               the right one for you...
             </overloads>
            
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ExtractExistingFile"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ExtractWithPassword(OfficeOpenXml.Packaging.Ionic.Zip.ExtractExistingFileAction,System.String)"/>
            
             <remarks>
            
             <para>
               Existing entries in the filesystem will not be overwritten. If you
               would like to force the overwrite of existing files, see the <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ExtractExistingFile"/>property, or call
               <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ExtractWithPassword(OfficeOpenXml.Packaging.Ionic.Zip.ExtractExistingFileAction,System.String)"/>.
             </para>
            
             <para>
               See the remarks on the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.LastModified"/> property for some
               details about how the "last modified" time of the created file is
               set.
             </para>
             </remarks>
            
             <example>
               In this example, entries that use encryption are extracted using a
               particular password.
             <code>
             using (var zip = ZipFile.Read(FilePath))
             {
                 foreach (ZipEntry e in zip)
                 {
                     if (e.UsesEncryption)
                         e.ExtractWithPassword("Secret!");
                     else
                         e.Extract();
                 }
             }
             </code>
             <code lang="VB">
             Using zip As ZipFile = ZipFile.Read(FilePath)
                 Dim e As ZipEntry
                 For Each e In zip
                     If (e.UsesEncryption)
                       e.ExtractWithPassword("Secret!")
                     Else
                       e.Extract
                     End If
                 Next
             End Using
             </code>
             </example>
             <param name="password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,System.String)">
             <summary>
               Extract the entry to the filesystem, starting at the specified base
               directory, and using the specified password.
             </summary>
            
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ExtractExistingFile"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,OfficeOpenXml.Packaging.Ionic.Zip.ExtractExistingFileAction,System.String)"/>
            
             <remarks>
             <para>
               Existing entries in the filesystem will not be overwritten. If you
               would like to force the overwrite of existing files, see the <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ExtractExistingFile"/>property, or call
               <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ExtractWithPassword(OfficeOpenXml.Packaging.Ionic.Zip.ExtractExistingFileAction,System.String)"/>.
             </para>
            
             <para>
               See the remarks on the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.LastModified"/> property, for some
               details about how the last modified time of the created file is set.
             </para>
             </remarks>
            
             <param name="baseDirectory">The pathname of the base directory.</param>
             <param name="password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ExtractWithPassword(OfficeOpenXml.Packaging.Ionic.Zip.ExtractExistingFileAction,System.String)">
             <summary>
               Extract the entry to a file in the filesystem, relative to the
               current directory, using the specified behavior when extraction
               would overwrite an existing file.
             </summary>
            
             <remarks>
             <para>
               See the remarks on the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.LastModified"/> property, for some
               details about how the last modified time of the created file is set.
             </para>
             </remarks>
            
             <param name="password">The Password to use for decrypting the entry.</param>
            
             <param name="extractExistingFile">
             The action to take if extraction would overwrite an existing file.
             </param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,OfficeOpenXml.Packaging.Ionic.Zip.ExtractExistingFileAction,System.String)">
             <summary>
               Extract the entry to the filesystem, starting at the specified base
               directory, and using the specified behavior when extraction would
               overwrite an existing file.
             </summary>
            
             <remarks>
               See the remarks on the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.LastModified"/> property, for some
               details about how the last modified time of the created file is set.
             </remarks>
            
             <param name="baseDirectory">the pathname of the base directory</param>
            
             <param name="extractExistingFile">The action to take if extraction would
             overwrite an existing file.</param>
            
             <param name="password">The Password to use for decrypting the entry.</param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ExtractWithPassword(System.IO.Stream,System.String)">
             <summary>
               Extracts the entry to the specified stream, using the specified
               Password.  For example, the caller could extract to Console.Out, or
               to a MemoryStream.
             </summary>
            
             <remarks>
             <para>
               The caller can specify any write-able stream, for example a <see
               cref="T:System.IO.FileStream"/>, a <see
               cref="T:System.IO.MemoryStream"/>, or ASP.NET's
               <c>Response.OutputStream</c>.  The content will be decrypted and
               decompressed as necessary. If the entry is encrypted and no password
               is provided, this method will throw.
             </para>
             <para>
               The position on the stream is not reset by this method before it extracts.
               You may want to call stream.Seek() before calling ZipEntry.Extract().
             </para>
             </remarks>
            
            
             <param name="stream">
               the stream to which the entry should be extracted.
             </param>
             <param name="password">
               The password to use for decrypting the entry.
             </param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.OpenReader">
             <summary>
               Opens a readable stream corresponding to the zip entry in the
               archive.  The stream decompresses and decrypts as necessary, as it
               is read.
             </summary>
            
             <remarks>
            
             <para>
               DotNetZip offers a variety of ways to extract entries from a zip
               file.  This method allows an application to extract an entry by
               reading a <see cref="T:System.IO.Stream"/>.
             </para>
            
             <para>
               The return value is of type <see
               cref="T:OfficeOpenXml.Packaging.Ionic.Crc.CrcCalculatorStream"/>.  Use it as you would any
               stream for reading.  When an application calls <see
               cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/> on that stream, it will
               receive data from the zip entry that is decrypted and decompressed
               as necessary.
             </para>
            
             <para>
               <c>CrcCalculatorStream</c> adds one additional feature: it keeps a
               CRC32 checksum on the bytes of the stream as it is read.  The CRC
               value is available in the <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Crc.CrcCalculatorStream.Crc"/> property on the
               <c>CrcCalculatorStream</c>.  When the read is complete, your
               application
               <em>should</em> check this CRC against the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Crc"/>
               property on the <c>ZipEntry</c> to validate the content of the
               ZipEntry. You don't have to validate the entry using the CRC, but
               you should, to verify integrity. Check the example for how to do
               this.
             </para>
            
             <para>
               If the entry is protected with a password, then you need to provide
               a password prior to calling <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.OpenReader"/>, either by
               setting the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Password"/> property on the entry, or the
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/> property on the <c>ZipFile</c>
               itself. Or, you can use <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.OpenReader(System.String)" />, the
               overload of OpenReader that accepts a password parameter.
             </para>
            
             <para>
               If you want to extract entry data into a write-able stream that is
               already opened, like a <see cref="T:System.IO.FileStream"/>, do not
               use this method. Instead, use <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Extract(System.IO.Stream)"/>.
             </para>
            
             <para>
               Your application may use only one stream created by OpenReader() at
               a time, and you should not call other Extract methods before
               completing your reads on a stream obtained from OpenReader().  This
               is because there is really only one source stream for the compressed
               content.  A call to OpenReader() seeks in the source stream, to the
               beginning of the compressed content.  A subsequent call to
               OpenReader() on a different entry will seek to a different position
               in the source stream, as will a call to Extract() or one of its
               overloads.  This will corrupt the state for the decompressing stream
               from the original call to OpenReader().
             </para>
            
             <para>
                The <c>OpenReader()</c> method works only when the ZipEntry is
                obtained from an instance of <c>ZipFile</c>. This method will throw
                an exception if the ZipEntry is obtained from a ZipInputStream.
             </para>
             </remarks>
            
             <example>
               This example shows how to open a zip archive, then read in a named
               entry via a stream. After the read loop is complete, the code
               compares the calculated during the read loop with the expected CRC
               on the <c>ZipEntry</c>, to verify the extraction.
             <code>
             using (ZipFile zip = new ZipFile(ZipFileToRead))
             {
               ZipEntry e1= zip["Elevation.mp3"];
               using (Ionic.Zlib.CrcCalculatorStream s = e1.OpenReader())
               {
                 byte[] buffer = new byte[4096];
                 int n, totalBytesRead= 0;
                 do {
                   n = s.Read(buffer,0, buffer.Length);
                   totalBytesRead+=n;
                 } while (n&gt;0);
                  if (s.Crc32 != e1.Crc32)
                   throw new Exception(string.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32));
                  if (totalBytesRead != e1.UncompressedSize)
                   throw new Exception(string.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize));
               }
             }
             </code>
             <code lang="VB">
               Using zip As New ZipFile(ZipFileToRead)
                   Dim e1 As ZipEntry = zip.Item("Elevation.mp3")
                   Using s As Ionic.Zlib.CrcCalculatorStream = e1.OpenReader
                       Dim n As Integer
                       Dim buffer As Byte() = New Byte(4096) {}
                       Dim totalBytesRead As Integer = 0
                       Do
                           n = s.Read(buffer, 0, buffer.Length)
                           totalBytesRead = (totalBytesRead + n)
                       Loop While (n &gt; 0)
                       If (s.Crc32 &lt;&gt; e1.Crc32) Then
                           Throw New Exception(String.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32))
                       End If
                       If (totalBytesRead &lt;&gt; e1.UncompressedSize) Then
                           Throw New Exception(String.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize))
                       End If
                   End Using
               End Using
             </code>
             </example>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.Extract(System.IO.Stream)"/>
             <returns>The Stream for reading.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.OpenReader(System.String)">
             <summary>
               Opens a readable stream for an encrypted zip entry in the archive.
               The stream decompresses and decrypts as necessary, as it is read.
             </summary>
            
             <remarks>
             <para>
               See the documentation on the <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.OpenReader"/> method for
               full details. This overload allows the application to specify a
               password for the <c>ZipEntry</c> to be read.
             </para>
             </remarks>
            
             <param name="password">The password to use for decrypting the entry.</param>
             <returns>The Stream for reading.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ValidateOutput(System.String,System.IO.Stream,System.String@)">
            <summary>
            Validates that the args are consistent.
            </summary>
            <remarks>
            Only one of {baseDir, outStream} can be non-null.
            If baseDir is non-null, then the outputFile is created.
            </remarks>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ReadEntry(OfficeOpenXml.Packaging.Ionic.Zip.ZipContainer,System.Boolean)">
            <summary>
              Reads one <c>ZipEntry</c> from the given stream.  The content for
              the entry does not get decompressed or decrypted.  This method
              basically reads metadata, and seeks.
            </summary>
            <param name="zc">the ZipContainer this entry belongs to.</param>
            <param name="first">
              true of this is the first entry being read from the stream.
            </param>
            <returns>the <c>ZipEntry</c> read from the stream.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.FindExtraFieldSegment(System.Byte[],System.Int32,System.UInt16)">
            <summary>
              Finds a particular segment in the given extra field.
              This is used when modifying a previously-generated
              extra field, in particular when removing the AES crypto
              segment in the extra field.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ProcessExtraField(System.IO.Stream,System.Int16)">
            <summary>
              At current cursor position in the stream, read the extra
              field, and set the properties on the ZipEntry instance
              appropriately.  This can be called when processing the
              Extra field in the Central Directory, or in the local
              header.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.GetEncodedFileNameBytes">
            <summary>
              generate and return a byte array that encodes the filename
              for the entry.
            </summary>
            <remarks>
              <para>
                side effects: generate and store into _CommentBytes the
                byte array for any comment attached to the entry. Also
                sets _actualEncoding to indicate the actual encoding
                used. The same encoding is used for both filename and
                comment.
              </para>
            </remarks>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.PrepSourceStream">
             <summary>
               Stores the position of the entry source stream, or, if the position is
               already stored, seeks to that position.
             </summary>
            
             <remarks>
             <para>
               This method is called in prep for reading the source stream.  If PKZIP
               encryption is used, then we need to calc the CRC32 before doing the
               encryption, because the CRC is used in the 12th byte of the PKZIP
               encryption header.  So, we need to be able to seek backward in the source
               when saving the ZipEntry. This method is called from the place that
               calculates the CRC, and also from the method that does the encryption of
               the file data.
             </para>
            
             <para>
               The first time through, this method sets the _sourceStreamOriginalPosition
               field. Subsequent calls to this method seek to that position.
             </para>
             </remarks>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.CopyMetaData(OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry)">
            <summary>
            Copy metadata that may have been changed by the app.  We do this when
            resetting the zipFile instance.  If the app calls Save() on a ZipFile, then
            tries to party on that file some more, we may need to Reset() it , which
            means re-reading the entries and then copying the metadata.  I think.
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.SetInputAndFigureFileLength(System.IO.Stream@)">
            <summary>
              Set the input stream and get its length, if possible.  The length is
              used for progress updates, AND, to allow an optimization in case of
              a stream/file of zero length. In that case we skip the Encrypt and
              compression Stream. (like DeflateStream or BZip2OutputStream)
            </summary>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.PrepOutputStream(System.IO.Stream,System.Int64,OfficeOpenXml.Packaging.Ionic.Zip.CountingStream@,System.IO.Stream@,System.IO.Stream@,OfficeOpenXml.Packaging.Ionic.Crc.CrcCalculatorStream@)">
            <summary>
              Prepare the given stream for output - wrap it in a CountingStream, and
              then in a CRC stream, and an encryptor and deflator as appropriate.
            </summary>
            <remarks>
              <para>
                Previously this was used in ZipEntry.Write(), but in an effort to
                introduce some efficiencies in that method I've refactored to put the
                code inline.  This method still gets called by ZipOutputStream.
              </para>
            </remarks>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntryTimestamp">
             <summary>
               An enum that specifies the type of timestamp available on the ZipEntry.
             </summary>
            
             <remarks>
            
             <para>
               The last modified time of a file can be stored in multiple ways in
               a zip file, and they are not mutually exclusive:
             </para>
            
             <list type="bullet">
               <item>
                 In the so-called "DOS" format, which has a 2-second precision. Values
                 are rounded to the nearest even second. For example, if the time on the
                 file is 12:34:43, then it will be stored as 12:34:44. This first value
                 is accessible via the <c>LastModified</c> property. This value is always
                 present in the metadata for each zip entry.  In some cases the value is
                 invalid, or zero.
               </item>
            
               <item>
                 In the so-called "Windows" or "NTFS" format, as an 8-byte integer
                 quantity expressed as the number of 1/10 milliseconds (in other words
                 the number of 100 nanosecond units) since January 1, 1601 (UTC).  This
                 format is how Windows represents file times.  This time is accessible
                 via the <c>ModifiedTime</c> property.
               </item>
            
               <item>
                 In the "Unix" format, a 4-byte quantity specifying the number of seconds since
                 January 1, 1970 UTC.
               </item>
            
               <item>
                 In an older format, now deprecated but still used by some current
                 tools. This format is also a 4-byte quantity specifying the number of
                 seconds since January 1, 1970 UTC.
               </item>
            
             </list>
            
             <para>
               This bit field describes which of the formats were found in a <c>ZipEntry</c> that was read.
             </para>
            
             </remarks>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntryTimestamp.None">
            <summary>
            Default value.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntryTimestamp.DOS">
            <summary>
            A DOS timestamp with 2-second precision.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntryTimestamp.Windows">
            <summary>
            A Windows timestamp with 100-ns precision.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntryTimestamp.Unix">
            <summary>
            A Unix timestamp with 1-second precision.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntryTimestamp.InfoZip1">
            <summary>
            A Unix timestamp with 1-second precision, stored in InfoZip v1 format.  This
            format is outdated and is supported for reading archives only.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.CompressionMethod">
             <summary>
               The method of compression to use for a particular ZipEntry.
             </summary>
            
             <remarks>
               <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWare's
               ZIP Specification</see> describes a number of distinct
               cmopression methods that can be used within a zip
               file. DotNetZip supports a subset of them.
             </remarks>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.CompressionMethod.None">
            <summary>
            No compression at all. For COM environments, the value is 0 (zero).
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.CompressionMethod.Deflate">
            <summary>
              DEFLATE compression, as described in <see
              href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC
              1951</see>.  This is the "normal" compression used in zip
              files. For COM environments, the value is 8.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntrySource">
            <summary>
            An enum that specifies the source of the ZipEntry. 
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntrySource.None">
            <summary>
            Default value.  Invalid on a bonafide ZipEntry.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntrySource.FileSystem">
            <summary>
            The entry was instantiated by calling AddFile() or another method that 
            added an entry from the filesystem.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntrySource.Stream">
            <summary>
            The entry was instantiated via <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,System.String)"/> or
            <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)"/> .
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntrySource.ZipFile">
            <summary>
            The ZipEntry was instantiated by reading a zipfile.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntrySource.WriteDelegate">
            <summary>
            The content for the ZipEntry will be or was provided by the WriteDelegate.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntrySource.JitStream">
            <summary>
            The content for the ZipEntry will be obtained from the stream dispensed by the <c>OpenDelegate</c>.
            The entry was instantiated via <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,OfficeOpenXml.Packaging.Ionic.Zip.OpenDelegate,OfficeOpenXml.Packaging.Ionic.Zip.CloseDelegate)"/>.
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntrySource.ZipOutputStream">
            <summary>
            The content for the ZipEntry will be or was obtained from a <c>ZipOutputStream</c>.
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.ZipErrorAction">
             <summary>
             An enum providing the options when an error occurs during opening or reading
             of a file or directory that is being saved to a zip file. 
             </summary>
            
             <remarks>
              <para>
                This enum describes the actions that the library can take when an error occurs
                opening or reading a file, as it is being saved into a Zip archive. 
              </para>
            
              <para>
                 In some cases an error will occur when DotNetZip tries to open a file to be
                 added to the zip archive.  In other cases, an error might occur after the
                 file has been successfully opened, while DotNetZip is reading the file.
              </para>
             
              <para>
                The first problem might occur when calling AddDirectory() on a directory
                that contains a Clipper .dbf file; the file is locked by Clipper and
                cannot be opened by another process. An example of the second problem is
                the ERROR_LOCK_VIOLATION that results when a file is opened by another
                process, but not locked, and a range lock has been taken on the file.
                Microsoft Outlook takes range locks on .PST files.
              </para>
             </remarks>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipErrorAction.Throw">
            <summary>
            Throw an exception when an error occurs while zipping.  This is the default
            behavior.  (For COM clients, this is a 0 (zero).)
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipErrorAction.Skip">
            <summary>
            When an error occurs during zipping, for example a file cannot be opened,
            skip the file causing the error, and continue zipping.  (For COM clients,
            this is a 1.)
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipErrorAction.Retry">
            <summary>
            When an error occurs during zipping, for example a file cannot be opened,
            retry the operation that caused the error. Be careful with this option. If
            the error is not temporary, the library will retry forever.  (For COM
            clients, this is a 2.)
            </summary>
        </member>
        <member name="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipErrorAction.InvokeErrorEvent">
            <summary>
            When an error occurs, invoke the zipError event.  The event type used is
            <see cref="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Error_Saving"/>.  A typical use of this option:
            a GUI application may wish to pop up a dialog to allow the user to view the
            error that occurred, and choose an appropriate action.  After your
            processing in the error event, if you want to skip the file, set <see
            cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.ZipErrorAction"/> on the
            <c>ZipProgressEventArgs.CurrentEntry</c> to <c>Skip</c>.  If you want the
            exception to be thrown, set <c>ZipErrorAction</c> on the <c>CurrentEntry</c>
            to <c>Throw</c>.  If you want to cancel the zip, set
            <c>ZipProgressEventArgs.Cancel</c> to true.  Cancelling differs from using
            Skip in that a cancel will not save any further entries, if there are any.
            (For COM clients, the value of this enum is a 3.)
            </summary>
        </member>
        <member name="T:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile">
             <summary>
               The ZipFile type represents a zip archive file.
             </summary>
            
             <remarks>
             <para>
               This is the main type in the DotNetZip class library. This class reads and
               writes zip files, as defined in the <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">specification
               for zip files described by PKWare</see>.  The compression for this
               implementation is provided by a managed-code version of Zlib, included with
               DotNetZip in the classes in the Ionic.Zlib namespace.
             </para>
            
             <para>
               This class provides a general purpose zip file capability.  Use it to read,
               create, or update zip files.  When you want to create zip files using a
               <c>Stream</c> type to write the zip file, you may want to consider the <see
               cref="T:OfficeOpenXml.Packaging.Ionic.Zip.ZipOutputStream"/> class.
             </para>
            
             <para>
               Both the <c>ZipOutputStream</c> class and the <c>ZipFile</c> class can
               be used to create zip files. Both of them support many of the common zip
               features, including Unicode, different compression methods and levels,
               and ZIP64. They provide very similar performance when creating zip
               files.
             </para>
            
             <para>
               The <c>ZipFile</c> class is generally easier to use than
               <c>ZipOutputStream</c> and should be considered a higher-level interface.  For
               example, when creating a zip file via calls to the <c>PutNextEntry()</c> and
               <c>Write()</c> methods on the <c>ZipOutputStream</c> class, the caller is
               responsible for opening the file, reading the bytes from the file, writing
               those bytes into the <c>ZipOutputStream</c>, setting the attributes on the
               <c>ZipEntry</c>, and setting the created, last modified, and last accessed
               timestamps on the zip entry. All of these things are done automatically by a
               call to <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddFile(System.String,System.String)">ZipFile.AddFile()</see>.
               For this reason, the <c>ZipOutputStream</c> is generally recommended for use
               only when your application emits arbitrary data, not necessarily data from a
               filesystem file, directly into a zip file, and does so using a <c>Stream</c>
               metaphor.
             </para>
            
             <para>
               Aside from the differences in programming model, there are other
               differences in capability between the two classes.
             </para>
            
             <list type="bullet">
               <item>
                 <c>ZipFile</c> can be used to read and extract zip files, in addition to
                 creating zip files. <c>ZipOutputStream</c> cannot read zip files. If you want
                 to use a stream to read zip files, check out the ZipInputStream class.
               </item>
            
               <item>
                 <c>ZipOutputStream</c> does not support the creation of segmented or spanned
                 zip files.
               </item>
            
               <item>
                 <c>ZipOutputStream</c> cannot produce a self-extracting archive.
               </item>
             </list>
            
             <para>
               Be aware that the <c>ZipFile</c> class implements the <see
               cref="T:System.IDisposable"/> interface.  In order for <c>ZipFile</c> to
               produce a valid zip file, you use use it within a using clause (<c>Using</c>
               in VB), or call the <c>Dispose()</c> method explicitly.  See the examples
               for how to employ a using clause.
             </para>
            
             </remarks>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddItem(System.String)">
             <summary>
               Adds an item, either a file or a directory, to a zip file archive.
             </summary>
            
             <remarks>
             <para>
               This method is handy if you are adding things to zip archive and don't
               want to bother distinguishing between directories or files.  Any files are
               added as single entries.  A directory added through this method is added
               recursively: all files and subdirectories contained within the directory
               are added to the <c>ZipFile</c>.
             </para>
            
             <para>
               The name of the item may be a relative path or a fully-qualified
               path. Remember, the items contained in <c>ZipFile</c> instance get written
               to the disk only when you call <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Save"/> or a similar
               save method.
             </para>
            
             <para>
               The directory name used for the file within the archive is the same
               as the directory name (potentially a relative path) specified in the
               <paramref name="fileOrDirectoryName"/>.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddFile(System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddDirectory(System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateItem(System.String)"/>
            
             <overloads>This method has two overloads.</overloads>
             <param name="fileOrDirectoryName">
             the name of the file or directory to add.</param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddItem(System.String,System.String)">
             <summary>
               Adds an item, either a file or a directory, to a zip file archive,
               explicitly specifying the directory path to be used in the archive.
             </summary>
            
             <remarks>
             <para>
               If adding a directory, the add is recursive on all files and
               subdirectories contained within it.
             </para>
             <para>
               The name of the item may be a relative path or a fully-qualified path.
               The item added by this call to the <c>ZipFile</c> is not read from the
               disk nor written to the zip file archive until the application calls
               Save() on the <c>ZipFile</c>.
             </para>
            
             <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used in the archive, which would override the
               "natural" path of the filesystem file.
             </para>
            
             <para>
               Encryption will be used on the file data if the <c>Password</c> has
               been set on the <c>ZipFile</c> object, prior to calling this method.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <exception cref="T:System.IO.FileNotFoundException">
               Thrown if the file or directory passed in does not exist.
             </exception>
            
             <param name="fileOrDirectoryName">the name of the file or directory to add.
             </param>
            
             <param name="directoryPathInArchive">
               The name of the directory path to use within the zip archive.  This path
               need not refer to an extant directory in the current filesystem.  If the
               files within the zip are later extracted, this is the path used for the
               extracted file.  Passing <c>null</c> (<c>Nothing</c> in VB) will use the
               path on the fileOrDirectoryName.  Passing the empty string ("") will
               insert the item at the root path within the archive.
             </param>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddFile(System.String,System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)"/>
            
             <example>
               This example shows how to zip up a set of files into a flat hierarchy,
               regardless of where in the filesystem the files originated. The resulting
               zip archive will contain a toplevel directory named "flat", which itself
               will contain files Readme.txt, MyProposal.docx, and Image1.jpg.  A
               subdirectory under "flat" called SupportFiles will contain all the files
               in the "c:\SupportFiles" directory on disk.
            
             <code>
             String[] itemnames= {
               "c:\\fixedContent\\Readme.txt",
               "MyProposal.docx",
               "c:\\SupportFiles",  // a directory
               "images\\Image1.jpg"
             };
            
             try
             {
               using (ZipFile zip = new ZipFile())
               {
                 for (int i = 1; i &lt; itemnames.Length; i++)
                 {
                   // will add Files or Dirs, recurses and flattens subdirectories
                   zip.AddItem(itemnames[i],"flat");
                 }
                 zip.Save(ZipToCreate);
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code>
            
             <code lang="VB">
               Dim itemnames As String() = _
                 New String() { "c:\fixedContent\Readme.txt", _
                                "MyProposal.docx", _
                                "SupportFiles", _
                                "images\Image1.jpg" }
               Try
                   Using zip As New ZipFile
                       Dim i As Integer
                       For i = 1 To itemnames.Length - 1
                           ' will add Files or Dirs, recursing and flattening subdirectories.
                           zip.AddItem(itemnames(i), "flat")
                       Next i
                       zip.Save(ZipToCreate)
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString())
               End Try
             </code>
             </example>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddFile(System.String)">
             <summary>
               Adds a File to a Zip file archive.
             </summary>
             <remarks>
            
             <para>
               This call collects metadata for the named file in the filesystem,
               including the file attributes and the timestamp, and inserts that metadata
               into the resulting ZipEntry.  Only when the application calls Save() on
               the <c>ZipFile</c>, does DotNetZip read the file from the filesystem and
               then write the content to the zip file archive.
             </para>
            
             <para>
               This method will throw an exception if an entry with the same name already
               exists in the <c>ZipFile</c>.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <example>
             <para>
               In this example, three files are added to a Zip archive. The ReadMe.txt
               file will be placed in the root of the archive. The .png file will be
               placed in a folder within the zip called photos\personal.  The pdf file
               will be included into a folder within the zip called Desktop.
             </para>
             <code>
                try
                {
                  using (ZipFile zip = new ZipFile())
                  {
                    zip.AddFile("c:\\photos\\personal\\7440-N49th.png");
                    zip.AddFile("c:\\Desktop\\2008-Regional-Sales-Report.pdf");
                    zip.AddFile("ReadMe.txt");
            
                    zip.Save("Package.zip");
                  }
                }
                catch (System.Exception ex1)
                {
                  System.Console.Error.WriteLine("exception: " + ex1);
                }
             </code>
            
             <code lang="VB">
              Try
                   Using zip As ZipFile = New ZipFile
                       zip.AddFile("c:\photos\personal\7440-N49th.png")
                       zip.AddFile("c:\Desktop\2008-Regional-Sales-Report.pdf")
                       zip.AddFile("ReadMe.txt")
                       zip.Save("Package.zip")
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString)
               End Try
             </code>
             </example>
            
             <overloads>This method has two overloads.</overloads>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddItem(System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddDirectory(System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateFile(System.String)"/>
            
             <param name="fileName">
               The name of the file to add. It should refer to a file in the filesystem.
               The name of the file may be a relative path or a fully-qualified path.
             </param>
             <returns>The <c>ZipEntry</c> corresponding to the File added.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddFile(System.String,System.String)">
             <summary>
               Adds a File to a Zip file archive, potentially overriding the path to be
               used within the zip archive.
             </summary>
            
             <remarks>
             <para>
               The file added by this call to the <c>ZipFile</c> is not written to the
               zip file archive until the application calls Save() on the <c>ZipFile</c>.
             </para>
            
             <para>
               This method will throw an exception if an entry with the same name already
               exists in the <c>ZipFile</c>.
             </para>
            
             <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used in the archive.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <example>
             <para>
               In this example, three files are added to a Zip archive. The ReadMe.txt
               file will be placed in the root of the archive. The .png file will be
               placed in a folder within the zip called images.  The pdf file will be
               included into a folder within the zip called files\docs, and will be
               encrypted with the given password.
             </para>
             <code>
             try
             {
               using (ZipFile zip = new ZipFile())
               {
                 // the following entry will be inserted at the root in the archive.
                 zip.AddFile("c:\\datafiles\\ReadMe.txt", "");
                 // this image file will be inserted into the "images" directory in the archive.
                 zip.AddFile("c:\\photos\\personal\\7440-N49th.png", "images");
                 // the following will result in a password-protected file called
                 // files\\docs\\2008-Regional-Sales-Report.pdf  in the archive.
                 zip.Password = "EncryptMe!";
                 zip.AddFile("c:\\Desktop\\2008-Regional-Sales-Report.pdf", "files\\docs");
                 zip.Save("Archive.zip");
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code>
            
             <code lang="VB">
               Try
                   Using zip As ZipFile = New ZipFile
                       ' the following entry will be inserted at the root in the archive.
                       zip.AddFile("c:\datafiles\ReadMe.txt", "")
                       ' this image file will be inserted into the "images" directory in the archive.
                       zip.AddFile("c:\photos\personal\7440-N49th.png", "images")
                       ' the following will result in a password-protected file called
                       ' files\\docs\\2008-Regional-Sales-Report.pdf  in the archive.
                       zip.Password = "EncryptMe!"
                       zip.AddFile("c:\Desktop\2008-Regional-Sales-Report.pdf", "files\documents")
                       zip.Save("Archive.zip")
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1)
               End Try
             </code>
             </example>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddItem(System.String,System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)"/>
            
             <param name="fileName">
               The name of the file to add.  The name of the file may be a relative path
               or a fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the fileName.
               This path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on the fileName, if any.  Passing the empty string
               ("") will insert the item at the root path within the archive.
             </param>
            
             <returns>The <c>ZipEntry</c> corresponding to the file added.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.RemoveEntries(System.Collections.Generic.ICollection{OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry})">
             <summary>
               This method removes a collection of entries from the <c>ZipFile</c>.
             </summary>
            
             <param name="entriesToRemove">
               A collection of ZipEntry instances from this zip file to be removed. For
               example, you can pass in an array of ZipEntry instances; or you can call
               SelectEntries(), and then add or remove entries from that
               ICollection&lt;ZipEntry&gt; (ICollection(Of ZipEntry) in VB), and pass
               that ICollection to this method.
             </param>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SelectEntries(System.String)" />
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)" />
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.RemoveEntries(System.Collections.Generic.ICollection{System.String})">
             <summary>
               This method removes a collection of entries from the <c>ZipFile</c>, by name.
             </summary>
            
             <param name="entriesToRemove">
               A collection of strings that refer to names of entries to be removed
               from the <c>ZipFile</c>.  For example, you can pass in an array or a
               List of Strings that provide the names of entries to be removed.
             </param>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SelectEntries(System.String)" />
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.RemoveSelectedEntries(System.String)" />
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddFiles(System.Collections.Generic.IEnumerable{System.String})">
             <summary>
               This method adds a set of files to the <c>ZipFile</c>.
             </summary>
            
             <remarks>
             <para>
               Use this method to add a set of files to the zip archive, in one call.
               For example, a list of files received from
               <c>System.IO.Directory.GetFiles()</c> can be added to a zip archive in one
               call.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
             </remarks>
            
             <param name="fileNames">
               The collection of names of the files to add. Each string should refer to a
               file in the filesystem. The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <example>
               This example shows how to create a zip file, and add a few files into it.
             <code>
             String ZipFileToCreate = "archive1.zip";
             String DirectoryToZip = "c:\\reports";
             using (ZipFile zip = new ZipFile())
             {
               // Store all files found in the top level directory, into the zip archive.
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               zip.AddFiles(filenames);
               zip.Save(ZipFileToCreate);
             }
             </code>
            
             <code lang="VB">
             Dim ZipFileToCreate As String = "archive1.zip"
             Dim DirectoryToZip As String = "c:\reports"
             Using zip As ZipFile = New ZipFile
                 ' Store all files found in the top level directory, into the zip archive.
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 zip.AddFiles(filenames)
                 zip.Save(ZipFileToCreate)
             End Using
             </code>
             </example>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateFiles(System.Collections.Generic.IEnumerable{System.String})">
             <summary>
               Adds or updates a set of files in the <c>ZipFile</c>.
             </summary>
            
             <remarks>
             <para>
               Any files that already exist in the archive are updated. Any files that
               don't yet exist in the archive are added.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
             </remarks>
            
             <param name="fileNames">
               The collection of names of the files to update. Each string should refer to a file in
               the filesystem. The name of the file may be a relative path or a fully-qualified path.
             </param>
            
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddFiles(System.Collections.Generic.IEnumerable{System.String},System.String)">
             <summary>
               Adds a set of files to the <c>ZipFile</c>, using the
               specified directory path in the archive.
             </summary>
            
             <remarks>
             <para>
               Any directory structure that may be present in the
               filenames contained in the list is "flattened" in the
               archive.  Each file in the list is added to the archive in
               the specified top-level directory.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel"/>, their respective values at the
               time of this call will be applied to each ZipEntry added.
             </para>
             </remarks>
            
             <param name="fileNames">
               The names of the files to add. Each string should refer to
               a file in the filesystem.  The name of the file may be a
               relative path or a fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the file name.
               Th is path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
               the empty string ("") will insert the item at the root path within the
               archive.
             </param>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddFiles(System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.String)">
             <summary>
               Adds a set of files to the <c>ZipFile</c>, using the specified directory
               path in the archive, and preserving the full directory structure in the
               filenames.
             </summary>
            
             <remarks>
            
             <para>
               Think of the <paramref name="directoryPathInArchive"/> as a "root" or
               base directory used in the archive for the files that get added.  when
               <paramref name="preserveDirHierarchy"/> is true, the hierarchy of files
               found in the filesystem will be placed, with the hierarchy intact,
               starting at that root in the archive. When <c>preserveDirHierarchy</c>
               is false, the path hierarchy of files is flattned, and the flattened
               set of files gets placed in the root within the archive as specified in
               <c>directoryPathInArchive</c>.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
            
             </remarks>
            
             <param name="fileNames">
               The names of the files to add. Each string should refer to a file in the
               filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use as a prefix for each entry name.
               This path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
               the empty string ("") will insert the item at the root path within the
               archive.
             </param>
            
             <param name="preserveDirHierarchy">
               whether the entries in the zip archive will reflect the directory
               hierarchy that is present in the various filenames.  For example, if
               <paramref name="fileNames"/> includes two paths,
               \Animalia\Chordata\Mammalia\Info.txt and
               \Plantae\Magnoliophyta\Dicotyledon\Info.txt, then calling this method
               with <paramref name="preserveDirHierarchy"/> = <c>false</c> will
               result in an exception because of a duplicate entry name, while
               calling this method with <paramref name="preserveDirHierarchy"/> =
               <c>true</c> will result in the full direcory paths being included in
               the entries added to the ZipFile.
             </param>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateFiles(System.Collections.Generic.IEnumerable{System.String},System.String)">
             <summary>
               Adds or updates a set of files to the <c>ZipFile</c>, using the specified
               directory path in the archive.
             </summary>
            
             <remarks>
            
             <para>
               Any files that already exist in the archive are updated. Any files that
               don't yet exist in the archive are added.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
             </remarks>
            
             <param name="fileNames">
               The names of the files to add or update. Each string should refer to a
               file in the filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the file name.
               This path may, or may not, correspond to a real directory in the current
               filesystem.  If the files within the zip are later extracted, this is the
               path used for the extracted file.  Passing <c>null</c> (<c>Nothing</c> in
               VB) will use the path on each of the <c>fileNames</c>, if any.  Passing
               the empty string ("") will insert the item at the root path within the
               archive.
             </param>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddSelectedFiles(System.String,System.String)" />
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateFile(System.String)">
             <summary>
               Adds or Updates a File in a Zip file archive.
             </summary>
            
             <remarks>
             <para>
               This method adds a file to a zip archive, or, if the file already exists
               in the zip archive, this method Updates the content of that given filename
               in the zip archive.  The <c>UpdateFile</c> method might more accurately be
               called "AddOrUpdateFile".
             </para>
            
             <para>
               Upon success, there is no way for the application to learn whether the file
               was added versus updated.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
             </remarks>
            
             <example>
            
               This example shows how to Update an existing entry in a zipfile. The first
               call to UpdateFile adds the file to the newly-created zip archive.  The
               second call to UpdateFile updates the content for that file in the zip
               archive.
            
             <code>
             using (ZipFile zip1 = new ZipFile())
             {
               // UpdateFile might more accurately be called "AddOrUpdateFile"
               zip1.UpdateFile("MyDocuments\\Readme.txt");
               zip1.UpdateFile("CustomerList.csv");
               zip1.Comment = "This zip archive has been created.";
               zip1.Save("Content.zip");
             }
            
             using (ZipFile zip2 = ZipFile.Read("Content.zip"))
             {
               zip2.UpdateFile("Updates\\Readme.txt");
               zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed.";
               zip2.Save();
             }
            
             </code>
             <code lang="VB">
               Using zip1 As New ZipFile
                   ' UpdateFile might more accurately be called "AddOrUpdateFile"
                   zip1.UpdateFile("MyDocuments\Readme.txt")
                   zip1.UpdateFile("CustomerList.csv")
                   zip1.Comment = "This zip archive has been created."
                   zip1.Save("Content.zip")
               End Using
            
               Using zip2 As ZipFile = ZipFile.Read("Content.zip")
                   zip2.UpdateFile("Updates\Readme.txt")
                   zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed."
                   zip2.Save
               End Using
             </code>
             </example>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddFile(System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateDirectory(System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateItem(System.String)"/>
            
             <param name="fileName">
               The name of the file to add or update. It should refer to a file in the
               filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <returns>
               The <c>ZipEntry</c> corresponding to the File that was added or updated.
             </returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)">
             <summary>
               Adds or Updates a File in a Zip file archive.
             </summary>
            
             <remarks>
             <para>
               This method adds a file to a zip archive, or, if the file already exists
               in the zip archive, this method Updates the content of that given filename
               in the zip archive.
             </para>
            
             <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used in the archive.  The entry to be added or
               updated is found by using the specified directory path, combined with the
               basename of the specified filename.
             </para>
            
             <para>
               Upon success, there is no way for the application to learn if the file was
               added versus updated.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
             </remarks>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddFile(System.String,System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)"/>
            
             <param name="fileName">
               The name of the file to add or update. It should refer to a file in the
               filesystem.  The name of the file may be a relative path or a
               fully-qualified path.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               <c>fileName</c>.  This path may, or may not, correspond to a real
               directory in the current filesystem.  If the files within the zip are
               later extracted, this is the path used for the extracted file.  Passing
               <c>null</c> (<c>Nothing</c> in VB) will use the path on the
               <c>fileName</c>, if any.  Passing the empty string ("") will insert the
               item at the root path within the archive.
             </param>
            
             <returns>
               The <c>ZipEntry</c> corresponding to the File that was added or updated.
             </returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateDirectory(System.String)">
             <summary>
               Add or update a directory in a zip archive.
             </summary>
            
             <remarks>
               If the specified directory does not exist in the archive, then this method
               is equivalent to calling <c>AddDirectory()</c>.  If the specified
               directory already exists in the archive, then this method updates any
               existing entries, and adds any new entries. Any entries that are in the
               zip archive but not in the specified directory, are left alone.  In other
               words, the contents of the zip file will be a union of the previous
               contents and the new files.
             </remarks>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateFile(System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddDirectory(System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateItem(System.String)"/>
            
             <param name="directoryName">
               The path to the directory to be added to the zip archive, or updated in
               the zip archive.
             </param>
            
             <returns>
             The <c>ZipEntry</c> corresponding to the Directory that was added or updated.
             </returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)">
             <summary>
               Add or update a directory in the zip archive at the specified root
               directory in the archive.
             </summary>
            
             <remarks>
               If the specified directory does not exist in the archive, then this method
               is equivalent to calling <c>AddDirectory()</c>.  If the specified
               directory already exists in the archive, then this method updates any
               existing entries, and adds any new entries. Any entries that are in the
               zip archive but not in the specified directory, are left alone.  In other
               words, the contents of the zip file will be a union of the previous
               contents and the new files.
             </remarks>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)"/>
            
             <param name="directoryName">
               The path to the directory to be added to the zip archive, or updated
               in the zip archive.
             </param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               <c>directoryName</c>.  This path may, or may not, correspond to a real
               directory in the current filesystem.  If the files within the zip are
               later extracted, this is the path used for the extracted file.  Passing
               <c>null</c> (<c>Nothing</c> in VB) will use the path on the
               <c>directoryName</c>, if any.  Passing the empty string ("") will insert
               the item at the root path within the archive.
             </param>
            
             <returns>
               The <c>ZipEntry</c> corresponding to the Directory that was added or updated.
             </returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateItem(System.String)">
             <summary>
               Add or update a file or directory in the zip archive.
             </summary>
            
             <remarks>
             <para>
               This is useful when the application is not sure or does not care if the
               item to be added is a file or directory, and does not know or does not
               care if the item already exists in the <c>ZipFile</c>. Calling this method
               is equivalent to calling <c>RemoveEntry()</c> if an entry by the same name
               already exists, followed calling by <c>AddItem()</c>.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
             </remarks>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddItem(System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateFile(System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateDirectory(System.String)"/>
            
             <param name="itemName">
              the path to the file or directory to be added or updated.
             </param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)">
             <summary>
               Add or update a file or directory.
             </summary>
            
             <remarks>
             <para>
               This method is useful when the application is not sure or does not care if
               the item to be added is a file or directory, and does not know or does not
               care if the item already exists in the <c>ZipFile</c>. Calling this method
               is equivalent to calling <c>RemoveEntry()</c>, if an entry by that name
               exists, and then calling <c>AddItem()</c>.
             </para>
            
             <para>
               This version of the method allows the caller to explicitly specify the
               directory path to be used for the item being added to the archive.  The
               entry or entries that are added or updated will use the specified
               <c>DirectoryPathInArchive</c>. Extracting the entry from the archive will
               result in a file stored in that directory path.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
             </remarks>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddItem(System.String,System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)"/>
            
             <param name="itemName">
               The path for the File or Directory to be added or updated.
             </param>
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               <c>itemName</c>.  This path may, or may not, correspond to a real
               directory in the current filesystem.  If the files within the zip are
               later extracted, this is the path used for the extracted file.  Passing
               <c>null</c> (<c>Nothing</c> in VB) will use the path on the
               <c>itemName</c>, if any.  Passing the empty string ("") will insert the
               item at the root path within the archive.
             </param>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,System.String)">
             <summary>
               Adds a named entry into the zip archive, taking content for the entry
               from a string.
             </summary>
            
             <remarks>
               Calling this method creates an entry using the given fileName and
               directory path within the archive.  There is no need for a file by the
               given name to exist in the filesystem; the name is used within the zip
               archive only. The content for the entry is encoded using the default text
               encoding for the machine, or on Silverlight, using UTF-8.
             </remarks>
            
             <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            
             <param name="entryName">
               The name, including any path, to use for the entry within the archive.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
             <example>
            
             This example shows how to add an entry to the zipfile, using a string as
             content for that entry.
            
             <code lang="C#">
             string Content = "This string will be the content of the Readme.txt file in the zip archive.";
             using (ZipFile zip1 = new ZipFile())
             {
               zip1.AddFile("MyDocuments\\Resume.doc", "files");
               zip1.AddEntry("Readme.txt", Content);
               zip1.Comment = "This zip file was created at " + System.DateTime.Now.ToString("G");
               zip1.Save("Content.zip");
             }
            
             </code>
             <code lang="VB">
             Public Sub Run()
               Dim Content As String = "This string will be the content of the Readme.txt file in the zip archive."
               Using zip1 As ZipFile = New ZipFile
                 zip1.AddEntry("Readme.txt", Content)
                 zip1.AddFile("MyDocuments\Resume.doc", "files")
                 zip1.Comment = ("This zip file was created at " &amp; DateTime.Now.ToString("G"))
                 zip1.Save("Content.zip")
               End Using
             End Sub
             </code>
             </example>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.Text.Encoding)">
             <summary>
               Adds a named entry into the zip archive, taking content for the entry
               from a string, and using the specified text encoding.
             </summary>
            
             <remarks>
            
             <para>
               Calling this method creates an entry using the given fileName and
               directory path within the archive.  There is no need for a file by the
               given name to exist in the filesystem; the name is used within the zip
               archive only.
             </para>
            
             <para>
               The content for the entry, a string value, is encoded using the given
               text encoding. A BOM (byte-order-mark) is emitted into the file, if the
               Encoding parameter is set for that.
             </para>
            
             <para>
               Most Encoding classes support a constructor that accepts a boolean,
               indicating whether to emit a BOM or not. For example see <see
               cref="M:System.Text.UTF8Encoding.#ctor(System.Boolean)"/>.
             </para>
            
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            
             <param name="encoding">
               The text encoding to use when encoding the string. Be aware: This is
               distinct from the text encoding used to encode the fileName, as specified
               in <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)">
             <summary>
               Create an entry in the <c>ZipFile</c> using the given <c>Stream</c>
               as input.  The entry will have the given filename.
             </summary>
            
             <remarks>
            
             <para>
               The application should provide an open, readable stream; in this case it
               will be read during the call to <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Save"/> or one of
               its overloads.
             </para>
            
             <para>
               The passed stream will be read from its current position. If
               necessary, callers should set the position in the stream before
               calling AddEntry(). This might be appropriate when using this method
               with a MemoryStream, for example.
             </para>
            
             <para>
               In cases where a large number of streams will be added to the
               <c>ZipFile</c>, the application may wish to avoid maintaining all of the
               streams open simultaneously.  To handle this situation, the application
               should use the <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,OfficeOpenXml.Packaging.Ionic.Zip.OpenDelegate,OfficeOpenXml.Packaging.Ionic.Zip.CloseDelegate)"/>
               overload.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <example>
             <para>
               This example adds a single entry to a <c>ZipFile</c> via a <c>Stream</c>.
             </para>
            
             <code lang="C#">
             String zipToCreate = "Content.zip";
             String fileNameInArchive = "Content-From-Stream.bin";
             using (System.IO.Stream streamToRead = MyStreamOpener())
             {
               using (ZipFile zip = new ZipFile())
               {
                 ZipEntry entry= zip.AddEntry(fileNameInArchive, streamToRead);
                 zip.AddFile("Readme.txt");
                 zip.Save(zipToCreate);  // the stream is read implicitly here
               }
             }
             </code>
            
             <code lang="VB">
             Dim zipToCreate As String = "Content.zip"
             Dim fileNameInArchive As String = "Content-From-Stream.bin"
             Using streamToRead as System.IO.Stream = MyStreamOpener()
               Using zip As ZipFile = New ZipFile()
                 Dim entry as ZipEntry = zip.AddEntry(fileNameInArchive, streamToRead)
                 zip.AddFile("Readme.txt")
                 zip.Save(zipToCreate)  '' the stream is read implicitly, here
               End Using
             End Using
             </code>
             </example>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateEntry(System.String,System.IO.Stream)"/>
            
             <param name="entryName">
               The name, including any path, which is shown in the zip file for the added
               entry.
             </param>
             <param name="stream">
               The input stream from which to grab content for the file
             </param>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,OfficeOpenXml.Packaging.Ionic.Zip.WriteDelegate)">
             <summary>
               Add a ZipEntry for which content is written directly by the application.
             </summary>
            
             <remarks>
             <para>
               When the application needs to write the zip entry data, use this
               method to add the ZipEntry. For example, in the case that the
               application wishes to write the XML representation of a DataSet into
               a ZipEntry, the application can use this method to do so.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             <para>
               About progress events: When using the WriteDelegate, DotNetZip does
               not issue any SaveProgress events with <c>EventType</c> = <see
               cref="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Saving_EntryBytesRead">
               Saving_EntryBytesRead</see>. (This is because it is the
               application's code that runs in WriteDelegate - there's no way for
               DotNetZip to know when to issue a EntryBytesRead event.)
               Applications that want to update a progress bar or similar status
               indicator should do so from within the WriteDelegate
               itself. DotNetZip will issue the other SaveProgress events,
               including <see cref="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Saving_Started">
               Saving_Started</see>,
               <see cref="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry">
               Saving_BeforeWriteEntry</see>, and <see
               cref="F:OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry">
               Saving_AfterWriteEntry</see>.
             </para>
            
             <para>
               Note: When you use PKZip encryption, it's normally necessary to
               compute the CRC of the content to be encrypted, before compressing or
               encrypting it. Therefore, when using PKZip encryption with a
               WriteDelegate, the WriteDelegate CAN BE called twice: once to compute
               the CRC, and the second time to potentially compress and
               encrypt. Surprising, but true. This is because PKWARE specified that
               the encryption initialization data depends on the CRC.
               If this happens, for each call of the delegate, your
               application must stream the same entry data in its entirety. If your
               application writes different data during the second call, it will
               result in a corrupt zip file.
             </para>
            
             <para>
               The double-read behavior happens with all types of entries, not only
               those that use WriteDelegate. It happens if you add an entry from a
               filesystem file, or using a string, or a stream, or an opener/closer
               pair. But in those cases, DotNetZip takes care of reading twice; in
               the case of the WriteDelegate, the application code gets invoked
               twice. Be aware.
             </para>
            
             <para>
               As you can imagine, this can cause performance problems for large
               streams, and it can lead to correctness problems when you use a
               <c>WriteDelegate</c>. This is a pretty big pitfall.  There are two
               ways to avoid it.  First, and most preferred: don't use PKZIP
               encryption.  If you use the WinZip AES encryption, this problem
               doesn't occur, because the encryption protocol doesn't require the CRC
               up front. Second: if you do choose to use PKZIP encryption, write out
               to a non-seekable stream (like standard output, or the
               Response.OutputStream in an ASP.NET application).  In this case,
               DotNetZip will use an alternative encryption protocol that does not
               rely on the CRC of the content.  This also implies setting bit 3 in
               the zip entry, which still presents problems for some zip tools.
             </para>
            
             <para>
               In the future I may modify DotNetZip to *always* use bit 3 when PKZIP
               encryption is in use.  This seems like a win overall, but there will
               be some work involved.  If you feel strongly about it, visit the
               DotNetZip forums and vote up <see
               href="http://dotnetzip.codeplex.com/workitem/13686">the Workitem
               tracking this issue</see>.
             </para>
            
             </remarks>
            
             <param name="entryName">the name of the entry to add</param>
             <param name="writer">the delegate which will write the entry content</param>
             <returns>the ZipEntry added</returns>
            
             <example>
            
               This example shows an application filling a DataSet, then saving the
               contents of that DataSet as XML, into a ZipEntry in a ZipFile, using an
               anonymous delegate in C#. The DataSet XML is never saved to a disk file.
            
             <code lang="C#">
             var c1= new System.Data.SqlClient.SqlConnection(connstring1);
             var da = new System.Data.SqlClient.SqlDataAdapter()
                 {
                     SelectCommand=  new System.Data.SqlClient.SqlCommand(strSelect, c1)
                 };
            
             DataSet ds1 = new DataSet();
             da.Fill(ds1, "Invoices");
            
             using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
             {
                 zip.AddEntry(zipEntryName, (name,stream) => ds1.WriteXml(stream) );
                 zip.Save(zipFileName);
             }
             </code>
             </example>
            
             <example>
            
             This example uses an anonymous method in C# as the WriteDelegate to provide
             the data for the ZipEntry. The example is a bit contrived - the
             <c>AddFile()</c> method is a simpler way to insert the contents of a file
             into an entry in a zip file. On the other hand, if there is some sort of
             processing or transformation of the file contents required before writing,
             the application could use the <c>WriteDelegate</c> to do it, in this way.
            
             <code lang="C#">
             using (var input = File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite ))
             {
                 using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
                 {
                     zip.AddEntry(zipEntryName, (name,output) =>
                         {
                             byte[] buffer = new byte[BufferSize];
                             int n;
                             while ((n = input.Read(buffer, 0, buffer.Length)) != 0)
                             {
                                 // could transform the data here...
                                 output.Write(buffer, 0, n);
                                 // could update a progress bar here
                             }
                         });
            
                     zip.Save(zipFileName);
                 }
             }
             </code>
             </example>
            
             <example>
            
             This example uses a named delegate in VB to write data for the given
             ZipEntry (VB9 does not have anonymous delegates). The example here is a bit
             contrived - a simpler way to add the contents of a file to a ZipEntry is to
             simply use the appropriate <c>AddFile()</c> method.  The key scenario for
             which the <c>WriteDelegate</c> makes sense is saving a DataSet, in XML
             format, to the zip file. The DataSet can write XML to a stream, and the
             WriteDelegate is the perfect place to write into the zip file.  There may be
             other data structures that can write to a stream, but cannot be read as a
             stream.  The <c>WriteDelegate</c> would be appropriate for those cases as
             well.
            
             <code lang="VB">
             Private Sub WriteEntry (ByVal name As String, ByVal output As Stream)
                 Using input As FileStream = File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
                     Dim n As Integer = -1
                     Dim buffer As Byte() = New Byte(BufferSize){}
                     Do While n &lt;&gt; 0
                         n = input.Read(buffer, 0, buffer.Length)
                         output.Write(buffer, 0, n)
                     Loop
                 End Using
             End Sub
            
             Public Sub Run()
                 Using zip = New ZipFile
                     zip.AddEntry(zipEntryName, New WriteDelegate(AddressOf WriteEntry))
                     zip.Save(zipFileName)
                 End Using
             End Sub
             </code>
             </example>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,OfficeOpenXml.Packaging.Ionic.Zip.OpenDelegate,OfficeOpenXml.Packaging.Ionic.Zip.CloseDelegate)">
             <summary>
               Add an entry, for which the application will provide a stream
               containing the entry data, on a just-in-time basis.
             </summary>
            
             <remarks>
             <para>
               In cases where the application wishes to open the stream that
               holds the content for the ZipEntry, on a just-in-time basis, the
               application can use this method.  The application provides an
               opener delegate that will be called by the DotNetZip library to
               obtain a readable stream that can be read to get the bytes for
               the given entry.  Typically, this delegate opens a stream.
               Optionally, the application can provide a closer delegate as
               well, which will be called by DotNetZip when all bytes have been
               read from the entry.
             </para>
            
             <para>
               These delegates are called from within the scope of the call to
               ZipFile.Save().
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <example>
            
               This example uses anonymous methods in C# to open and close the
               source stream for the content for a zip entry.
            
             <code lang="C#">
             using(Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
             {
                 zip.AddEntry(zipEntryName,
                              (name) =>  File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite ),
                              (name, stream) =>  stream.Close()
                              );
            
                 zip.Save(zipFileName);
             }
             </code>
            
             </example>
            
             <example>
            
               This example uses delegates in VB.NET to open and close the
               the source stream for the content for a zip entry.  VB 9.0 lacks
               support for "Sub" lambda expressions, and so the CloseDelegate must
               be an actual, named Sub.
            
             <code lang="VB">
            
             Function MyStreamOpener(ByVal entryName As String) As Stream
                 '' This simply opens a file.  You probably want to do somethinig
                 '' more involved here: open a stream to read from a database,
                 '' open a stream on an HTTP connection, and so on.
                 Return File.OpenRead(entryName)
             End Function
            
             Sub MyStreamCloser(entryName As String, stream As Stream)
                 stream.Close()
             End Sub
            
             Public Sub Run()
                 Dim dirToZip As String = "fodder"
                 Dim zipFileToCreate As String = "Archive.zip"
                 Dim opener As OpenDelegate = AddressOf MyStreamOpener
                 Dim closer As CloseDelegate = AddressOf MyStreamCloser
                 Dim numFilestoAdd As Int32 = 4
                 Using zip As ZipFile = New ZipFile
                     Dim i As Integer
                     For i = 0 To numFilesToAdd - 1
                         zip.AddEntry(String.Format("content-{0:000}.txt"), opener, closer)
                     Next i
                     zip.Save(zipFileToCreate)
                 End Using
             End Sub
            
             </code>
             </example>
            
             <param name="entryName">the name of the entry to add</param>
             <param name="opener">
              the delegate that will be invoked by ZipFile.Save() to get the
              readable stream for the given entry. ZipFile.Save() will call
              read on this stream to obtain the data for the entry. This data
              will then be compressed and written to the newly created zip
              file.
             </param>
             <param name="closer">
              the delegate that will be invoked to close the stream. This may
              be null (Nothing in VB), in which case no call is makde to close
              the stream.
             </param>
             <returns>the ZipEntry added</returns>
            
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateEntry(System.String,System.String)">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given
               string as content for the <c>ZipEntry</c>.
             </summary>
            
             <remarks>
            
             <para>
               Calling this method is equivalent to removing the <c>ZipEntry</c> for
               the given file name and directory path, if it exists, and then calling
               <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,System.String)" />.  See the documentation for
               that method for further explanation. The string content is encoded
               using the default encoding for the machine, or on Silverlight, using
               UTF-8. This encoding is distinct from the encoding used for the
               filename itself.  See <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AlternateEncoding"/>.
             </para>
            
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateEntry(System.String,System.String,System.Text.Encoding)">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given string as
               content for the <c>ZipEntry</c>.
             </summary>
            
             <remarks>
               Calling this method is equivalent to removing the <c>ZipEntry</c> for the
               given file name and directory path, if it exists, and then calling <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,System.String,System.Text.Encoding)" />.  See the
               documentation for that method for further explanation.
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="content">
               The content of the file, should it be extracted from the zip.
             </param>
            
             <param name="encoding">
               The text encoding to use when encoding the string. Be aware: This is
               distinct from the text encoding used to encode the filename. See <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AlternateEncoding" />.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateEntry(System.String,OfficeOpenXml.Packaging.Ionic.Zip.WriteDelegate)">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given delegate
               as the source for content for the <c>ZipEntry</c>.
             </summary>
            
             <remarks>
               Calling this method is equivalent to removing the <c>ZipEntry</c> for the
               given file name and directory path, if it exists, and then calling <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,OfficeOpenXml.Packaging.Ionic.Zip.WriteDelegate)" />.  See the
               documentation for that method for further explanation.
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="writer">the delegate which will write the entry content.</param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateEntry(System.String,OfficeOpenXml.Packaging.Ionic.Zip.OpenDelegate,OfficeOpenXml.Packaging.Ionic.Zip.CloseDelegate)">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given delegates
               to open and close the stream that provides the content for the <c>ZipEntry</c>.
             </summary>
            
             <remarks>
               Calling this method is equivalent to removing the <c>ZipEntry</c> for the
               given file name and directory path, if it exists, and then calling <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,OfficeOpenXml.Packaging.Ionic.Zip.OpenDelegate,OfficeOpenXml.Packaging.Ionic.Zip.CloseDelegate)" />.  See the
               documentation for that method for further explanation.
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="opener">
              the delegate that will be invoked to open the stream
             </param>
             <param name="closer">
              the delegate that will be invoked to close the stream
             </param>
            
             <returns>The <c>ZipEntry</c> added or updated.</returns>
            
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateEntry(System.String,System.IO.Stream)">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given stream as
               input, and the given filename and given directory Path.
             </summary>
            
             <remarks>
             <para>
               Calling the method is equivalent to calling <c>RemoveEntry()</c> if an
               entry by the same name already exists, and then calling <c>AddEntry()</c>
               with the given <c>fileName</c> and stream.
             </para>
            
             <para>
               The stream must be open and readable during the call to
               <c>ZipFile.Save</c>.  You can dispense the stream on a just-in-time basis
               using the <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.InputStream"/> property. Check the
               documentation of that property for more information.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to the
               <c>ZipEntry</c> added.
             </para>
            
             </remarks>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,System.IO.Stream)"/>
             <seealso cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry.InputStream"/>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="stream">The input stream from which to read file data.</param>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,System.Byte[])">
             <summary>
               Add an entry into the zip archive using the given filename and
               directory path within the archive, and the given content for the
               file. No file is created in the filesystem.
             </summary>
            
             <param name="byteContent">The data to use for the entry.</param>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateEntry(System.String,System.Byte[])">
             <summary>
               Updates the given entry in the <c>ZipFile</c>, using the given byte
               array as content for the entry.
             </summary>
            
             <remarks>
               Calling this method is equivalent to removing the <c>ZipEntry</c>
               for the given filename and directory path, if it exists, and then
               calling <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddEntry(System.String,System.Byte[])" />.  See the
               documentation for that method for further explanation.
             </remarks>
            
             <param name="entryName">
               The name, including any path, to use within the archive for the entry.
             </param>
            
             <param name="byteContent">The content to use for the <c>ZipEntry</c>.</param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
            
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddDirectory(System.String)">
             <summary>
               Adds the contents of a filesystem directory to a Zip file archive.
             </summary>
            
             <remarks>
            
             <para>
               The name of the directory may be a relative path or a fully-qualified
               path. Any files within the named directory are added to the archive.  Any
               subdirectories within the named directory are also added to the archive,
               recursively.
             </para>
            
             <para>
               Top-level entries in the named directory will appear as top-level entries
               in the zip archive.  Entries in subdirectories in the named directory will
               result in entries in subdirectories in the zip archive.
             </para>
            
             <para>
               If you want the entries to appear in a containing directory in the zip
               archive itself, then you should call the AddDirectory() overload that
               allows you to explicitly specify a directory path for use in the archive.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
            
             </remarks>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddItem(System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddFile(System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateDirectory(System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)"/>
            
             <overloads>This method has 2 overloads.</overloads>
            
             <param name="directoryName">The name of the directory to add.</param>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)">
             <summary>
               Adds the contents of a filesystem directory to a Zip file archive,
               overriding the path to be used for entries in the archive.
             </summary>
            
             <remarks>
             <para>
               The name of the directory may be a relative path or a fully-qualified
               path. The add operation is recursive, so that any files or subdirectories
               within the name directory are also added to the archive.
             </para>
            
             <para>
               Top-level entries in the named directory will appear as top-level entries
               in the zip archive.  Entries in subdirectories in the named directory will
               result in entries in subdirectories in the zip archive.
             </para>
            
             <para>
               For <c>ZipFile</c> properties including <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SetCompression"/>, <see
               cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ProvisionalAlternateEncoding"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ExtractExistingFile"/>,
               <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, and <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel"/>, their
               respective values at the time of this call will be applied to each
               ZipEntry added.
             </para>
            
             </remarks>
            
             <example>
             <para>
               In this code, calling the ZipUp() method with a value of "c:\reports" for
               the directory parameter will result in a zip file structure in which all
               entries are contained in a toplevel "reports" directory.
             </para>
            
             <code lang="C#">
             public void ZipUp(string targetZip, string directory)
             {
               using (var zip = new ZipFile())
               {
                 zip.AddDirectory(directory, System.IO.Path.GetFileName(directory));
                 zip.Save(targetZip);
               }
             }
             </code>
             </example>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddItem(System.String,System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddFile(System.String,System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)"/>
            
             <param name="directoryName">The name of the directory to add.</param>
            
             <param name="directoryPathInArchive">
               Specifies a directory path to use to override any path in the
               DirectoryName.  This path may, or may not, correspond to a real directory
               in the current filesystem.  If the zip is later extracted, this is the
               path used for the extracted file or directory.  Passing <c>null</c>
               (<c>Nothing</c> in VB) or the empty string ("") will insert the items at
               the root path within the archive.
             </param>
            
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddDirectoryByName(System.String)">
             <summary>
               Creates a directory in the zip archive.
             </summary>
            
             <remarks>
            
             <para>
               Use this when you want to create a directory in the archive but there is
               no corresponding filesystem representation for that directory.
             </para>
            
             <para>
               You will probably not need to do this in your code. One of the only times
               you will want to do this is if you want an empty directory in the zip
               archive.  The reason: if you add a file to a zip archive that is stored
               within a multi-level directory, all of the directory tree is implicitly
               created in the zip archive.
             </para>
            
             </remarks>
            
             <param name="directoryNameInArchive">
               The name of the directory to create in the archive.
             </param>
             <returns>The <c>ZipEntry</c> added.</returns>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CheckZip(System.String)">
             <summary>
               Checks a zip file to see if its directory is consistent.
             </summary>
            
             <remarks>
            
             <para>
               In cases of data error, the directory within a zip file can get out
               of synch with the entries in the zip file.  This method checks the
               given zip file and returns true if this has occurred.
             </para>
            
             <para> This method may take a long time to run for large zip files.  </para>
            
             <para>
               This method is not supported in the Reduced or Compact Framework
               versions of DotNetZip.
             </para>
            
             <para>
               Developers using COM can use the <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ComHelper.CheckZip(System.String)">ComHelper.CheckZip(String)</see>
               method.
             </para>
            
             </remarks>
            
             <param name="zipFileName">The filename to of the zip file to check.</param>
            
             <returns>true if the named zip file checks OK. Otherwise, false. </returns>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.FixZipDirectory(System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CheckZip(System.String,System.Boolean,System.IO.TextWriter)"/>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CheckZip(System.String,System.Boolean,System.IO.TextWriter)">
             <summary>
               Checks a zip file to see if its directory is consistent,
               and optionally fixes the directory if necessary.
             </summary>
            
             <remarks>
            
             <para>
               In cases of data error, the directory within a zip file can get out of
               synch with the entries in the zip file.  This method checks the given
               zip file, and returns true if this has occurred. It also optionally
               fixes the zipfile, saving the fixed copy in <em>Name</em>_Fixed.zip.
             </para>
            
             <para>
               This method may take a long time to run for large zip files.  It
               will take even longer if the file actually needs to be fixed, and if
               <c>fixIfNecessary</c> is true.
             </para>
            
             <para>
               This method is not supported in the Reduced or Compact
               Framework versions of DotNetZip.
             </para>
            
             </remarks>
            
             <param name="zipFileName">The filename to of the zip file to check.</param>
            
             <param name="fixIfNecessary">If true, the method will fix the zip file if
                 necessary.</param>
            
             <param name="writer">
             a TextWriter in which messages generated while checking will be written.
             </param>
            
             <returns>true if the named zip is OK; false if the file needs to be fixed.</returns>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CheckZip(System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.FixZipDirectory(System.String)"/>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.FixZipDirectory(System.String)">
             <summary>
               Rewrite the directory within a zipfile.
             </summary>
            
             <remarks>
            
             <para>
               In cases of data error, the directory in a zip file can get out of
               synch with the entries in the zip file.  This method attempts to fix
               the zip file if this has occurred.
             </para>
            
             <para> This can take a long time for large zip files. </para>
            
             <para> This won't work if the zip file uses a non-standard
             code page - neither IBM437 nor UTF-8. </para>
            
             <para>
               This method is not supported in the Reduced or Compact Framework
               versions of DotNetZip.
             </para>
            
             <para>
               Developers using COM can use the <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ComHelper.FixZipDirectory(System.String)">ComHelper.FixZipDirectory(String)</see>
               method.
             </para>
            
             </remarks>
            
             <param name="zipFileName">The filename to of the zip file to fix.</param>
            
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CheckZip(System.String)"/>
             <seealso cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CheckZip(System.String,System.Boolean,System.IO.TextWriter)"/>
        </member>
        <member name="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CheckZipPassword(System.String,System.String)">
             <summary>
               Verify the password on a zip file.
             </summary>
            
             <remarks>
               <para>
                 Keep in mind that passwords in zipfiles are applied to
                 zip entries, not to the entire zip file. So testing a
                 zipfile for a particular password doesn't work in the
                 general case. On the other hand, it's often the case
                 that a single password will be used on all entries in a
                 zip file. This method works for that case.
               </para>
               <para>
                 There is no way to check a password without doing the
                 decryption. So this code decrypts and extracts the given
                 zipfile into <see cref="F:System.IO.Stream.Null"/>
               </para>
             </remarks>
            
             <param name="zipFileName">The filename to of the zip file to fix.</param>
            
             <param name="password">The password to check.</param>
            
             <returns>a bool indicating whether the password matches.</returns>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Info">
             <summary>
               Provides a human-readable string with information about the ZipFile.
             </summary>
            
             <remarks>
               <para>
                 The information string contains 10 lines or so, about each ZipEntry,
                 describing whether encryption is in use, the compressed and uncompressed
                 length of the entry, the offset of the entry, and so on. As a result the
                 information string can be very long for zip files that contain many
                 entries.
               </para>
               <para>
                 This information is mostly useful for diagnostic purposes.
               </para>
             </remarks>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.FullScan">
             <summary>
             Indicates whether to perform a full scan of the zip file when reading it.
             </summary>
            
             <remarks>
            
             <para>
               You almost never want to use this property.
             </para>
            
             <para>
               When reading a zip file, if this flag is <c>true</c> (<c>True</c> in
               VB), the entire zip archive will be scanned and searched for entries.
               For large archives, this can take a very, long time. The much more
               efficient default behavior is to read the zip directory, which is
               stored at the end of the zip file. But, in some cases the directory is
               corrupted and you need to perform a full scan of the zip file to
               determine the contents of the zip file. This property lets you do
               that, when necessary.
             </para>
            
             <para>
               This flag is effective only when calling <see
               cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Initialize(System.String)"/>. Normally you would read a ZipFile with the
               static <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Read(System.String)">ZipFile.Read</see>
               method. But you can't set the <c>FullScan</c> property on the
               <c>ZipFile</c> instance when you use a static factory method like
               <c>ZipFile.Read</c>.
             </para>
            
             </remarks>
            
             <example>
            
               This example shows how to read a zip file using the full scan approach,
               and then save it, thereby producing a corrected zip file.
            
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 zip.FullScan = true;
                 zip.Initialize(zipFileName);
                 zip.Save(newName);
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 zip.FullScan = True
                 zip.Initialize(zipFileName)
                 zip.Save(newName)
             End Using
             </code>
             </example>
            
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.SortEntriesBeforeSaving">
             <summary>
               Whether to sort the ZipEntries before saving the file.
             </summary>
            
             <remarks>
               The default is false.  If you have a large number of zip entries, the sort
               alone can consume significant time.
             </remarks>
            
             <example>
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 zip.AddFiles(filesToAdd);
                 zip.SortEntriesBeforeSaving = true;
                 zip.Save(name);
             }
             </code>
            
             <code lang="VB">
             Using zip As New ZipFile
                 zip.AddFiles(filesToAdd)
                 zip.SortEntriesBeforeSaving = True
                 zip.Save(name)
             End Using
             </code>
             </example>
            
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.AddDirectoryWillTraverseReparsePoints">
             <summary>
               Indicates whether NTFS Reparse Points, like junctions, should be
               traversed during calls to <c>AddDirectory()</c>.
             </summary>
            
             <remarks>
               By default, calls to AddDirectory() will traverse NTFS reparse
               points, like mounted volumes, and directory junctions.  An example
               of a junction is the "My Music" directory in Windows Vista.  In some
               cases you may not want DotNetZip to traverse those directories.  In
               that case, set this property to false.
             </remarks>
            
             <example>
             <code lang="C#">
             using (var zip = new ZipFile())
             {
                 zip.AddDirectoryWillTraverseReparsePoints = false;
                 zip.AddDirectory(dirToZip,"fodder");
                 zip.Save(zipFileToCreate);
             }
             </code>
             </example>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.BufferSize">
             <summary>
               Size of the IO buffer used while saving.
             </summary>
            
             <remarks>
            
             <para>
               First, let me say that you really don't need to bother with this.  It is
               here to allow for optimizations that you probably won't make! It will work
               fine if you don't set or get this property at all. Ok?
             </para>
            
             <para>
               Now that we have <em>that</em> out of the way, the fine print: This
               property affects the size of the buffer that is used for I/O for each
               entry contained in the zip file. When a file is read in to be compressed,
               it uses a buffer given by the size here.  When you update a zip file, the
               data for unmodified entries is copied from the first zip file to the
               other, through a buffer given by the size here.
             </para>
            
             <para>
               Changing the buffer size affects a few things: first, for larger buffer
               sizes, the memory used by the <c>ZipFile</c>, obviously, will be larger
               during I/O operations.  This may make operations faster for very much
               larger files.  Last, for any given entry, when you use a larger buffer
               there will be fewer progress events during I/O operations, because there's
               one progress event generated for each time the buffer is filled and then
               emptied.
             </para>
            
             <para>
               The default buffer size is 8k.  Increasing the buffer size may speed
               things up as you compress larger files.  But there are no hard-and-fast
               rules here, eh?  You won't know til you test it.  And there will be a
               limit where ever larger buffers actually slow things down.  So as I said
               in the beginning, it's probably best if you don't set or get this property
               at all.
             </para>
            
             </remarks>
            
             <example>
             This example shows how you might set a large buffer size for efficiency when
             dealing with zip entries that are larger than 1gb.
             <code lang="C#">
             using (ZipFile zip = new ZipFile())
             {
                 zip.SaveProgress += this.zip1_SaveProgress;
                 zip.AddDirectory(directoryToZip, "");
                 zip.UseZip64WhenSaving = Zip64Option.Always;
                 zip.BufferSize = 65536*8; // 65536 * 8 = 512k
                 zip.Save(ZipFileToCreate);
             }
             </code>
             </example>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CodecBufferSize">
             <summary>
               Size of the work buffer to use for the ZLIB codec during compression.
             </summary>
            
             <remarks>
               <para>
                 When doing ZLIB or Deflate compression, the library fills a buffer,
                 then passes it to the compressor for compression. Then the library
                 reads out the compressed bytes. This happens repeatedly until there
                 is no more uncompressed data to compress. This property sets the
                 size of the buffer that will be used for chunk-wise compression. In
                 order for the setting to take effect, your application needs to set
                 this property before calling one of the <c>ZipFile.Save()</c>
                 overloads.
               </para>
               <para>
                 Setting this affects the performance and memory efficiency of
                 compression and decompression. For larger files, setting this to a
                 larger size may improve compression performance, but the exact
                 numbers vary depending on available memory, the size of the streams
                 you are compressing, and a bunch of other variables. I don't have
                 good firm recommendations on how to set it.  You'll have to test it
                 yourself. Or just leave it alone and accept the default.
               </para>
             </remarks>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.FlattenFoldersOnExtract">
             <summary>
               Indicates whether extracted files should keep their paths as
               stored in the zip archive.
             </summary>
            
             <remarks>
              <para>
                This property affects Extraction.  It is not used when creating zip
                archives.
              </para>
            
              <para>
                With this property set to <c>false</c>, the default, extracting entries
                from a zip file will create files in the filesystem that have the full
                path associated to the entry within the zip file.  With this property set
                to <c>true</c>, extracting entries from the zip file results in files
                with no path: the folders are "flattened."
              </para>
            
              <para>
                An example: suppose the zip file contains entries /directory1/file1.txt and
                /directory2/file2.txt.  With <c>FlattenFoldersOnExtract</c> set to false,
                the files created will be \directory1\file1.txt and \directory2\file2.txt.
                With the property set to true, the files created are file1.txt and file2.txt.
              </para>
            
             </remarks>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Strategy">
             <summary>
               The compression strategy to use for all entries.
             </summary>
            
             <remarks>
               Set the Strategy used by the ZLIB-compatible compressor, when
               compressing entries using the DEFLATE method. Different compression
               strategies work better on different sorts of data. The strategy
               parameter can affect the compression ratio and the speed of
               compression but not the correctness of the compresssion.  For more
               information see <see
               cref="T:OfficeOpenXml.Packaging.Ionic.Zlib.CompressionStrategy">Ionic.Zlib.CompressionStrategy</see>.
             </remarks>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Name">
             <summary>
               The name of the <c>ZipFile</c>, on disk.
             </summary>
            
             <remarks>
            
             <para>
               When the <c>ZipFile</c> instance was created by reading an archive using
               one of the <c>ZipFile.Read</c> methods, this property represents the name
               of the zip file that was read.  When the <c>ZipFile</c> instance was
               created by using the no-argument constructor, this value is <c>null</c>
               (<c>Nothing</c> in VB).
             </para>
            
             <para>
               If you use the no-argument constructor, and you then explicitly set this
               property, when you call <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Save"/>, this name will
               specify the name of the zip file created.  Doing so is equivalent to
               calling <see cref="M:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Save(System.String)"/>.  When instantiating a
               <c>ZipFile</c> by reading from a stream or byte array, the <c>Name</c>
               property remains <c>null</c>.  When saving to a stream, the <c>Name</c>
               property is implicitly set to <c>null</c>.
             </para>
             </remarks>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionLevel">
             <summary>
               Sets the compression level to be used for entries subsequently added to
               the zip archive.
             </summary>
            
             <remarks>
              <para>
                Varying the compression level used on entries can affect the
                size-vs-speed tradeoff when compression and decompressing data streams
                or files.
              </para>
            
              <para>
                As with some other properties on the <c>ZipFile</c> class, like <see
                cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Password"/>, <see cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Encryption"/>, and <see
                cref="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.ZipErrorAction"/>, setting this property on a <c>ZipFile</c>
                instance will cause the specified <c>CompressionLevel</c> to be used on all
                <see cref="T:OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry"/> items that are subsequently added to the
                <c>ZipFile</c> instance. If you set this property after you have added
                items to the <c>ZipFile</c>, but before you have called <c>Save()</c>,
                those items will not use the specified compression level.
              </para>
            
              <para>
                If you do not set this property, the default compression level is used,
                which normally gives a good balance of compression efficiency and
                compression speed.  In some tests, using <c>BestCompression</c> can
                double the time it takes to compress, while delivering just a small
                increase in compression efficiency.  This behavior will vary with the
                type of data you compress.  If you are in doubt, just leave this setting
                alone, and accept the default.
              </para>
             </remarks>
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.CompressionMethod">
            <summary>
              The compression method for the zipfile.
            </summary>
            <remarks>
              <para>
                By default, the compression method is <c>CompressionMethod.Deflate.</c>
              </para>
            </remarks>
            <seealso cref="T:OfficeOpenXml.Packaging.Ionic.Zip.CompressionMethod" />
        </member>
        <member name="P:OfficeOpenXml.Packaging.Ionic.Zip.ZipFile.Comment">
             <summary>
               A comment attached to the zip archive.
             </summary>
            
             <remarks>
            
             <para>
               This property is read/write. It allows the application to specify a
               comment for the <c>ZipFile</c>, or read the comment for the
               <c>ZipFile</c>.  After setting this property, changes are only made
               permanent when you call a <c>Save()</c> method.
             </para>
            
             <para>
               According to <see
               href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">PKWARE's
               zip specification</see>, the comment is not encrypted, even if there is a
               password set on the zip file.
             </para>
            
             <para>
               The specification does not describe how to indicate the encoding used
               on a comment string. Many "compliant" zip tools and libraries use
               IBM437 as the code page for comments; DotNetZip, too, follows th